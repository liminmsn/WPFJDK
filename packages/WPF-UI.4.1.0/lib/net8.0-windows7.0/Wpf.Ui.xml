<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Wpf.Ui</name>
    </assembly>
    <members>
        <member name="T:Wpf.Ui.Animations.Transition">
            <summary>
            Available types of transitions.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Animations.Transition.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Animations.Transition.FadeIn">
            <summary>
            Change opacity.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Animations.Transition.FadeInWithSlide">
            <summary>
            Change opacity and slide from bottom.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Animations.Transition.SlideBottom">
            <summary>
            Slide from bottom.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Animations.Transition.SlideRight">
            <summary>
            Slide from the right side.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Animations.Transition.SlideLeft">
            <summary>
            Slide from the left side.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Animations.TransitionAnimationProvider">
            <summary>
            Provides tools for <see cref="T:System.Windows.FrameworkElement"/> animation.
            </summary>
            <example>
            <code lang="csharp">
            TransitionAnimationProvider.ApplyTransition(MyFrameworkElement, Transition.FadeIn, 500);
            </code>
            </example>
        </member>
        <member name="M:Wpf.Ui.Animations.TransitionAnimationProvider.ApplyTransition(System.Object,Wpf.Ui.Animations.Transition,System.Int32)">
            <summary>
            Attempts to apply an animation effect while adding content to the frame.
            </summary>
            <param name="element">Currently rendered element.</param>
            <param name="type">Selected transition type.</param>
            <param name="duration">Transition duration.</param>
            <returns>Returns <see langword="true"/> if the transition was applied. Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="T:Wpf.Ui.Appearance.ApplicationAccentColorManager">
            <summary>
            Allows updating the accents used by controls in the application by swapping dynamic resources.
            </summary>
            <example>
            <code lang="csharp">
            ApplicationAccentColorManager.Apply(
                Color.FromArgb(0xFF, 0xEE, 0x00, 0xBB),
                ApplicationTheme.Dark,
                false
            );
            </code>
            <code lang="csharp">
            ApplicationAccentColorManager.Apply(
                ApplicationAccentColorManager.GetColorizationColor(),
                ApplicationTheme.Dark,
                false
            );
            </code>
            </example>
        </member>
        <member name="F:Wpf.Ui.Appearance.ApplicationAccentColorManager.BackgroundBrightnessThresholdValue">
            <summary>
            The maximum value of the background HSV brightness after which the text on the accent will be turned dark.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.SystemAccent">
            <summary>
            Gets the SystemAccentColor.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.SystemAccentBrush">
            <summary>
            Gets the <see cref="T:System.Windows.Media.Brush"/> of the SystemAccentColor.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.PrimaryAccent">
            <summary>
            Gets the SystemAccentColorPrimary.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.PrimaryAccentBrush">
            <summary>
            Gets the <see cref="T:System.Windows.Media.Brush"/> of the SystemAccentColorPrimary.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.SecondaryAccent">
            <summary>
            Gets the SystemAccentColorSecondary.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.SecondaryAccentBrush">
            <summary>
            Gets the <see cref="T:System.Windows.Media.Brush"/> of the SystemAccentColorSecondary.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.TertiaryAccent">
            <summary>
            Gets the SystemAccentColorTertiary.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.TertiaryAccentBrush">
            <summary>
            Gets the <see cref="T:System.Windows.Media.Brush"/> of the SystemAccentColorTertiary.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ApplicationAccentColorManager.IsAccentColorOnTitleBarsEnabled">
            <summary>
            Gets a value indicating whether the user has enabled accent color on title bars and window borders in Windows settings.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationAccentColorManager.Apply(System.Windows.Media.Color,Wpf.Ui.Appearance.ApplicationTheme,System.Boolean)">
            <summary>
            Changes the color accents of the application based on the color entered.
            </summary>
            <param name="systemAccent">Primary accent color.</param>
            <param name="applicationTheme">If <see cref="F:Wpf.Ui.Appearance.ApplicationTheme.Dark"/>, the colors will be different.</param>
            <param name="systemGlassColor">If the color is taken from the Glass Color System, its brightness will be increased with the help of the operations on HSV space.</param>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationAccentColorManager.Apply(System.Windows.Media.Color,System.Windows.Media.Color,System.Windows.Media.Color,System.Windows.Media.Color)">
            <summary>
            Changes the color accents of the application based on the entered colors.
            </summary>
            <param name="systemAccent">Primary color.</param>
            <param name="primaryAccent">Alternative light or dark color.</param>
            <param name="secondaryAccent">Second alternative light or dark color (most used).</param>
            <param name="tertiaryAccent">Third alternative light or dark color.</param>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationAccentColorManager.ApplySystemAccent">
            <summary>
            Applies system accent color to the application.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationAccentColorManager.GetColorizationColor">
            <summary>
            Gets current Desktop Window Manager colorization color.
            <para>It should be the color defined in the system Personalization.</para>
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationAccentColorManager.UpdateColorResources(Wpf.Ui.Appearance.ApplicationTheme,System.Windows.Media.Color,System.Windows.Media.Color,System.Windows.Media.Color,System.Windows.Media.Color)">
            <summary>
            Updates application resources.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationAccentColorManager.GetUiColor(Wpf.Ui.Appearance.UISettingsRCW.UIColorType)">
            <summary>
            Gets the color of the UI.
            </summary>
            <param name="colorType">Type of the color.</param>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationAccentColorManager.GetWinRTInstance">
            <summary>
              Gets the WinRT instance of UISettings.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Appearance.ApplicationTheme">
            <summary>
            Theme in which an application using WPF UI is displayed.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.ApplicationTheme.Unknown">
            <summary>
            Unknown application theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.ApplicationTheme.Dark">
            <summary>
            Dark application theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.ApplicationTheme.Light">
            <summary>
            Light application theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.ApplicationTheme.HighContrast">
            <summary>
            High contract application theme.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Appearance.ApplicationThemeManager">
            <summary>
            Allows to manage the application theme by swapping resource dictionaries containing dynamic resources with color information.
            </summary>
            <example>
            <code lang="csharp">
            ApplicationThemeManager.Apply(
                ApplicationTheme.Light
            );
            </code>
            <code lang="csharp">
            if (ApplicationThemeManager.GetAppTheme() == ApplicationTheme.Dark)
            {
                ApplicationThemeManager.Apply(
                    ApplicationTheme.Light
                );
            }
            </code>
            <code>
            ApplicationThemeManager.Changed += (theme, accent) =>
            {
                Debug.WriteLine($"Application theme changed to {theme.ToString()}");
            };
            </code>
            </example>
        </member>
        <member name="E:Wpf.Ui.Appearance.ApplicationThemeManager.Changed">
            <summary>
            Event triggered when the application's theme is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.IsHighContrast">
            <summary>
            Gets a value that indicates whether the application is currently using the high contrast theme.
            </summary>
            <returns><see langword="true"/> if application uses high contrast theme.</returns>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.IsSystemHighContrast">
            <summary>
            Gets a value that indicates whether the Windows is currently using the high contrast theme.
            </summary>
            <returns><see langword="true"/> if system uses high contrast theme.</returns>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.Apply(Wpf.Ui.Appearance.ApplicationTheme,Wpf.Ui.Controls.WindowBackdropType,System.Boolean)">
            <summary>
            Changes the current application theme.
            </summary>
            <param name="applicationTheme">Theme to set.</param>
            <param name="backgroundEffect">Whether the custom background effect should be applied.</param>
            <param name="updateAccent">Whether the color accents should be changed.</param>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.Apply(System.Windows.FrameworkElement)">
            <summary>
            Applies Resources in the <paramref name="frameworkElement"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.GetAppTheme">
            <summary>
            Gets currently set application theme.
            </summary>
            <returns><see cref="F:Wpf.Ui.Appearance.ApplicationTheme.Unknown"/> if something goes wrong.</returns>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.GetSystemTheme">
            <summary>
            Gets currently set system theme.
            </summary>
            <returns><see cref="F:Wpf.Ui.Appearance.SystemTheme.Unknown"/> if something goes wrong.</returns>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.IsAppMatchesSystem">
            <summary>
            Gets a value that indicates whether the application is matching the system theme.
            </summary>
            <returns><see langword="true"/> if the application has the same theme as the system.</returns>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.IsMatchedDark">
            <summary>
            Checks if the application and the operating system are currently working in a dark theme.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.IsMatchedLight">
            <summary>
            Checks if the application and the operating system are currently working in a light theme.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ApplicationThemeManager.FetchApplicationTheme">
            <summary>
            Tries to guess the currently set application theme.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Appearance.ObservedWindow">
            <summary>
            Represents a window that is being observed for changes in appearance.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ObservedWindow.#ctor(System.IntPtr,Wpf.Ui.Controls.WindowBackdropType,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Appearance.ObservedWindow"/> class.
            </summary>
            <param name="handle">The handle of the window.</param>
            <param name="backdrop">The backdrop type of the window.</param>
            <param name="updateAccents">Indicates whether to update accents.</param>
        </member>
        <member name="P:Wpf.Ui.Appearance.ObservedWindow.RootVisual">
            <summary>
            Gets the root visual of the window.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ObservedWindow.Handle">
            <summary>
            Gets the handle of the window.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ObservedWindow.Backdrop">
            <summary>
            Gets the backdrop type of the window.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ObservedWindow.UpdateAccents">
            <summary>
            Gets a value indicating whether to update accents.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ObservedWindow.HasHook">
            <summary>
            Gets a value indicating whether the window has a hook.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ObservedWindow.AddHook(System.Windows.Interop.HwndSourceHook)">
            <summary>
            Adds a hook to the window.
            </summary>
            <param name="hook">The hook to add.</param>
        </member>
        <member name="M:Wpf.Ui.Appearance.ObservedWindow.RemoveHook(System.Windows.Interop.HwndSourceHook)">
            <summary>
            Removes a hook from the window.
            </summary>
            <param name="hook">The hook to remove.</param>
        </member>
        <member name="T:Wpf.Ui.Appearance.ResourceDictionaryManager">
            <summary>
            Allows managing application dictionaries.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.ResourceDictionaryManager.SearchNamespace">
            <summary>
            Gets the namespace, e.g. the library the resource is being searched for.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.ResourceDictionaryManager.HasDictionary(System.String)">
            <summary>
            Shows whether the application contains the <see cref="T:System.Windows.ResourceDictionary"/>.
            </summary>
            <param name="resourceLookup">Any part of the resource name.</param>
            <returns><see langword="false"/> if it doesn't exist.</returns>
        </member>
        <member name="M:Wpf.Ui.Appearance.ResourceDictionaryManager.GetDictionary(System.String)">
            <summary>
            Gets the <see cref="T:System.Windows.ResourceDictionary"/> if exists.
            </summary>
            <param name="resourceLookup">Any part of the resource name.</param>
            <returns><see cref="T:System.Windows.ResourceDictionary"/>, <see langword="null"/> if it doesn't exist.</returns>
        </member>
        <member name="M:Wpf.Ui.Appearance.ResourceDictionaryManager.UpdateDictionary(System.String,System.Uri)">
            <summary>
            Shows whether the application contains the <see cref="T:System.Windows.ResourceDictionary"/>.
            </summary>
            <param name="resourceLookup">Any part of the resource name.</param>
            <param name="newResourceUri">A valid <see cref="T:System.Uri"/> for the replaced resource.</param>
            <returns><see langword="true"/> if the dictionary <see cref="T:System.Uri"/> was updated. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:Wpf.Ui.Appearance.SystemTheme">
            <summary>
            Windows 11 themes.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.Unknown">
            <summary>
            Unknown Windows theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.Custom">
            <summary>
            Custom Windows theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.Light">
            <summary>
            Default light theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.Dark">
            <summary>
            Default dark theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.HCWhite">
            <summary>
            High-contrast theme: Desert
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.HCBlack">
            <summary>
            High-contrast theme: Acquatic
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.HC1">
            <summary>
            High-contrast theme: Dusk
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.HC2">
            <summary>
            High-contrast theme: Nightsky
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.Glow">
            <summary>
            Dark theme: Glow
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.CapturedMotion">
            <summary>
            Dark theme: Captured Motion
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.Sunrise">
            <summary>
            Light theme: Sunrise
            </summary>
        </member>
        <member name="F:Wpf.Ui.Appearance.SystemTheme.Flow">
            <summary>
            Light theme: Flow
            </summary>
        </member>
        <member name="T:Wpf.Ui.Appearance.SystemThemeManager">
            <summary>
            Provides information about Windows system themes.
            </summary>
            <example>
            <code lang="csharp">
            var currentWindowTheme = SystemThemeManager.GetCachedSystemTheme();
            </code>
            <code lang="csharp">
            SystemThemeManager.UpdateSystemThemeCache();
            var currentWindowTheme = SystemThemeManager.GetCachedSystemTheme();
            </code>
            </example>
        </member>
        <member name="P:Wpf.Ui.Appearance.SystemThemeManager.GlassColor">
            <summary>
            Gets the Windows glass color.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Appearance.SystemThemeManager.HighContrast">
            <summary>
            Gets a value indicating whether the system is currently using the high contrast theme.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.SystemThemeManager.GetCachedSystemTheme">
            <summary>
            Returns the Windows theme retrieved from the registry. If it has not been cached before, invokes the <see cref="M:Wpf.Ui.Appearance.SystemThemeManager.UpdateSystemThemeCache"/> and then returns the currently obtained theme.
            </summary>
            <returns>Currently cached Windows theme.</returns>
        </member>
        <member name="M:Wpf.Ui.Appearance.SystemThemeManager.UpdateSystemThemeCache">
            <summary>
            Refreshes the currently saved system theme.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Appearance.SystemThemeWatcher">
            <summary>
            Automatically updates the application background if the system theme or color is changed.
            <para><see cref="T:Wpf.Ui.Appearance.SystemThemeWatcher"/> settings work globally and cannot be changed for each <see cref="T:System.Windows.Window"/>.</para>
            </summary>
            <example>
            <code lang="csharp">
            SystemThemeWatcher.Watch(this as System.Windows.Window);
            SystemThemeWatcher.UnWatch(this as System.Windows.Window);
            </code>
            <code lang="csharp">
            SystemThemeWatcher.Watch(
                _serviceProvider.GetRequiredService&lt;MainWindow&gt;()
            );
            </code>
            </example>
        </member>
        <member name="M:Wpf.Ui.Appearance.SystemThemeWatcher.Watch(System.Windows.Window,Wpf.Ui.Controls.WindowBackdropType,System.Boolean)">
            <summary>
            Watches the <see cref="T:System.Windows.Window"/> and applies the background effect and theme according to the system theme.
            </summary>
            <param name="window">The window that will be updated.</param>
            <param name="backdrop">Background effect to be applied when changing the theme.</param>
            <param name="updateAccents">If <see langword="true"/>, the accents will be updated when the change is detected.</param>
        </member>
        <member name="M:Wpf.Ui.Appearance.SystemThemeWatcher.UnWatch(System.Windows.Window)">
            <summary>
            Unwatches the window and removes the hook to receive messages from the system.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.SystemThemeWatcher.WndProc(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Boolean@)">
            <summary>
            Listens to system messages on the application windows.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Appearance.ThemeChangedEvent">
            <summary>
            Event triggered when application theme is updated.
            </summary>
            <param name="currentApplicationTheme">Current application <see cref="T:Wpf.Ui.Appearance.ApplicationTheme"/>.</param>
            <param name="systemAccent">Current base system accent <see cref="T:System.Windows.Media.Color"/>.</param>
        </member>
        <member name="T:Wpf.Ui.Appearance.UISettingsRCW">
            <summary>
            Contains internal RCWs for invoking the UISettings
            </summary>
        </member>
        <member name="T:Wpf.Ui.Appearance.UISettingsRCW.NativeMethods">
            <summary>
            Contains internal RCWs for invoking the InputPane (tiptsf touch keyboard)
            </summary>
        </member>
        <member name="T:Wpf.Ui.Appearance.WindowBackgroundManager">
            <summary>
            Facilitates the management of the window background.
            </summary>
            <example>
            <code lang="csharp">
            WindowBackgroundManager.UpdateBackground(
                observedWindow.RootVisual,
                currentApplicationTheme,
                observedWindow.Backdrop
            );
            </code>
            </example>
        </member>
        <member name="M:Wpf.Ui.Appearance.WindowBackgroundManager.ApplyDarkThemeToWindow(System.Windows.Window)">
            <summary>
            Tries to apply dark theme to <see cref="T:System.Windows.Window"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.WindowBackgroundManager.RemoveDarkThemeFromWindow(System.Windows.Window)">
            <summary>
            Tries to remove dark theme from <see cref="T:System.Windows.Window"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Appearance.WindowBackgroundManager.UpdateBackground(System.Windows.Window,Wpf.Ui.Appearance.ApplicationTheme,Wpf.Ui.Controls.WindowBackdropType)">
            <summary>
            Forces change to application background. Required if custom background effect was previously applied.
            </summary>
        </member>
        <member name="T:Wpf.Ui.AutomationPeers.CardControlAutomationPeer">
            <summary>
            Provides UI Automation peer for the CardControl.
            </summary>
        </member>
        <member name="M:Wpf.Ui.AutomationPeers.CardControlAutomationPeer.#ctor(Wpf.Ui.Controls.CardControl)">
            <summary>
            Provides UI Automation peer for the CardControl.
            </summary>
        </member>
        <member name="T:Wpf.Ui.ContentDialogService">
             <summary>
             Represents a contract with the service that creates <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
             </summary>
             <example>
             <code lang="xml">
             &lt;ContentPresenter x:Name="RootContentDialogPresenter" Grid.Row="0" /&gt;
             </code>
             <code lang="csharp">
             IContentDialogService contentDialogService = new ContentDialogService();
             contentDialogService.SetContentPresenter(RootContentDialogPresenter);
            
             await _contentDialogService.ShowAsync(
                 new ContentDialog(){
                     Title = "The cake?",
                     Content = "IS A LIE!",
                     PrimaryButtonText = "Save",
                     SecondaryButtonText = "Don't Save",
                     CloseButtonText = "Cancel"
                 }
             );
             </code>
             </example>
        </member>
        <member name="M:Wpf.Ui.ContentDialogService.SetDialogHost(System.Windows.Controls.ContentPresenter)">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.ContentDialogService.GetDialogHost">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.ContentDialogService.ShowAsync(Wpf.Ui.Controls.ContentDialog,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:Wpf.Ui.Controls.Anchor">
            <summary>
            Creates a hyperlink to web pages, files, email addresses, locations in the same page, or anything else a URL can address.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:Anchor
                NavigateUri="https://lepo.co/" /&gt;
            </code>
            </example>
        </member>
        <member name="T:Wpf.Ui.Controls.Arc">
            <summary>
            Control that draws a symmetrical arc with rounded edges.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:Arc
                EndAngle="359"
                StartAngle="0"
                Stroke="{ui:ThemeResource SystemAccentColorSecondaryBrush}"
                StrokeThickness="2"
                Visibility="Visible" /&gt;
            </code>
            </example>
        </member>
        <member name="F:Wpf.Ui.Controls.Arc.StartAngleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Arc.StartAngle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Arc.EndAngleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Arc.EndAngle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Arc.SweepDirectionProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Arc.SweepDirection"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Arc.StartAngle">
            <summary>
            Gets or sets the initial angle from which the arc will be drawn.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Arc.EndAngle">
            <summary>
            Gets or sets the final angle from which the arc will be drawn.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Arc.SweepDirection">
            <summary>
            Gets or sets the direction to where the arc will be drawn.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Arc.IsLargeArc">
            <summary>
            Gets a value indicating whether one of the two larger arc sweeps is chosen; otherwise, if is <see langword="false"/>, one of the smaller arc sweeps is chosen.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Arc.DefiningGeometry">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.Arc.DefinedGeometry">
            <summary>
            Get the geometry that defines this shape.
            <para><see href="https://stackoverflow.com/a/36756365/13224348">Based on Mark Feldman implementation.</see></para>
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Arc.PointAtAngle(System.Double)">
            <summary>
            Draws a point on the coordinates of the given angle.
            <para><see href="https://stackoverflow.com/a/36756365/13224348">Based on Mark Feldman implementation.</see></para>
            </summary>
            <param name="angle">The angle at which to create the point.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.Arc.PropertyChangedCallback(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Event triggered when one of the key parameters is changed. Forces the geometry to be redrawn.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Arc.OnRender(System.Windows.Media.DrawingContext)">
            <summary>Overrides the default OnRender method to draw the <see cref="T:Wpf.Ui.Controls.Arc" /> element.</summary>
            <param name="drawingContext">A <see cref="T:System.Windows.Media.DrawingContext" /> object that is drawn during the rendering pass of this <see cref="T:System.Windows.Shapes.Shape" />.</param>
        </member>
        <member name="T:Wpf.Ui.Controls.AutoSuggestBox">
            <summary>
            Represents a text control that makes suggestions to users as they enter text using a keyboard. The app is notified when text has been changed by the user and is responsible for providing relevant suggestions for this control to display.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:AutoSuggestBox x:Name="AutoSuggestBox" PlaceholderText="Search"&gt;
                &lt;ui:AutoSuggestBox.Icon&gt;
                    &lt;ui:IconSourceElement&gt;
                        &lt;ui:SymbolIconSource Symbol="Search24" /&gt;
                    &lt;/ui:IconSourceElement&gt;
                &lt;/ui:AutoSuggestBox.Icon&gt;
            &lt;/ui:AutoSuggestBox&gt;
            </code>
            </example>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.OriginalItemsSourceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.OriginalItemsSource"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.IsSuggestionListOpenProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.IsSuggestionListOpen"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.TextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.Text"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.PlaceholderTextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.PlaceholderText"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.UpdateTextOnSelectProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.UpdateTextOnSelect"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.MaxSuggestionListHeightProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.MaxSuggestionListHeight"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.FocusCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.FocusCommand"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.ClearButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.AutoSuggestBox.ClearButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.OriginalItemsSource">
            <summary>
            Gets or sets your items here if you want to use the default filtering
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.IsSuggestionListOpen">
            <summary>
            Gets or sets a value indicating whether the drop-down portion of the <see cref="T:Wpf.Ui.Controls.AutoSuggestBox"/> is open.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.Text">
            <summary>
            Gets or sets the text that is shown in the control.
            </summary>
            <remarks>
            This property is not typically set in XAML.
            </remarks>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.PlaceholderText">
            <summary>
            Gets or sets the placeholder text to be displayed in the control.
            </summary>
            <remarks>
            The placeholder text to be displayed in the control. The default is an empty string.
            </remarks>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.MaxSuggestionListHeight">
            <summary>
            Gets or sets the maximum height for the drop-down portion of the <see cref="T:Wpf.Ui.Controls.AutoSuggestBox"/> control.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.UpdateTextOnSelect">
            <summary>
            Gets or sets a value indicating whether items in the view will trigger an update of the editable text part of the <see cref="T:Wpf.Ui.Controls.AutoSuggestBox"/> when clicked.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.ClearButtonEnabled">
            <summary>
            Gets or sets a value indicating whether to show the clear button when <see cref="T:Wpf.Ui.Controls.AutoSuggestBox"/> is focused.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.AutoSuggestBox.FocusCommand">
            <summary>
            Gets command used for focusing control.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.QuerySubmittedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.QuerySubmitted"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.SuggestionChosenEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.SuggestionChosen"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestBox.TextChangedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.TextChanged"/> routed event.</summary>
        </member>
        <member name="E:Wpf.Ui.Controls.AutoSuggestBox.QuerySubmitted">
            <summary>
            Occurs when the user submits a search query.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.AutoSuggestBox.SuggestionChosen">
            <summary>
            Event occurs when the user selects an item from the recommended ones.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.AutoSuggestBox.TextChanged">
            <summary>
            Raised after the text content of the editable control component is updated.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.AutoSuggestBox.Focus">
            <inheritdoc cref="M:System.Windows.UIElement.Focus" />
        </member>
        <member name="M:Wpf.Ui.Controls.AutoSuggestBox.OnQuerySubmitted(System.String)">
            <summary>
            Method for <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.QuerySubmitted"/>.
            </summary>
            <param name="queryText">Currently submitted query text.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.AutoSuggestBox.OnSuggestionChosen(System.Object)">
            <summary>
            Method for <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.SuggestionChosen"/>.
            </summary>
            <param name="selectedItem">Currently selected item.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.AutoSuggestBox.OnTextChanged(Wpf.Ui.Controls.AutoSuggestionBoxTextChangeReason,System.String)">
            <summary>
            Method for <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.TextChanged"/>.
            </summary>
            <param name="reason">Data for the text changed event.</param>
            <param name="text">Changed text.</param>
        </member>
        <member name="T:Wpf.Ui.Controls.AutoSuggestBoxQuerySubmittedEventArgs">
            <summary>
            Provides event data for the <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.QuerySubmitted"/> event.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.AutoSuggestBoxSuggestionChosenEventArgs">
            <summary>
            Provides data for the <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.SuggestionChosen"/> event.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.AutoSuggestBoxTextChangedEventArgs">
            <summary>
            Provides data for the <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.TextChanged"/> event.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.AutoSuggestionBoxTextChangeReason">
            <summary>
            Provides data for the <see cref="E:Wpf.Ui.Controls.AutoSuggestBox.TextChanged"/> event.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestionBoxTextChangeReason.UserInput">
            <summary>
            The user edited the text.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestionBoxTextChangeReason.ProgrammaticChange">
            <summary>
            The text was changed via code.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.AutoSuggestionBoxTextChangeReason.SuggestionChosen">
            <summary>
            The user selected one of the items in the auto-suggestion box.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.Badge">
            <summary>
            Used to highlight an item, attract attention or flag status.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:Badge Appearance="Secondary"&gt;
                &lt;TextBox Text="Hello" /&gt;
            &lt;/ui:Badge&gt;
            </code>
            </example>
        </member>
        <member name="F:Wpf.Ui.Controls.Badge.AppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Badge.Appearance"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Badge.Appearance">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.Controls.BreadcrumbBar">
            <summary>
            The <see cref="T:Wpf.Ui.Controls.BreadcrumbBar"/> control provides the direct path of pages or folders to the current location.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:BreadcrumbBar x:Name="BreadcrumbBar" /&gt;
            </code>
            </example>
        </member>
        <member name="F:Wpf.Ui.Controls.BreadcrumbBar.CommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.BreadcrumbBar.Command"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.BreadcrumbBar.TemplateButtonCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.BreadcrumbBar.TemplateButtonCommand"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.BreadcrumbBar.TemplateButtonCommand">
            <summary>
            Gets the <see cref="T:Wpf.Ui.Input.RelayCommand`1"/> triggered after clicking
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.BreadcrumbBar.ItemClickedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.BreadcrumbBar.ItemClicked"/> routed event.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.BreadcrumbBar.Command">
            <summary>
            Gets or sets custom command executed after selecting the item.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.BreadcrumbBar.ItemClicked">
            <summary>
            Occurs when an item is clicked in the <see cref="T:Wpf.Ui.Controls.BreadcrumbBar"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.BreadcrumbBar.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.BreadcrumbBar"/> class.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.BreadcrumbBarItem">
            <summary>
            Represents an item in a <see cref="T:Wpf.Ui.Controls.BreadcrumbBar"/> control.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.BreadcrumbBarItem.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.BreadcrumbBarItem.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.BreadcrumbBarItem.IconMarginProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.BreadcrumbBarItem.IconMargin"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.BreadcrumbBarItem.IsLastProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.BreadcrumbBarItem.IsLast"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.BreadcrumbBarItem.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.BreadcrumbBarItem.IconMargin">
            <summary>
            Gets or sets get or sets margin for the <see cref="P:Wpf.Ui.Controls.BreadcrumbBarItem.Icon"/>
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.BreadcrumbBarItem.IsLast">
            <summary>
            Gets or sets a value indicating whether the current item is the last one.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.BreadcrumbBarItemClickedEventArgs.Item">
            <summary>
            Gets the Content property value of the BreadcrumbBarItem that is clicked.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.BreadcrumbBarItemClickedEventArgs.Index">
            <summary>
            Gets the index of the item that was clicked.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.Button">
            <summary>
            Inherited from the <see cref="T:System.Windows.Controls.Button"/>, adding <see cref="T:Wpf.Ui.Controls.SymbolRegular"/>.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:Button
                Appearance="Primary"
                Content="WPF UI button with font icon"
                Icon="{ui:SymbolIcon Symbol=Fluent24}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:Button
                Appearance="Primary"
                Content="WPF UI button with font icon"
                Icon="{ui:FontIcon '&#x1F308;'}" /&gt;
            </code>
            </example>
            <remarks>
            The <see cref="T:Wpf.Ui.Controls.Button"/> class inherits from the base <see cref="T:System.Windows.Controls.Button"/> class.
            </remarks>
        </member>
        <member name="F:Wpf.Ui.Controls.Button.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Button.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Button.AppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Button.Appearance"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Button.MouseOverBackgroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Button.MouseOverBackground"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Button.MouseOverBorderBrushProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Button.MouseOverBorderBrush"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Button.PressedForegroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Button.PressedForeground"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Button.PressedBackgroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Button.PressedBackground"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Button.PressedBorderBrushProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Button.PressedBorderBrush"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Button.CornerRadiusProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Button.CornerRadius"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Button.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Button.Appearance">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.Button.MouseOverBackground">
            <summary>
            Gets or sets background <see cref="T:System.Windows.Media.Brush"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Button.MouseOverBorderBrush">
            <summary>
            Gets or sets border <see cref="T:System.Windows.Media.Brush"/> when the user mouses over the button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Button.PressedForeground">
            <summary>
            Gets or sets the foreground <see cref="T:System.Windows.Media.Brush"/> when the user clicks the button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Button.PressedBackground">
            <summary>
            Gets or sets background <see cref="T:System.Windows.Media.Brush"/> when the user clicks the button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Button.PressedBorderBrush">
            <summary>
            Gets or sets border <see cref="T:System.Windows.Media.Brush"/> when the user clicks the button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Button.CornerRadius">
            <summary>
            Gets or sets a value that represents the degree to which the corners of a <see cref="T:System.Windows.Controls.Border" /> are rounded.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.CalendarDatePicker">
            <summary>
            Represents a control that allows a user to pick a date from a calendar display.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:CalendarDatePicker /&gt;
            </code>
            </example>
        </member>
        <member name="F:Wpf.Ui.Controls.CalendarDatePicker.IsCalendarOpenProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CalendarDatePicker.IsCalendarOpen"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CalendarDatePicker.IsTodayHighlightedProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CalendarDatePicker.IsTodayHighlighted"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CalendarDatePicker.DateProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CalendarDatePicker.Date"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CalendarDatePicker.FirstDayOfWeekProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CalendarDatePicker.FirstDayOfWeek"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CalendarDatePicker.IsTodayHighlighted">
            <summary>
            Gets or sets a value indicating whether the current date is highlighted.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CalendarDatePicker.IsCalendarOpen">
            <summary>
            Gets or sets a value indicating whether the calendar view of the <see cref="T:Wpf.Ui.Controls.CalendarDatePicker"/> is currently shown.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CalendarDatePicker.FirstDayOfWeek">
            <summary>
            Gets or sets the day that is considered the beginning of the week.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CalendarDatePicker.Date">
            <summary>
            Gets or sets the date currently set in the calendar picker.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.CalendarDatePicker.OnClick">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.Controls.CardAction">
            <summary>
            Inherited from the <see cref="T:System.Windows.Controls.Primitives.ButtonBase"/> interactive card styled according to Fluent Design.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardAction.IsChevronVisibleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardAction.IsChevronVisible"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardAction.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardAction.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardAction.IsChevronVisible">
            <summary>
            Gets or sets a value indicating whether to display the chevron icon on the right side of the card.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardAction.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.CardColor">
            <summary>
            Ala Pa**one color card.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardColor.TitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardColor.Title"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardColor.SubtitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardColor.Subtitle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardColor.SubtitleFontSizeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardColor.SubtitleFontSize"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardColor.ColorProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardColor.Color"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardColor.BrushProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardColor.Brush"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardColor.CardBrushProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardColor.CardBrush"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardColor.Title">
            <summary>
            Gets or sets the main text displayed below the color.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardColor.Subtitle">
            <summary>
            Gets or sets text displayed under main <see cref="P:Wpf.Ui.Controls.CardColor.Title"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardColor.SubtitleFontSize">
            <summary>
            Gets or sets the font size of <see cref="P:Wpf.Ui.Controls.CardColor.Subtitle"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardColor.Color">
            <summary>
            Gets or sets the displayed <see cref="P:Wpf.Ui.Controls.CardColor.CardBrush"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardColor.Brush">
            <summary>
            Gets or sets the displayed <see cref="P:Wpf.Ui.Controls.CardColor.CardBrush"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardColor.CardBrush">
            <summary>
            Gets the <see cref="T:System.Windows.Media.Brush"/> displayed in <see cref="T:Wpf.Ui.Controls.CardColor"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.CardColor.OnSubtitlePropertyChanged">
            <summary>
            Virtual method triggered when <see cref="P:Wpf.Ui.Controls.CardColor.Subtitle"/> is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.CardColor.OnColorPropertyChanged">
            <summary>
            Virtual method triggered when <see cref="P:Wpf.Ui.Controls.CardColor.Color"/> is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.CardColor.OnBrushPropertyChanged">
            <summary>
            Virtual method triggered when <see cref="P:Wpf.Ui.Controls.CardColor.Brush"/> is changed.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.CardControl">
            <summary>
            Inherited from the <see cref="T:System.Windows.Controls.Primitives.ButtonBase"/> control which displays an additional control on the right side of the card.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardControl.HeaderProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardControl.Header"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardControl.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardControl.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardControl.CornerRadiusProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardControl.CornerRadius"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardControl.Header">
            <summary>
            Gets or sets header which is used for each item in the control.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardControl.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardControl.CornerRadius">
            <summary>
            Gets or sets the corner radius of the control.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.CardExpander">
            <summary>
            Inherited from the <see cref="T:System.Windows.Controls.Expander"/> control which can hide the collapsible content.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardExpander.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardExpander.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardExpander.CornerRadiusProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardExpander.CornerRadius"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.CardExpander.ContentPaddingProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.CardExpander.ContentPadding"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardExpander.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardExpander.CornerRadius">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.CardExpander.ContentPadding">
            <summary>
            Gets or sets content padding Property
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.Card">
            <summary>
            Simple Card with content and <see cref="P:Wpf.Ui.Controls.Card.Footer"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Card.FooterProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Card.Footer"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Card.HasFooterProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Card.HasFooter"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Card.Footer">
            <summary>
            Gets or sets additional content displayed at the bottom.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Card.HasFooter">
            <summary>
            Gets a value indicating whether the <see cref="T:Wpf.Ui.Controls.Card"/> has a <see cref="P:Wpf.Ui.Controls.Card.Footer"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ClientAreaBorder">
            <summary>
            If you use <see cref="T:System.Windows.Shell.WindowChrome"/> to extend the UI elements to the non-client area, you can include this container
            in the template of <see cref="T:System.Windows.Window"/> so that the content inside automatically fills the client area.
            Using this container can let you get rid of various margin adaptations done in
            Setter/Trigger of the style of <see cref="T:System.Windows.Window"/> when the window state changes.
            </summary>
            <example>
            <code lang="xml">
            &lt;Style
                x:Key="MyWindowCustomStyle"
                BasedOn="{StaticResource {x:Type Window}}"
                TargetType="{x:Type controls:FluentWindow}"&gt;
                &lt;Setter Property="Template" &gt;
                    &lt;Setter.Value&gt;
                        &lt;ControlTemplate TargetType="{x:Type Window}"&gt;
                            &lt;AdornerDecorator&gt;
                                &lt;controls:ClientAreaBorder
                                    Background="{TemplateBinding Background}"
                                    BorderBrush="{TemplateBinding BorderBrush}"
                                    BorderThickness="{TemplateBinding BorderThickness}"&gt;
                                    &lt;ContentPresenter x:Name="ContentPresenter" /&gt;
                                &lt;/controls:ClientAreaBorder&gt;
                            &lt;/AdornerDecorator&gt;
                        &lt;/ControlTemplate&gt;
                    &lt;/Setter.Value&gt;
                &lt;/Setter&gt;
            &lt;/Style&gt;
            </code>
            </example>
        </member>
        <member name="P:Wpf.Ui.Controls.ClientAreaBorder.PaddedBorderThickness">
            <summary>
            Gets the system value for the padded border thickness in WPF units.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ClientAreaBorder.ResizeFrameBorderThickness">
            <summary>
            Gets the system <see cref="F:Windows.Win32.UI.WindowsAndMessaging.SYSTEM_METRICS_INDEX.SM_CXFRAME"/> and <see cref="F:Windows.Win32.UI.WindowsAndMessaging.SYSTEM_METRICS_INDEX.SM_CYFRAME"/> values in WPF units.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ClientAreaBorder.WindowChromeNonClientFrameThickness">
            <summary>
            Gets the thickness of the window's non-client frame used for maximizing the window with a custom chrome.
            </summary>
            <remarks>
            If you use a <see cref="T:System.Windows.Shell.WindowChrome"/> to extend the client area of a window to the non-client area, you need to handle the edge margin issue when the window is maximized.
            Use this property to get the correct margin value when the window is maximized, so that when the window is maximized, the client area can completely cover the screen client area by no less than a single pixel at any DPI.
            The<see cref="M:Windows.Win32.PInvoke.GetSystemMetrics(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_METRICS_INDEX)"/> method cannot obtain this value directly.
            </remarks>
        </member>
        <member name="M:Wpf.Ui.Controls.ClientAreaBorder.OnVisualParentChanged(System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.Controls.ColorPicker">
            <summary>
            Represents a control that lets a user pick a color using a color spectrum, sliders, and text input.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ContentDialog">
             <summary>
             Dialogue displayed inside the application covering its internals, displaying some content.
             </summary>
             <example>
             <code lang="xml">
             &lt;ContentPresenter x:Name="RootContentDialogPresenter" Grid.Row="0" /&gt;
             </code>
             <code lang="csharp">
             var contentDialog = new ContentDialog(RootContentDialogPresenter);
            
             contentDialog.SetCurrentValue(ContentDialog.TitleProperty, "Hello World");
             contentDialog.SetCurrentValue(ContentControl.ContentProperty, "This is a message");
             contentDialog.SetCurrentValue(ContentDialog.CloseButtonTextProperty, "Close this dialog");
            
             await contentDialog.ShowAsync(cancellationToken);
             </code>
             <code lang="csharp">
             var contentDialogService = new ContentDialogService();
             contentDialogService.SetContentPresenter(RootContentDialogPresenter);
            
             await _contentDialogService.ShowSimpleDialogAsync(
                 new SimpleContentDialogCreateOptions()
                     {
                         Title = "The cake?",
                         Content = "IS A LIE!",
                         PrimaryButtonText = "Save",
                         SecondaryButtonText = "Don't Save",
                         CloseButtonText = "Cancel"
                     }
                 );
             </code>
             </example>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.TitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.Title"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.TitleTemplateProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.TitleTemplate"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.DialogWidthProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.DialogWidth"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.DialogHeightProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.DialogHeight"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.DialogMaxWidthProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.DialogMaxWidth"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.DialogMaxHeightProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.DialogMaxHeight"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.DialogMarginProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.DialogMargin"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.PrimaryButtonTextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.PrimaryButtonText"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.SecondaryButtonTextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.SecondaryButtonText"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.CloseButtonTextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.CloseButtonText"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.PrimaryButtonIconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.PrimaryButtonIcon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.SecondaryButtonIconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.SecondaryButtonIcon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.CloseButtonIconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.CloseButtonIcon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.IsPrimaryButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.IsPrimaryButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.IsSecondaryButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.IsSecondaryButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.PrimaryButtonAppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.PrimaryButtonAppearance"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.SecondaryButtonAppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.SecondaryButtonAppearance"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.CloseButtonAppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.CloseButtonAppearance"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.DefaultButtonProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.DefaultButton"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.IsFooterVisibleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.IsFooterVisible"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.TemplateButtonCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ContentDialog.TemplateButtonCommand"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.OpenedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.ContentDialog.Opened"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.ClosingEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.ContentDialog.Closing"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.ClosedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.ContentDialog.Closed"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialog.ButtonClickedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.ContentDialog.ButtonClicked"/> routed event.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.Title">
            <summary>
            Gets or sets the title of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.TitleTemplate">
            <summary>
            Gets or sets the title template of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.DialogWidth">
            <summary>
            Gets or sets the width of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.DialogHeight">
            <summary>
            Gets or sets the height of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.DialogMaxWidth">
            <summary>
            Gets or sets the max width of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.DialogMaxHeight">
            <summary>
            Gets or sets the max height of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.DialogMargin">
            <summary>
            Gets or sets the margin of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.PrimaryButtonText">
            <summary>
            Gets or sets the text to display on the primary button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.SecondaryButtonText">
            <summary>
            Gets or sets the text to be displayed on the secondary button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.CloseButtonText">
            <summary>
            Gets or sets the text to display on the close button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.PrimaryButtonIcon">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> on the secondary button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.SecondaryButtonIcon">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> on the primary button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.CloseButtonIcon">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> on the close button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.IsPrimaryButtonEnabled">
            <summary>
            Gets or sets a value indicating whether the <see cref="T:Wpf.Ui.Controls.ContentDialog"/> primary button is enabled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.IsSecondaryButtonEnabled">
            <summary>
            Gets or sets a value indicating whether the <see cref="T:Wpf.Ui.Controls.ContentDialog"/> secondary button is enabled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.PrimaryButtonAppearance">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.ControlAppearance"/> to apply to the primary button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.SecondaryButtonAppearance">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.ControlAppearance"/> to apply to the secondary button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.CloseButtonAppearance">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.ControlAppearance"/> to apply to the close button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.DefaultButton">
            <summary>
            Gets or sets a value that indicates which button on the dialog is the default action.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.IsFooterVisible">
            <summary>
            Gets or sets a value indicating whether the footer buttons are visible.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.TemplateButtonCommand">
            <summary>
            Gets command triggered after clicking the button in the template.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.ContentDialog.Opened">
            <summary>
            Occurs after the dialog is opened.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.ContentDialog.Closing">
            <summary>
            Occurs after the dialog starts to close, but before it is closed and before the <see cref="E:Wpf.Ui.Controls.ContentDialog.Closed"/> event occurs.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.ContentDialog.Closed">
            <summary>
            Occurs after the dialog is closed.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.ContentDialog.ButtonClicked">
            <summary>
            Occurs after the <see cref="T:Wpf.Ui.Controls.ContentDialogButton"/> has been tapped.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ContentDialog.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/> class.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ContentDialog.#ctor(System.Windows.Controls.ContentPresenter)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/> class.
            </summary>
            <param name="dialogHost"><see cref="P:Wpf.Ui.Controls.ContentDialog.DialogHost"/> inside of which the dialogue will be placed. The new <see cref="T:Wpf.Ui.Controls.ContentDialog"/> will replace the current <see cref="P:System.Windows.Controls.ContentPresenter.Content"/>.</param>
        </member>
        <member name="P:Wpf.Ui.Controls.ContentDialog.DialogHost">
            <summary>
             Gets or sets <see cref="P:Wpf.Ui.Controls.ContentDialog.DialogHost"/> inside of which the dialogue will be placed. The new <see cref="T:Wpf.Ui.Controls.ContentDialog"/> will replace the current <see cref="P:System.Windows.Controls.ContentPresenter.Content"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ContentDialog.ShowAsync(System.Threading.CancellationToken)">
            <summary>
            Shows the dialog
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ContentDialog.Hide(Wpf.Ui.Controls.ContentDialogResult)">
            <summary>
            Hides the dialog with result
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ContentDialog.OnClosed(Wpf.Ui.Controls.ContentDialogResult)">
            <summary>
            Occurs after ContentPresenter.Content = null
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ContentDialog.OnButtonClick(Wpf.Ui.Controls.ContentDialogButton)">
            <summary>
            Invoked when a <see cref="T:Wpf.Ui.Controls.ContentDialogButton"/> is clicked.
            </summary>
            <param name="button">The button that was clicked.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.ContentDialog.OnLoaded">
            <summary>
            Occurs after Loaded event
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ContentDialogButton">
            <summary>
            Defines constants that specify the default button on a <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialogButton.Primary">
            <summary>
            The primary button is the default.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialogButton.Secondary">
            <summary>
            The secondary button is the default.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialogButton.Close">
            <summary>
            The close button is the default.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ContentDialogResult">
            <summary>
            Specifies identifiers to indicate the return value of a <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialogResult.None">
            <summary>
            No button was tapped.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialogResult.Primary">
            <summary>
            The primary button was tapped by the user.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ContentDialogResult.Secondary">
            <summary>
            The secondary button was tapped by the user.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ContextMenuLoader">
            <summary>
            Overwrites ContextMenu-Style for some UIElements (like RichTextBox) that don't take the default ContextMenu-Style by default.
            <para>The code inside this CodeBehind-Class forces this ContextMenu-Style on these UIElements through Reflection (because it is only accessible through Reflection it is also only possible through CodeBehind and not XAML)</para>
            </summary>
            <summary>
            ContextMenuLoader
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ContextMenuLoader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.ContextMenuLoader"/> class and registers editing styles
            defined in "ContextMenu.xaml" with the <see cref="T:System.Windows.Threading.Dispatcher"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ContextMenuLoader.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ControlAppearance">
            <summary>
            Types of the available color accents of the controls.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Primary">
            <summary>
            Control color according to the current theme accent.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Secondary">
            <summary>
            Control color according to the current theme element.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Info">
            <summary>
            Blue color theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Dark">
            <summary>
            Dark color theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Light">
            <summary>
            Light color theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Danger">
            <summary>
            Red color theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Success">
            <summary>
            Green color theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Caution">
            <summary>
            Orange color theme.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ControlAppearance.Transparent">
            <summary>
            Transparent color theme.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ControlsServices">
            <summary>
            Used to initialize the library controls with static values.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ControlsServices.Initialize(System.IServiceProvider)">
            <summary>
            Accepts a ServiceProvider for configuring dependency injection.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.DataGrid">
            <summary>
            A DataGrid control that displays data in rows and columns and allows
            for the entering and editing of data.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DataGrid.CheckBoxColumnElementStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DataGrid.CheckBoxColumnElementStyle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DataGrid.CheckBoxColumnEditingElementStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DataGrid.CheckBoxColumnEditingElementStyle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DataGrid.ComboBoxColumnElementStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DataGrid.ComboBoxColumnElementStyle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DataGrid.ComboBoxColumnEditingElementStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DataGrid.ComboBoxColumnEditingElementStyle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DataGrid.TextColumnElementStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DataGrid.TextColumnElementStyle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DataGrid.TextColumnEditingElementStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DataGrid.TextColumnEditingElementStyle"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DataGrid.CheckBoxColumnElementStyle">
            <summary>
            Gets or sets the style which is applied to all checkbox column in the DataGrid
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DataGrid.CheckBoxColumnEditingElementStyle">
            <summary>
            Gets or sets the style for all the column checkboxes in the DataGrid
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DataGrid.ComboBoxColumnElementStyle">
            <summary>
            Gets or sets the style which is applied to all combobox column in the DataGrid
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DataGrid.ComboBoxColumnEditingElementStyle">
            <summary>
            Gets or sets the style for all the column comboboxes in the DataGrid
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DataGrid.TextColumnElementStyle">
            <summary>
            Gets or sets the style which is applied to all textbox column in the DataGrid
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DataGrid.TextColumnEditingElementStyle">
            <summary>
            Gets or sets the style for all the column textboxes in the DataGrid
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.DropDownButton">
            <summary>
            A control that drop downs a flyout of choices from which one can be chosen.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DropDownButton.FlyoutProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DropDownButton.Flyout"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DropDownButton.IsDropDownOpenProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DropDownButton.IsDropDownOpen"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DropDownButton.Flyout">
            <summary>
            Gets or sets the flyout associated with this button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DropDownButton.IsDropDownOpen">
            <summary>
            Gets or sets a value indicating whether the drop-down for a button is currently open.
            </summary>
            <returns>
            <see langword="true" /> if the drop-down is open; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.DropDownButton.OnFlyoutChanged(System.Object)">
            <summary>This method is invoked when the <see cref="F:Wpf.Ui.Controls.DropDownButton.FlyoutProperty"/> changes.</summary>
            <param name="value">The new value of <see cref="F:Wpf.Ui.Controls.DropDownButton.FlyoutProperty"/>.</param>
        </member>
        <member name="T:Wpf.Ui.Controls.DynamicScrollBar">
            <summary>
            Custom <see cref="T:System.Windows.Controls.Primitives.ScrollBar"/> with events depending on actions taken by the user.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DynamicScrollBar.IsScrollingProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DynamicScrollBar.IsScrolling"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DynamicScrollBar.IsInteractedProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DynamicScrollBar.IsInteracted"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DynamicScrollBar.TimeoutProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DynamicScrollBar.Timeout"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DynamicScrollBar.IsScrolling">
            <summary>
            Gets or sets a value indicating whether the user was recently scrolling in the last few seconds.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DynamicScrollBar.IsInteracted">
            <summary>
            Gets or sets a value indicating whether the user has taken an action related to scrolling.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DynamicScrollBar.Timeout">
            <summary>
            Gets or sets additional delay after which the <see cref="T:Wpf.Ui.Controls.DynamicScrollBar"/> should be hidden.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.DynamicScrollBar.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
            <summary>
            Method reporting the mouse entered this element.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.DynamicScrollBar.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
            <summary>
            Method reporting the mouse leaved this element.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.DynamicScrollViewer">
            <summary>
            Custom <see cref="T:System.Windows.Controls.ScrollViewer"/> with events depending on actions taken by the user.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DynamicScrollViewer.IsScrollingVerticallyProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DynamicScrollViewer.IsScrollingVertically"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DynamicScrollViewer.IsScrollingHorizontallyProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DynamicScrollViewer.IsScrollingHorizontally"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DynamicScrollViewer.MinimalChangeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DynamicScrollViewer.MinimalChange"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.DynamicScrollViewer.TimeoutProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.DynamicScrollViewer.Timeout"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DynamicScrollViewer.IsScrollingVertically">
            <summary>
            Gets or sets a value indicating whether the user was scrolling vertically for the last few seconds.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DynamicScrollViewer.IsScrollingHorizontally">
            <summary>
            Gets or sets a value indicating whether the user was scrolling horizontally for the last few seconds.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DynamicScrollViewer.MinimalChange">
            <summary>
            Gets or sets the value required for the scroll to show automatically.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.DynamicScrollViewer.Timeout">
            <summary>
            Gets or sets time after which the scroll is to be hidden.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.DynamicScrollViewer.OnScrollChanged(System.Windows.Controls.ScrollChangedEventArgs)">
            <summary>
            OnScrollChanged is an override called whenever scrolling state changes on this <see cref="T:Wpf.Ui.Controls.DynamicScrollViewer"/>.
            </summary>
            <remarks>
            OnScrollChanged fires the ScrollChangedEvent. Overriders of this method should call
            base.OnScrollChanged(args) if they want the event to be fired.
            </remarks>
            <param name="e">ScrollChangedEventArgs containing information about the change in scrolling state.</param>
        </member>
        <member name="P:Wpf.Ui.Controls.EffectThicknessDecorator.Thickness">
            <summary>
            Gets or sets the thickness of the effect around the containing element.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.EffectThicknessDecorator.VisualChildrenCount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.EffectThicknessDecorator.OnVisualParentChanged(System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.EffectThicknessDecorator.GetVisualChild(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.EffectThicknessDecorator.OnInitialized(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.Controls.ElementPlacement">
            <summary>
            Decides where to put the element.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ElementPlacement.Left">
            <summary>
            Puts the control element on the left.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ElementPlacement.Right">
            <summary>
            Puts the control element on the right.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.EventIdentifier">
            <summary>
            Class used to create identifiers of threads or tasks that can be performed multiple times within one instance.
            <see cref="P:Wpf.Ui.Controls.EventIdentifier.Current"/> represents roughly the time in microseconds at which it was taken.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.EventIdentifier.Current">
            <summary>
            Gets or sets the current identifier.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.EventIdentifier.GetNext">
            <summary>
            Creates and gets the next identifier.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.EventIdentifier.IsEqual(System.Int64)">
            <summary>
            Checks if the identifiers are the same.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.EventIdentifier.UpdateIdentifier">
            <summary>
            Creates and assigns a random value with an extra time code if possible.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.FluentWindow">
            <summary>
            A custom WinUI Window with more convenience methods.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.FluentWindow.InteropHelper">
            <summary>
            Gets contains helper for accessing this window handle.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FluentWindow.WindowCornerPreferenceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FluentWindow.WindowCornerPreference"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FluentWindow.WindowBackdropTypeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FluentWindow.WindowBackdropType"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FluentWindow.ExtendsContentIntoTitleBarProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FluentWindow.ExtendsContentIntoTitleBar"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.FluentWindow.WindowCornerPreference">
            <summary>
            Gets or sets a value determining corner preference for current <see cref="T:System.Windows.Window"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.FluentWindow.WindowBackdropType">
            <summary>
            Gets or sets a value determining preferred backdrop type for current <see cref="T:System.Windows.Window"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.FluentWindow.ExtendsContentIntoTitleBar">
            <summary>
            Gets or sets a value indicating whether the default title bar of the window should be hidden to create space for app content.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.FluentWindow"/> class.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Wpf.Ui.Controls.FluentWindow"/> class.
            Overrides default properties.
            </summary>
            <remarks>
            Overrides default properties.
            </remarks>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnSourceInitialized(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnActivated(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnDeactivated(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnWindowCornerPreferenceChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Private <see cref="P:Wpf.Ui.Controls.FluentWindow.WindowCornerPreference"/> property callback.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnCornerPreferenceChanged(Wpf.Ui.Controls.WindowCornerPreference,Wpf.Ui.Controls.WindowCornerPreference)">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.FluentWindow.WindowCornerPreference"/> is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnWindowBackdropTypeChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Private <see cref="P:Wpf.Ui.Controls.FluentWindow.WindowBackdropType"/> property callback.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnBackdropTypeChanged(Wpf.Ui.Controls.WindowBackdropType,Wpf.Ui.Controls.WindowBackdropType)">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.FluentWindow.WindowBackdropType"/> is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnExtendsContentIntoTitleBarChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Private <see cref="P:Wpf.Ui.Controls.FluentWindow.ExtendsContentIntoTitleBar"/> property callback.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.OnExtendsContentIntoTitleBarChanged(System.Boolean,System.Boolean)">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.FluentWindow.ExtendsContentIntoTitleBar"/> is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.FluentWindow.SetWindowChrome">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.FluentWindow.WindowBackdropType"/> is changed.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.Flyout">
            <summary>
            Represents a control that creates a pop-up window that displays information for an element in the interface.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Flyout.IsOpenProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Flyout.IsOpen"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Flyout.PlacementProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Flyout.Placement"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Flyout.OpenedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.Flyout.Opened"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Flyout.ClosedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.Flyout.Closed"/> routed event.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Flyout.IsOpen">
            <summary>
            Gets or sets a value indicating whether a <see cref="T:Wpf.Ui.Controls.Flyout" /> is visible.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.Flyout.Opened">
            <summary>
            Event triggered when <see cref="T:Wpf.Ui.Controls.Flyout" /> is opened.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.Flyout.Closed">
            <summary>
            Event triggered when <see cref="T:Wpf.Ui.Controls.Flyout" /> is opened.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Flyout.Placement">
            <summary>
            Gets or sets the orientation of the <see cref="T:Wpf.Ui.Controls.Flyout" /> control when the control opens,
            and specifies the behavior of the <see cref="T:System.Windows.Controls.Primitives.Popup" />
            control when it overlaps screen boundaries.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Flyout.OnApplyTemplate">
            <summary>
            Invoked whenever application code or an internal process,
            such as a rebuilding layout pass, calls the ApplyTemplate method.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.FontTypography">
            <summary>
            Defines several predefined text styles that you can apply to some elements responsible for displaying it.
            <para><see href="https://learn.microsoft.com/en-us/windows/apps/design/style/typography"/></para>
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.GridView">
            <summary>
            Extends <see cref="T:System.Windows.Controls.GridView"/> to use Wpf.Ui custom styles
            </summary>
            <example>
            To use this enhanced GridView in a ListView:
            <code lang="xml">
            &lt;ListView&gt;
                &lt;ListView.View&gt;
                    &lt;local:GridView&gt;
                        &lt;GridViewColumn Header="First Name" DisplayMemberBinding="{Binding FirstName}"/&gt;
                        &lt;GridViewColumn Header="Last Name" DisplayMemberBinding="{Binding LastName}"/&gt;
                    &lt;/local:GridView&gt;
                &lt;/ListView.View&gt;
            &lt;/ListView&gt;
            </code>
            </example>
        </member>
        <member name="T:Wpf.Ui.Controls.GridViewColumn">
            <summary>
            Extends <see cref="T:System.Windows.Controls.GridViewColumn"/> with MinWidth and MaxWidth properties.
            It can be used with <see cref="T:Wpf.Ui.Controls.ListView"/> when in GridView mode.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:ListView&gt;
                &lt;ui:ListView.View&gt;
                    &lt;ui:GridView&gt;
                        &lt;ui:GridViewColumn
                            MinWidth="100"
                            MaxWidth="200"
                            DisplayMemberBinding="{Binding FirstName}"
                            Header="First Name" /&gt;
                    &lt;/ui:GridView&gt;
                &lt;/ui:ListView.View&gt;
            &lt;/ui:ListView&gt;
            </code>
            </example>
        </member>
        <member name="M:Wpf.Ui.Controls.GridViewColumn.UpdateDesiredWidth">
            <summary>
            Updates the desired width of the column to be clamped between MinWidth and MaxWidth).
            </summary>
            <remarks>
            Uses reflection to directly set the private `_desiredWidth` field on the `System.Windows.Controls.GridViewColumn`.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thrown if reflection fails to access the `_desiredWidth` field
            </exception>
        </member>
        <member name="P:Wpf.Ui.Controls.GridViewColumn.MinWidth">
            <summary>
            Gets or sets the minimum width of the column.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.GridViewColumn.MinWidthProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.GridViewColumn.MinWidth"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.GridViewColumn.MaxWidth">
            <summary>
            gets or sets the maximum width of the column.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.GridViewColumn.MaxWidthProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.GridViewColumn.MaxWidth"/> dependency property.</summary>
        </member>
        <member name="T:Wpf.Ui.Controls.GridViewHeaderRowPresenter">
            <summary>
            Extends <see cref="T:System.Windows.Controls.GridViewHeaderRowPresenter"/>, and adds layout support for <see cref="T:Wpf.Ui.Controls.GridViewColumn"/>, which can have <see cref="P:Wpf.Ui.Controls.GridViewColumn.MinWidth"/> and <see cref="P:Wpf.Ui.Controls.GridViewColumn.MaxWidth"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.GridViewRowPresenter">
            <summary>
            Extends <see cref="T:System.Windows.Controls.GridViewRowPresenter"/>, and adds header row layout support for <see cref="T:Wpf.Ui.Controls.GridViewColumn"/>, which can have <see cref="P:Wpf.Ui.Controls.GridViewColumn.MinWidth"/> and <see cref="P:Wpf.Ui.Controls.GridViewColumn.MaxWidth"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.HyperlinkButton">
            <summary>
            Button that opens a URL in a web browser.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.HyperlinkButton.NavigateUriProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.HyperlinkButton.NavigateUri"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.HyperlinkButton.NavigateUri">
            <summary>
            Gets or sets the URL (or application shortcut) to open.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.IAppearanceControl">
            <summary>
            UI <see cref="T:System.Windows.Controls.Control"/> with <see cref="T:Wpf.Ui.Controls.ControlAppearance"/> attributes.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.IAppearanceControl.Appearance">
            <summary>
            Gets or sets the <see cref="P:Wpf.Ui.Controls.IAppearanceControl.Appearance"/> of the control, if available.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.FontIcon">
            <summary>
            Represents an icon that uses a glyph from the specified font.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIcon.FontFamilyProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIcon.FontFamily"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIcon.FontSizeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIcon.FontSize"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIcon.FontStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIcon.FontStyle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIcon.FontWeightProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIcon.FontWeight"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIcon.GlyphProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIcon.Glyph"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIcon.FontFamily">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontFamily"/>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIcon.FontSize">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontSize"/>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIcon.FontStyle">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontStyle"/>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIcon.FontWeight">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontWeight"/>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIcon.Glyph">
            <summary>
            Gets or sets the character code that identifies the icon glyph.
            </summary>
            <returns>The hexadecimal character code for the icon glyph.</returns>
        </member>
        <member name="T:Wpf.Ui.Controls.IconElement">
            <summary>
            Represents the base class for an icon UI element.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.IconElement.ForegroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.IconElement.Foreground"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.IconElement.Foreground">
            <inheritdoc cref="P:System.Windows.Controls.Control.Foreground"/>
        </member>
        <member name="M:Wpf.Ui.Controls.IconElement.Coerce(System.Windows.DependencyObject,System.Object)">
            <summary>
            Coerces the value of an Icon dependency property, allowing the use of either IconElement or IconSourceElement.
            </summary>
            <param name="_">The dependency object (unused).</param>
            <param name="baseValue">The value to be coerced.</param>
            <returns>An IconElement, either directly or derived from an IconSourceElement.</returns>
        </member>
        <member name="T:Wpf.Ui.Controls.IconElementConverter">
            <summary>
            Tries to convert <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> and <seealso cref="T:Wpf.Ui.Controls.SymbolFilled"/>  to <see cref="T:Wpf.Ui.Controls.SymbolIcon"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.IconSourceElement">
            <summary>
            Represents an icon that uses an IconSource as its content.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.IconSourceElement.IconSourceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.IconSourceElement.IconSource"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.IconSourceElement.IconSource">
            <summary>
            Gets or sets <see cref="P:Wpf.Ui.Controls.IconSourceElement.IconSource"/>
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ImageIcon">
            <summary>
            Represents an icon that uses an <see cref="T:System.Windows.Controls.Image"/> as its content.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ImageIcon.SourceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ImageIcon.Source"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ImageIcon.Source">
            <summary>
            Gets or sets the Source on this Image.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.SymbolIcon">
            <summary>
            Represents a text element containing an icon glyph.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolIcon.SymbolProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SymbolIcon.Symbol"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolIcon.FilledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SymbolIcon.Filled"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.SymbolIcon.Symbol">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.SymbolRegular"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.SymbolIcon.Filled">
            <summary>
            Gets or sets a value indicating whether or not we should use the <see cref="T:Wpf.Ui.Controls.SymbolFilled"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.FontIconSource">
            <summary>
            Represents an icon source that uses a glyph from the specified font.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIconSource.FontFamilyProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIconSource.FontFamily"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIconSource.FontSizeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIconSource.FontSize"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIconSource.FontStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIconSource.FontStyle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIconSource.FontWeightProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIconSource.FontWeight"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.FontIconSource.GlyphProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.FontIconSource.Glyph"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIconSource.FontFamily">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontFamily"/>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIconSource.FontSize">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontSize"/>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIconSource.FontWeight">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontWeight"/>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIconSource.FontStyle">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontStyle"/>
        </member>
        <member name="P:Wpf.Ui.Controls.FontIconSource.Glyph">
            <summary>
            Gets or sets the character code that identifies the icon glyph.
            </summary>
            <returns>The hexadecimal character code for the icon glyph.</returns>
        </member>
        <member name="T:Wpf.Ui.Controls.IconSource">
            <summary>
            Represents the base class for an icon source.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.IconSource.ForegroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.IconSource.Foreground"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.IconSource.Foreground">
            <inheritdoc cref="P:System.Windows.Controls.Control.Foreground"/>
        </member>
        <member name="T:Wpf.Ui.Controls.SymbolIconSource">
            <summary>
            Represents an icon source that uses a glyph from the specified font.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolIconSource.FontSizeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SymbolIconSource.FontSize"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolIconSource.FontStyleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SymbolIconSource.FontStyle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolIconSource.FontWeightProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SymbolIconSource.FontWeight"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolIconSource.SymbolProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SymbolIconSource.Symbol"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolIconSource.FilledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SymbolIconSource.Filled"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.SymbolIconSource.FontSize">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontSize"/>
        </member>
        <member name="P:Wpf.Ui.Controls.SymbolIconSource.FontWeight">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontWeight"/>
        </member>
        <member name="P:Wpf.Ui.Controls.SymbolIconSource.FontStyle">
            <inheritdoc cref="P:System.Windows.Controls.Control.FontStyle"/>
        </member>
        <member name="P:Wpf.Ui.Controls.SymbolIconSource.Symbol">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.SymbolRegular"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.SymbolIconSource.Filled">
            <summary>
            Gets or sets a value indicating whether or not we should use the <see cref="T:Wpf.Ui.Controls.SymbolFilled"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.IDpiAwareControl">
            <summary>
            The control that should react to changes in the screen DPI.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.IIconControl">
            <summary>
            Control that allows you to set an icon in it with an <see cref="P:Wpf.Ui.Controls.IIconControl.Icon"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.IIconControl.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.Image">
            <summary>
            Represents an image with additional properties for Borders and Rounded corners
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Image.SourceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Image.Source"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Image.CornerRadiusProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Image.CornerRadius"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Image.StretchProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Image.Stretch"/> dependency property.</summary>
            <seealso cref="P:System.Windows.Controls.Viewbox.Stretch" />
        </member>
        <member name="F:Wpf.Ui.Controls.Image.StretchDirectionProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Image.StretchDirection"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Image.InnerCornerRadiusPropertyKey">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Image.InnerCornerRadius"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Image.InnerCornerRadiusProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Image.InnerCornerRadius"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Image.Source">
            <summary>
            Gets or sets the Source on this Image.
            The Source property is the ImageSource that holds the actual image drawn.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Image.Stretch">
            <summary>
            Gets or sets the Stretch on this Image.
            The Stretch property determines how large the Image will be drawn.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Image.StretchDirection">
            <summary>
            Gets or sets the stretch direction of the Viewbox, which determines the restrictions on
            scaling that are applied to the content inside the Viewbox.  For instance, this property
            can be used to prevent the content from being smaller than its native size or larger than
            its native size.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Image.CornerRadius">
            <summary>
            Gets or sets the CornerRadius property allows users to control the roundness of the corners independently by
            setting a radius value for each corner.  Radius values that are too large are scaled so that they
            smoothly blend from corner to corner.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Image.InnerCornerRadius">
            <summary>
            Gets the CornerRadius for the inner image's Mask.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadge.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBadge.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadge.SeverityProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBadge.Severity"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadge.ValueProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBadge.Value"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadge.CornerRadiusProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBadge.CornerRadius"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBadge.Severity">
            <summary>
            Gets or sets the title of the <see cref="P:Wpf.Ui.Controls.InfoBadge.Severity" />.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBadge.Value">
            <summary>
            Gets or sets the title of the <see cref="P:Wpf.Ui.Controls.InfoBadge.Value" />.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBadge.CornerRadius">
            <summary>
            Gets or sets the title of the <see cref="P:Wpf.Ui.Controls.InfoBadge.CornerRadius" />.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBadge.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadgeSeverity.Attention">
            <summary>
            Communicates that the InfoBadge is displaying general information that requires the user's attention.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadgeSeverity.Informational">
            <summary>
            Communicates that the InfoBadge is displaying general information that requires the user's attention.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadgeSeverity.Success">
            <summary>
            Communicates that the InfoBadge is displaying general information that requires the user's attention.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadgeSeverity.Caution">
            <summary>
            Communicates that the InfoBadge is displaying general information that requires the user's attention.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBadgeSeverity.Critical">
            <summary>
            Communicates that the InfoBadge is displaying general information that requires the user's attention.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.InfoBar">
            <summary>
            An <see cref="T:Wpf.Ui.Controls.InfoBar" /> is an inline notification for essential app-
            wide messages. The InfoBar will take up space in a layout and will not
            cover up other content or float on top of it. It supports rich content
            (including titles, messages, and icons) and can be configured to be
            user-dismissable or persistent.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBar.IsClosableProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBar.IsClosable"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBar.IsOpenProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBar.IsOpen"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBar.TitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBar.Title"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBar.MessageProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBar.Message"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBar.SeverityProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBar.Severity"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBar.TemplateButtonCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.InfoBar.TemplateButtonCommand"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBar.IsClosable">
            <summary>
            Gets or sets a value indicating whether the user can close the <see cref="T:Wpf.Ui.Controls.InfoBar" />. Defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBar.IsOpen">
            <summary>
            Gets or sets a value indicating whether the <see cref="T:Wpf.Ui.Controls.InfoBar" /> is open.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBar.Title">
            <summary>
            Gets or sets the title of the <see cref="T:Wpf.Ui.Controls.InfoBar" />.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBar.Message">
            <summary>
            Gets or sets the message of the <see cref="T:Wpf.Ui.Controls.InfoBar" />.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBar.Severity">
            <summary>
            Gets or sets the type of the <see cref="T:Wpf.Ui.Controls.InfoBar" /> to apply
            consistent status color, icon, and assistive technology settings
            dependent on the criticality of the notification.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.InfoBar.TemplateButtonCommand">
            <summary>
            Gets the <see cref="T:Wpf.Ui.Input.RelayCommand`1"/> triggered after clicking
            the close button.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.InfoBar.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.InfoBar"/> class.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBarSeverity.Informational">
            <summary>
            Communicates that the InfoBar is displaying general information that requires the user's attention.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBarSeverity.Success">
            <summary>
            Communicates that the InfoBar is displaying information regarding a long-running and/or background task
            that has completed successfully.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBarSeverity.Warning">
            <summary>
            Communicates that the InfoBar is displaying information regarding a condition that might cause a problem in
            the future.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.InfoBarSeverity.Error">
            <summary>
            Communicates that the InfoBar is displaying information regarding an error or problem that has occurred.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ItemRange">
            <summary>
            Items range.
            <para>Based on <see href="https://github.com/sbaeumlisberger/VirtualizingWrapPanel"/>.</para>
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.IThemeControl">
            <summary>
            Control changing its properties or appearance depending on the theme.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.IThemeControl.ApplicationTheme">
            <summary>
            Gets the theme that is currently set.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ListView">
            <summary>
            Extends <see cref="T:System.Windows.Controls.ListView"/>, and adds customized support <see cref="F:Wpf.Ui.Controls.ListViewViewState.GridView"/> or <see cref="F:Wpf.Ui.Controls.ListViewViewState.Default"/>.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:ListView ItemsSource="{Binding ...}" &gt;
                &lt;ui:ListView.View&gt;
                    &lt;ui:GridView&gt;
                        &lt;GridViewColumn
                            DisplayMemberBinding="{Binding FirstName}"
                            Header="First Name" /&gt;
                        &lt;GridViewColumn
                            DisplayMemberBinding="{Binding LastName}"
                            Header="Last Name" /&gt;
                    &lt;/ui:GridView&gt;
                &lt;/ui:ListView.View&gt;
            &lt;/ui:ListView&gt;
            </code>
            </example>
        </member>
        <member name="F:Wpf.Ui.Controls.ListView.ViewStateProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ListView.ViewState"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ListView.ViewState">
            <summary>
            Gets or sets the view state of the <see cref="T:Wpf.Ui.Controls.ListView"/>, enabling custom logic based on the current view.
            </summary>
            <value>The current view state of the <see cref="T:Wpf.Ui.Controls.ListView"/>.</value>
        </member>
        <member name="T:Wpf.Ui.Controls.LoadingScreen">
            <summary>
            Prestyled loading screen with <see cref="T:Wpf.Ui.Controls.ProgressRing"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.MenuItem">
            <summary>
            Extended <see cref="T:System.Windows.Controls.MenuItem"/> with <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> properties.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MenuItem.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.MenuLoader">
            <summary>
            Changes readonly field value of <see cref="P:System.Windows.SystemParameters.MenuDropAlignment"/> to false.
            </summary>
            <summary>
            MenuLoader
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.MenuLoader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.MenuLoader"/> class.
            </summary>
            <remarks>
            Sets menu alignment on initialization.
            </remarks>
        </member>
        <member name="M:Wpf.Ui.Controls.MenuLoader.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.MessageBox">
            <summary>
            Customized window for notifications.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.ShowTitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.ShowTitle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.PrimaryButtonTextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.PrimaryButtonText"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.SecondaryButtonTextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.SecondaryButtonText"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.CloseButtonTextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.CloseButtonText"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.PrimaryButtonIconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.PrimaryButtonIcon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.SecondaryButtonIconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.SecondaryButtonIcon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.CloseButtonIconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.CloseButtonIcon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.PrimaryButtonAppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.PrimaryButtonAppearance"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.SecondaryButtonAppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.SecondaryButtonAppearance"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.CloseButtonAppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.CloseButtonAppearance"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.IsPrimaryButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.IsPrimaryButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.IsSecondaryButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.IsSecondaryButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.IsCloseButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.IsCloseButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBox.TemplateButtonCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.MessageBox.TemplateButtonCommand"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.ShowTitle">
            <summary>
            Gets or sets a value indicating whether to show the <see cref="P:System.Windows.Window.Title"/> in <see cref="T:Wpf.Ui.Controls.TitleBar"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.PrimaryButtonText">
            <summary>
            Gets or sets the text to display on the primary button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.SecondaryButtonText">
            <summary>
            Gets or sets the text to be displayed on the secondary button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.CloseButtonText">
            <summary>
            Gets or sets the text to display on the close button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.PrimaryButtonIcon">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> on the primary button
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.SecondaryButtonIcon">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> on the secondary button
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.CloseButtonIcon">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> on the close button
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.PrimaryButtonAppearance">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.ControlAppearance"/> on the primary button
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.SecondaryButtonAppearance">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.ControlAppearance"/> on the secondary button
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.CloseButtonAppearance">
            <summary>
            Gets or sets the <see cref="T:Wpf.Ui.Controls.ControlAppearance"/> on the close button
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.IsCloseButtonEnabled">
            <summary>
            Gets or sets a value indicating whether the <see cref="T:Wpf.Ui.Controls.MessageBox"/> close button is enabled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.IsSecondaryButtonEnabled">
            <summary>
            Gets or sets a value indicating whether the <see cref="T:Wpf.Ui.Controls.MessageBox"/> secondary button is enabled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.IsPrimaryButtonEnabled">
            <summary>
            Gets or sets a value indicating whether the <see cref="T:Wpf.Ui.Controls.MessageBox"/> primary button is enabled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.MessageBox.TemplateButtonCommand">
            <summary>
            Gets the command triggered after clicking the button on the Footer.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.MessageBox.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.MessageBox"/> class.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.MessageBox.ShowDialogAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Displays a message box
            </summary>
            <returns><see cref="T:Wpf.Ui.Controls.MessageBoxResult"/></returns>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">Thrown if the operation is canceled.</exception>
        </member>
        <member name="M:Wpf.Ui.Controls.MessageBox.OnLoaded">
            <summary>
            Occurs after Loading event
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.MessageBox.ResizeToContentSize(System.Windows.UIElement)">
            <summary>
            Resizes the MessageBox to fit the content's size, including margins.
            </summary>
            <param name="rootElement">The root element of the MessageBox</param>
        </member>
        <member name="M:Wpf.Ui.Controls.MessageBox.OnButtonClick(Wpf.Ui.Controls.MessageBoxButton)">
            <summary>
            Occurs after the <see cref="T:Wpf.Ui.Controls.MessageBoxButton"/> is clicked
            </summary>
            <param name="button">The MessageBox button</param>
        </member>
        <member name="T:Wpf.Ui.Controls.MessageBoxButton">
            <summary>
            Defines constants that specify the default button on a <see cref="T:Wpf.Ui.Controls.MessageBox"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBoxButton.Primary">
            <summary>
            The primary button
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBoxButton.Secondary">
            <summary>
            The secondary button
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBoxButton.Close">
            <summary>
            The close button
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.MessageBoxResult">
            <summary>
            Specifies identifiers to indicate the return value of a <see cref="T:Wpf.Ui.Controls.MessageBox"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBoxResult.None">
            <summary>
            No button was tapped.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBoxResult.Primary">
            <summary>
            The primary button was tapped by the user.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.MessageBoxResult.Secondary">
            <summary>
            The secondary button was tapped by the user.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.INavigationView">
            <summary>
            Represents a container that enables navigation of app content. It has a header, a view for the main content, and a menu pane for navigation commands.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.Header">
            <summary>
            Gets or sets the header content.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.HeaderVisibility">
            <summary>
            Gets or sets the <see cref="P:Wpf.Ui.Controls.INavigationView.Header"/> visibility.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.AlwaysShowHeader">
            <summary>
            Gets or sets a value indicating whether the header is always visible.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.MenuItems">
            <summary>
            Gets the collection of menu items displayed in the NavigationView.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.MenuItemsSource">
            <summary>
            Gets or sets an object source used to generate the content of the NavigationView menu.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.FooterMenuItems">
            <summary>
            Gets the list of objects to be used as navigation items in the footer menu.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.FooterMenuItemsSource">
            <summary>
            Gets or sets the object that represents the navigation items to be used in the footer menu.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.IsTopSeparatorVisible">
            <summary>
            Gets or sets a value indicating whether the top separators is visible.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.IsFooterSeparatorVisible">
            <summary>
            Gets or sets a value indicating whether the footer separators is visible.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.SelectedItem">
            <summary>
            Gets the selected item.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.ContentOverlay">
            <summary>
            Gets or sets a UI element that is shown at the top of the control, below the pane if PaneDisplayMode is Top.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.IsBackEnabled">
            <summary>
            Gets a value indicating whether the back button is enabled or disabled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.IsBackButtonVisible">
            <summary>
            Gets or sets a value that indicates whether the back button is visible or not.
            Default value is "Auto", which indicates that button visibility depends on the DisplayMode setting of the NavigationView.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.IsPaneToggleVisible">
            <summary>
            Gets or sets a value indicating whether the toggle button is visible.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.IsPaneOpen">
            <summary>
            Gets or sets a value indicating whether the NavigationView pane is expanded to its full width.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.IsPaneVisible">
            <summary>
            Gets or sets a value indicating whether the pane is shown.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.OpenPaneLength">
            <summary>
            Gets or sets the width of the NavigationView pane when it's fully expanded.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.CompactPaneLength">
            <summary>
            Gets or sets the width of the NavigationView pane in its compact display mode.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.PaneHeader">
            <summary>
            Gets or sets the content for the pane header.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.PaneTitle">
            <summary>
            Gets or sets the label adjacent to the menu icon when the NavigationView pane is open.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.PaneFooter">
            <summary>
            Gets or sets the content for the pane footer.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.PaneDisplayMode">
            <summary>
            Gets or sets a value that specifies how the pane and content areas of a NavigationView are being shown.
            <para>It is not the same PaneDisplayMode as in WinUi.</para>
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.TitleBar">
            <summary>
            Gets or sets an TitleBar to be displayed in the NavigationView.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.AutoSuggestBox">
            <summary>
            Gets or sets an AutoSuggestBox to be displayed in the NavigationView.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.BreadcrumbBar">
            <summary>
            Gets or sets an BreadcrumbBar that is in <see cref="P:Wpf.Ui.Controls.INavigationView.Header"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.ItemTemplate">
            <summary>
            Gets or sets the template property for <see cref="P:Wpf.Ui.Controls.INavigationView.MenuItems"/> and <see cref="P:Wpf.Ui.Controls.INavigationView.FooterMenuItems"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.TransitionDuration">
            <summary>
            Gets or sets a value deciding how long the effect of the transition between the pages should take.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.Transition">
            <summary>
            Gets or sets type of <see cref="T:Wpf.Ui.Controls.INavigationView"/> transitions during navigation.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.FrameMargin">
            <summary>
            Gets or sets margin for a Frame of <see cref="T:Wpf.Ui.Controls.INavigationView"/>
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.INavigationView.PaneOpened">
            <summary>
            Occurs when the NavigationView pane is opened.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.INavigationView.PaneClosed">
            <summary>
            Occurs when the NavigationView pane is closed.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.INavigationView.SelectionChanged">
            <summary>
            Occurs when the currently selected item changes.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.INavigationView.ItemInvoked">
            <summary>
            Occurs when an item in the menu receives an interaction such as a click or tap.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.INavigationView.BackRequested">
            <summary>
            Occurs when the back button receives an interaction such as a click or tap.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.INavigationView.Navigating">
            <summary>
            Occurs when a new navigation is requested
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.INavigationView.Navigated">
            <summary>
            Occurs when navigated to page
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationView.CanGoBack">
            <summary>
            Gets a value indicating whether there is at least one entry in back navigation history.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.Navigate(System.Type,System.Object)">
            <summary>
            Synchronously navigates current navigation Frame to the
            given Element.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.Navigate(System.String,System.Object)">
            <summary>
            Synchronously navigates current navigation Frame to the
            given Element.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.NavigateWithHierarchy(System.Type,System.Object)">
            <summary>
            Synchronously adds an element to the navigation stack and navigates current navigation Frame to the
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.ReplaceContent(System.Type)">
            <summary>
            Replaces the contents of the navigation frame, without changing the currently selected item or triggering an <see cref="E:Wpf.Ui.Controls.INavigationView.SelectionChanged"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.ReplaceContent(System.Windows.UIElement,System.Object)">
            <summary>
            Replaces the contents of the navigation frame, without changing the currently selected item or triggering an <see cref="E:Wpf.Ui.Controls.INavigationView.SelectionChanged"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.GoForward">
            <summary>
            Navigates the NavigationView to the next journal entry.
            </summary>
            <returns><see langword="true"/> if successfully navigated forward, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.GoBack">
            <summary>
            Navigates the NavigationView to the previous journal entry.
            </summary>
            <returns><see langword="true"/> if successfully navigated backward, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.ClearJournal">
            <summary>
            Clears the NavigationView history.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.SetPageProviderService(Wpf.Ui.Abstractions.INavigationViewPageProvider)">
            <summary>
            Allows you to assign to the NavigationView a special service responsible for retrieving the page instances.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationView.SetServiceProvider(System.IServiceProvider)">
            <summary>
            Allows you to assign a general <see cref="T:System.IServiceProvider"/> to the NavigationView that will be used to retrieve page instances and view models.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.INavigationViewItem">
            <summary>
            Represents the container for an item in a NavigationView control.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.Id">
            <summary>
            Gets the unique identifier that allows the item to be located in the navigation.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.Content">
            <summary>
            Gets or sets the content
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.Icon">
            <summary>
            Gets or sets the icon displayed in the MenuItem object.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.MenuItems">
            <summary>
            Gets the collection of menu items displayed in the NavigationView.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.MenuItemsSource">
            <summary>
            Gets or sets an object source used to generate the content of the NavigationView menu.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.IsActive">
            <summary>
            Gets a value indicating whether the current element is active.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.IsExpanded">
            <summary>
            Gets or sets a value indicating whether the sub-<see cref="P:Wpf.Ui.Controls.INavigationViewItem.MenuItems"/> are expanded.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.TargetPageTag">
            <summary>
            Gets or sets the unique tag used by the parent navigation system for the purpose of searching and navigating.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.TargetPageType">
            <summary>
            Gets or sets the type of the page to be navigated. (Should be derived from <see cref="T:System.Windows.FrameworkElement"/>).
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.NavigationCacheMode">
            <summary>
            Gets or sets the caching characteristics for a page involved in a navigation.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.Template">
            <summary>
            Gets or sets the template property
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.INavigationViewItem.NavigationViewItemParent">
            <summary>
            Gets or sets the parent if it's in <see cref="P:Wpf.Ui.Controls.INavigationViewItem.MenuItems"/> collection
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.INavigationViewItem.Click">
            <summary>
            Add / Remove ClickEvent handler.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationViewItem.Activate(Wpf.Ui.Controls.INavigationView)">
            <summary>
            Correctly activates
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INavigationViewItem.Deactivate(Wpf.Ui.Controls.INavigationView)">
            <summary>
            Correctly deactivates
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NavigationCacheMode">
            <summary>
            Specifies caching characteristics for a page involved in a navigation.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationCacheMode.Disabled">
            <summary>
            The page is never cached and a new instance of the page is created on each visit.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationCacheMode.Enabled">
            <summary>
            The page is cached, but the cached instance is discarded when the size of the cache for the frame is exceeded.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationCacheMode.Required">
            <summary>
            The page is cached and the cached instance is reused for every visit regardless of the cache size for the frame.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NavigationView">
            <content>
            Defines attached properties for <see cref="T:Wpf.Ui.Controls.NavigationView"/>.
            </content>
            <summary>
            Represents a container that enables navigation of app content. It has a header, a view for the main content, and a menu pane for navigation commands.
            </summary>
            <content>
            Defines events for <see cref="T:Wpf.Ui.Controls.NavigationView"/>.
            </content>
            <content>
            Defines navigation logic and state management for <see cref="T:Wpf.Ui.Controls.NavigationView"/>.
            </content>
            <content>
            Defines the dependency properties and dp callbacks for <see cref="T:Wpf.Ui.Controls.NavigationView"/> control
            </content>
            <content>
            Defines the template parts for the <see cref="T:Wpf.Ui.Controls.NavigationView"/> control
            </content>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.HeaderContentProperty">
            <summary>Registers attached property NavigationView.HeaderContent</summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.GetHeaderContent(System.Windows.FrameworkElement)">
            <summary>Helper for getting <see cref="F:Wpf.Ui.Controls.NavigationView.HeaderContentProperty"/> from <paramref name="target"/>.</summary>
            <param name="target"><see cref="T:System.Windows.FrameworkElement"/> to read <see cref="F:Wpf.Ui.Controls.NavigationView.HeaderContentProperty"/> from.</param>
            <returns>HeaderContent property value.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.SetHeaderContent(System.Windows.FrameworkElement,System.Object)">
            <summary>Helper for setting <see cref="F:Wpf.Ui.Controls.NavigationView.HeaderContentProperty"/> on <paramref name="target"/>.</summary>
            <param name="target"><see cref="T:System.Windows.FrameworkElement"/> to set <see cref="F:Wpf.Ui.Controls.NavigationView.HeaderContentProperty"/> on.</param>
            <param name="headerContent">HeaderContent property value.</param>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.NavigationParentProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.NavigationParent"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.NavigationParent">
            <summary>
            Gets the parent <see cref="T:Wpf.Ui.Controls.NavigationView"/> for its <see cref="T:Wpf.Ui.Controls.INavigationViewItem"/> children.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.GetNavigationParent(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Wpf.Ui.Controls.NavigationView.NavigationParentProperty"/> from <paramref name="navigationItem"/>.</summary>
            <param name="navigationItem"><see cref="T:System.Windows.DependencyObject"/> to read <see cref="F:Wpf.Ui.Controls.NavigationView.NavigationParentProperty"/> from.</param>
            <returns>NavigationParent property value.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Wpf.Ui.Controls.NavigationView"/> class and overrides default property metadata.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.NavigationView"/> class.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.SelectedItem">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnInitialized(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnUnloaded(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            This virtual method is called when this element is detached form a loaded tree.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnSizeChanged(System.Object,System.Windows.SizeChangedEventArgs)">
            <summary>
            This virtual method is called when ActualWidth or ActualHeight (or both) changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnBackButtonClick(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.NavigationView.BackButton"/> is clicked.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnToggleButtonClick(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.NavigationView.ToggleButton"/> is clicked.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.AutoSuggestBoxSymbolButtonOnClick(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.NavigationView.AutoSuggestBoxSymbolButton"/> is clicked.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnPaneDisplayModeChanged">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.NavigationView.PaneDisplayMode"/> is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnItemTemplateChanged">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.NavigationView.ItemTemplate"/> is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.AutoSuggestBoxOnSuggestionChosen(Wpf.Ui.Controls.AutoSuggestBox,Wpf.Ui.Controls.AutoSuggestBoxSuggestionChosenEventArgs)">
            <summary>
            Navigate to the page after its name is selected in <see cref="P:Wpf.Ui.Controls.NavigationView.AutoSuggestBox"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.PaneOpenedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.NavigationView.PaneOpened"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.PaneClosedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.NavigationView.PaneClosed"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.SelectionChangedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.NavigationView.SelectionChanged"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.ItemInvokedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.NavigationView.ItemInvoked"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.BackRequestedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.NavigationView.BackRequested"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.NavigatingEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.NavigationView.Navigating"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.NavigatedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.NavigationView.Navigated"/> routed event.</summary>
        </member>
        <member name="E:Wpf.Ui.Controls.NavigationView.PaneOpened">
            <inheritdoc/>
        </member>
        <member name="E:Wpf.Ui.Controls.NavigationView.PaneClosed">
            <inheritdoc/>
        </member>
        <member name="E:Wpf.Ui.Controls.NavigationView.SelectionChanged">
            <inheritdoc/>
        </member>
        <member name="E:Wpf.Ui.Controls.NavigationView.ItemInvoked">
            <inheritdoc/>
        </member>
        <member name="E:Wpf.Ui.Controls.NavigationView.BackRequested">
            <inheritdoc/>
        </member>
        <member name="E:Wpf.Ui.Controls.NavigationView.Navigating">
            <inheritdoc/>
        </member>
        <member name="E:Wpf.Ui.Controls.NavigationView.Navigated">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnPaneOpened">
            <summary>
            Raises the pane opened event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnPaneClosed">
            <summary>
            Raises the pane closed event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnSelectionChanged">
            <summary>
            Raises the selection changed event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnItemInvoked">
            <summary>
            Raises the item invoked event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnBackRequested">
            <summary>
            Raises the back requested event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnNavigating(System.Object)">
            <summary>
            Raises the navigating requested event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnNavigated(System.Object)">
            <summary>
            Raises the navigated requested event.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.CanGoBack">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.SetPageProviderService(Wpf.Ui.Abstractions.INavigationViewPageProvider)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.SetServiceProvider(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.Navigate(System.Type,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.Navigate(System.String,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.NavigateWithHierarchy(System.Type,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.ReplaceContent(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.ReplaceContent(System.Windows.UIElement,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.GoForward">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.GoBack">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.ClearJournal">
            <inheritdoc />
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.EnableDebugMessagesProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.EnableDebugMessages"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.HeaderProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.Header"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.HeaderVisibilityProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.HeaderVisibility"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.AlwaysShowHeaderProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.AlwaysShowHeader"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.MenuItemsProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.MenuItems"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.MenuItemsSourceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.MenuItemsSource"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.FooterMenuItemsProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.FooterMenuItems"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.FooterMenuItemsSourceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.FooterMenuItemsSource"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.IsTopSeparatorVisibleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.IsTopSeparatorVisible"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.IsFooterSeparatorVisibleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.IsFooterSeparatorVisible"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.ContentOverlayProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.ContentOverlay"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.IsBackEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.IsBackEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.IsBackButtonVisibleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.IsBackButtonVisible"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.IsPaneToggleVisibleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.IsPaneToggleVisible"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.IsPaneOpenProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.IsPaneOpen"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.IsPaneVisibleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.IsPaneVisible"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.OpenPaneLengthProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.OpenPaneLength"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.CompactPaneLengthProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.CompactPaneLength"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.PaneHeaderProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.PaneHeader"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.PaneTitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.PaneTitle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.PaneFooterProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.PaneFooter"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.PaneDisplayModeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.PaneDisplayMode"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.AutoSuggestBoxProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.AutoSuggestBox"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TitleBarProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.TitleBar"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.BreadcrumbBarProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.BreadcrumbBar"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.ItemTemplateProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.ItemTemplate"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TransitionDurationProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.TransitionDuration"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TransitionProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.Transition"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.FrameMarginProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationView.FrameMargin"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.EnableDebugMessages">
            <summary>
            Gets or sets a value indicating whether debugging messages for this control are enabled
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.Header">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.HeaderVisibility">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.AlwaysShowHeader">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.MenuItems">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.MenuItemsSource">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.FooterMenuItems">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.FooterMenuItemsSource">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.IsTopSeparatorVisible">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.IsFooterSeparatorVisible">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.ContentOverlay">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.IsBackEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.IsBackButtonVisible">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.IsPaneToggleVisible">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.IsPaneOpen">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.IsPaneVisible">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.OpenPaneLength">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.CompactPaneLength">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.PaneHeader">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.PaneTitle">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.PaneFooter">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.PaneDisplayMode">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.AutoSuggestBox">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.TitleBar">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.BreadcrumbBar">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.ItemTemplate">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.TransitionDuration">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.Transition">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.FrameMargin">
            <inheritdoc/>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TemplateElementNavigationViewContentPresenter">
            <summary>
            Template element represented by the <c>PART_MenuItemsItemsControl</c> name.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TemplateElementMenuItemsItemsControl">
            <summary>
            Template element represented by the <c>PART_MenuItemsItemsControl</c> name.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TemplateElementFooterMenuItemsItemsControl">
            <summary>
            Template element represented by the <c>PART_FooterMenuItemsItemsControl</c> name.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TemplateElementBackButton">
            <summary>
            Template element represented by the <c>PART_BackButton</c> name.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TemplateElementToggleButton">
            <summary>
            Template element represented by the <c>PART_ToggleButton</c> name.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationView.TemplateElementAutoSuggestBoxSymbolButton">
            <summary>
            Template element represented by the <c>PART_AutoSuggestBoxSymbolButton</c> name.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.NavigationViewContentPresenter">
            <summary>
            Gets or sets the control responsible for rendering the content.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.MenuItemsItemsControl">
            <summary>
            Gets or sets the control located at the top of the pane with left arrow icon.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.FooterMenuItemsItemsControl">
            <summary>
            Gets or sets the control located at the top of the pane with hamburger icon.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.BackButton">
            <summary>
            Gets or sets the control located at the top of the pane with left arrow icon.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.ToggleButton">
            <summary>
            Gets or sets the control located at the top of the pane with hamburger icon.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationView.AutoSuggestBoxSymbolButton">
            <summary>
            Gets or sets the control that is visitable if PaneDisplayMode="Left" and in compact state
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationView.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.Controls.NavigationViewActivator">
            <summary>
            Internal activator for creating content instances of the navigation view items.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationViewActivator.CreateInstance(System.Type,System.Object)">
            <summary>
            Creates new instance of type derived from <see cref="T:System.Windows.FrameworkElement"/>.
            </summary>
            <param name="pageType"><see cref="T:System.Windows.FrameworkElement"/> to instantiate.</param>
            <param name="dataContext">Additional context to set.</param>
            <returns>Instance of the <see cref="T:System.Windows.FrameworkElement"/> object or <see langword="null"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationViewActivator.FitBestConstructor(System.Reflection.ConstructorInfo[],System.Object)">
            <summary>
            Picks the constructor with the highest number of satisfiable parameters based on the provided context.
            </summary>
            <param name="parameterfullCtors">Array of constructors to evaluate.</param>
            <param name="dataContext">Context used to determine parameter satisfaction.</param>
            <returns>The constructor with the most satisfiable arguments, or null if none are fully satisfiable.</returns>
        </member>
        <member name="T:Wpf.Ui.Controls.NavigationViewBackButtonVisible">
            <summary>
            Defines constants that specify whether the back button is visible in NavigationView.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewBackButtonVisible.Collapsed">
            <summary>
            Do not display the back button in NavigationView, and do not reserve space for it in layout.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewBackButtonVisible.Visible">
            <summary>
            Display the back button in NavigationView.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewBackButtonVisible.Auto">
            <summary>
            The system chooses whether or not to display the back button, depending on the device/form factor. On phones, tablets, desktops, and hubs, the back button is visible. On Xbox/TV, the back button is collapsed.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewContentPresenter.TransitionDurationProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewContentPresenter.TransitionDuration"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewContentPresenter.TransitionProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewContentPresenter.Transition"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewContentPresenter.IsDynamicScrollViewerEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewContentPresenter.IsDynamicScrollViewerEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewContentPresenter.Transition">
            <summary>
            Gets or sets type of <see cref="T:Wpf.Ui.Controls.NavigationViewContentPresenter"/> transitions during navigation.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewContentPresenter.IsDynamicScrollViewerEnabled">
            <summary>
            Gets or sets a value indicating whether the dynamic scroll viewer is enabled.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NavigationViewItem">
            <summary>
            Represents the container for an item in a NavigationView control.
            When needed, it can be used as a normal button with a <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click"/> action.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.MenuItemsProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.MenuItems"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.MenuItemsSourceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.MenuItemsSource"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.HasMenuItemsPropertyKey">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.HasMenuItems"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.HasMenuItemsProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.HasMenuItems"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.IsActiveProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.IsActive"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.IsPaneOpenProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.IsPaneOpen"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.IsExpandedProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.IsExpanded"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.TargetPageTagProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.TargetPageTag"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.TargetPageTypeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.TargetPageType"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.InfoBadgeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.InfoBadge"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItem.NavigationCacheModeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItem.NavigationCacheMode"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.MenuItems">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.MenuItemsSource">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.HasMenuItems">
            <summary>
            Gets a value indicating whether MenuItems.Count > 0
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.IsActive">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.IsExpanded">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.Icon">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.TargetPageTag">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.TargetPageType">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.NavigationCacheMode">
            <inheritdoc/>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.NavigationViewItemParent">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.IsMenuElement">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItem.Id">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationViewItem.Activate(Wpf.Ui.Controls.INavigationView)">
            <summary>
            Correctly activates
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationViewItem.Deactivate(Wpf.Ui.Controls.INavigationView)">
            <summary>
            Correctly deactivates
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationViewItem.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationViewItem.OnInitialized(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationViewItem.OnClick">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NavigationViewItem.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            Is called when mouse is clicked down.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NavigationViewItemHeader">
            <summary>
            Represents a header for a group of menu items in a NavigationMenu.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItemHeader.TextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItemHeader.Text"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewItemHeader.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NavigationViewItemHeader.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItemHeader.Text">
            <summary>
            Gets or sets the text presented in the header element.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NavigationViewItemHeader.Icon">
            <summary>
            Gets or sets the icon.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NavigationViewItemSeparator">
            <summary>
            Represents a line that separates menu items in a NavigationMenu.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NavigationViewPaneDisplayMode">
            <summary>
            Defines constants that specify how and where the NavigationView pane is shown.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewPaneDisplayMode.Left">
            <summary>
            The pane is shown on the left side of the control.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewPaneDisplayMode.LeftMinimal">
            <summary>
            The pane is shown on the left side of the control. Only the pane icons are shown.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewPaneDisplayMode.LeftFluent">
            <summary>
            The pane is shown on the left side of the control. Large icons with titles underneath are the only display option. Does not support <see cref="P:Wpf.Ui.Controls.NavigationViewItem.MenuItems"/>.
            <para>Similar to the Windows Store (2022) app.</para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewPaneDisplayMode.Top">
            <summary>
            The pane is shown at the top of the control.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NavigationViewPaneDisplayMode.Bottom">
            <summary>
            The pane is shown at the bottom of the control.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.INumberFormatter">
            <summary>
            An interface that returns a string representation of a provided value, using distinct format methods to format several data types.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INumberFormatter.FormatDouble(System.Nullable{System.Double})">
            <summary>
            Returns a string representation of a <see cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INumberFormatter.FormatInt(System.Nullable{System.Int32})">
            <summary>
            Returns a string representation of an <see cref="T:System.Int32"/> value.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INumberFormatter.FormatUInt(System.Nullable{System.UInt32})">
            <summary>
            Returns a string representation of a <see cref="T:System.UInt32"/> value.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.INumberParser">
            <summary>
            An interface that parses a string representation of a numeric value.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INumberParser.ParseDouble(System.String)">
            <summary>
            Attempts to parse a string representation of a <see cref="T:System.Double"/> numeric value.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INumberParser.ParseInt(System.String)">
            <summary>
            Attempts to parse a string representation of an <see cref="T:System.Int32"/> numeric value.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.INumberParser.ParseUInt(System.String)">
            <summary>
            Attempts to parse a string representation of an <see cref="T:System.UInt32"/> numeric value.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NumberBox">
            <summary>
            Represents a control that can be used to display and edit numbers.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.ValueProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.MaxDecimalPlacesProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.MaxDecimalPlaces"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.SmallChangeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.SmallChange"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.LargeChangeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.LargeChange"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.MaximumProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.Maximum"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.MinimumProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.Minimum"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.AcceptsExpressionProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.AcceptsExpression"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.SpinButtonPlacementModeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.SpinButtonPlacementMode"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.ValidationModeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.ValidationMode"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.NumberFormatterProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.NumberBox.NumberFormatter"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBox.ValueChangedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.NumberBox.ValueChanged"/> routed event.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.Value">
            <summary>
            Gets or sets the numeric value of a <see cref="T:Wpf.Ui.Controls.NumberBox"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.MaxDecimalPlaces">
            <summary>
            Gets or sets the number of decimal places to be rounded when converting from Text to Value.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.SmallChange">
            <summary>
            Gets or sets the value that is added to or subtracted from <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> when a small change is made, such as with an arrow key or scrolling.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.LargeChange">
            <summary>
            Gets or sets the value that is added to or subtracted from <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> when a large change is made, such as with the PageUP and PageDown keys.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.Maximum">
            <summary>
            Gets or sets the numerical maximum for <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.Minimum">
            <summary>
            Gets or sets the numerical minimum for <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.AcceptsExpression">
            <summary>
            Gets or sets a value indicating whether the control will accept and evaluate a basic formulaic expression entered as input.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.NumberFormatter">
            <summary>
            Gets or sets the number formatter.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.SpinButtonPlacementMode">
            <summary>
            Gets or sets a value that indicates the placement of buttons used to increment or decrement the <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> property.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBox.ValidationMode">
            <summary>
            Gets or sets the input validation behavior to invoke when invalid input is entered.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.NumberBox.ValueChanged">
            <summary>
            Occurs after the user triggers evaluation of new input by pressing the Enter key, clicking a spin button, or by changing focus.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NumberBox.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NumberBox.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NumberBox.OnLostFocus(System.Windows.RoutedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NumberBox.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.NumberBox.OnValueChanged(System.Windows.DependencyObject,System.Nullable{System.Double})">
            <summary>
            Is called when <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> in this <see cref="T:Wpf.Ui.Controls.NumberBox"/> changes.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NumberBox.OnClipboardPaste(System.Object,System.Windows.DataObjectPastingEventArgs)">
            <summary>
            Is called when something is pasted in this <see cref="T:Wpf.Ui.Controls.NumberBox"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NumberBoxSpinButtonPlacementMode">
            <summary>
            Defines values that specify how the spin buttons used to increment or decrement the <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> are displayed.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBoxSpinButtonPlacementMode.Hidden">
            <summary>
            The spin buttons are not displayed.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBoxSpinButtonPlacementMode.Compact">
            <summary>
            The spin buttons have two visual states, depending on focus. By default, the spin buttons are displayed in a compact, vertical orientation. When the Numberbox gets focus, the spin buttons expand.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBoxSpinButtonPlacementMode.Inline">
            <summary>
            The spin buttons are displayed in an expanded, horizontal orientation.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NumberBoxValidationMode">
            <summary>
            Defines values that specify the input validation behavior of a <see cref="T:Wpf.Ui.Controls.NumberBox"/> when invalid input is entered.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBoxValidationMode.InvalidInputOverwritten">
            <summary>
            Input validation is disabled.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.NumberBoxValidationMode.Disabled">
            <summary>
            Invalid input is replaced by <see cref="T:Wpf.Ui.Controls.NumberBox"/> PlaceholderText text.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.NumberBoxValueChangedEventArgs">
            <summary>
            Provides information for the <see cref="E:Wpf.Ui.Controls.NumberBox.ValueChanged" /> event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.NumberBoxValueChangedEventArgs.#ctor(System.Nullable{System.Double},System.Nullable{System.Double},System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.NumberBoxValueChangedEventArgs" /> class. />
            </summary>
            <param name="oldValue">
                The value of the <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> property before the change
                reported by the relevant event or state change.
            </param>
            <param name="newValue">
                The value of the <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> property after the change
                reported by the relevant event or state change.
            </param>
            <param name="source">
                An alternate source that will be reported when the event is handled. This pre-populates
                the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property.
            </param>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBoxValueChangedEventArgs.OldValue">
            <summary>Gets the value of the <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> property before the change.</summary>
            <returns>The property value before the change.</returns>
        </member>
        <member name="P:Wpf.Ui.Controls.NumberBoxValueChangedEventArgs.NewValue">
            <summary>Gets the value of the <see cref="P:Wpf.Ui.Controls.NumberBox.Value"/> property after the change.</summary>
            <returns>The property value after the change.</returns>
        </member>
        <member name="T:Wpf.Ui.Controls.ValidateNumberFormatter">
            <summary>
            Base nubmer formatter that uses default format specifier and <see cref="T:System.Globalization.CultureInfo"/> that represents the culture used by the current thread.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ValidateNumberFormatter.FormatDouble(System.Nullable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.ValidateNumberFormatter.FormatInt(System.Nullable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.ValidateNumberFormatter.FormatUInt(System.Nullable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.ValidateNumberFormatter.ParseDouble(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.ValidateNumberFormatter.ParseInt(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.ValidateNumberFormatter.ParseUInt(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.Controls.PassiveScrollViewer">
            <summary>
            A custom ScrollViewer that allows certain mouse events to bubble through when it's inactive.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.PassiveScrollViewer.IsScrollSpillEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.PassiveScrollViewer.IsScrollSpillEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.PassiveScrollViewer.IsScrollSpillEnabled">
            <summary>
            Gets or sets a value indicating whether blocked inner scrolling should be propagated forward.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.PasswordBox">
            <summary>
            The modified password control.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.PasswordBox.PasswordProperty">
            <summary>
            Identifies the <see cref="P:Wpf.Ui.Controls.PasswordBox.Password"/> dependency property.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.PasswordBox.PasswordCharProperty">
            <summary>
            Identifies the <see cref="P:Wpf.Ui.Controls.PasswordBox.PasswordChar"/> dependency property.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.PasswordBox.IsPasswordRevealedProperty">
            <summary>
            Identifies the <see cref="P:Wpf.Ui.Controls.PasswordBox.IsPasswordRevealed"/> dependency property.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.PasswordBox.RevealButtonEnabledProperty">
            <summary>
            Identifies the <see cref="P:Wpf.Ui.Controls.PasswordBox.RevealButtonEnabled"/> dependency property.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.PasswordBox.PasswordChangedEvent">
            <summary>
            Identifies the <see cref="E:Wpf.Ui.Controls.PasswordBox.PasswordChanged"/> routed event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.PasswordBox"/> class.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.PasswordBox.Password">
            <summary>
            Gets or sets the actual password (not asterisks).
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.PasswordBox.PasswordChar">
            <summary>
            Gets or sets the character used to mask the password.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.PasswordBox.IsPasswordRevealed">
            <summary>
            Gets a value indicating whether the password is currently revealed.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.PasswordBox.RevealButtonEnabled">
            <summary>
            Gets or sets a value indicating whether gets or sets whether the password reveal button is enabled.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.PasswordBox.PasswordChanged">
            <summary>
            Occurs when the password content changes.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.OnTextChanged(System.Windows.Controls.TextChangedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.OnPasswordChanged">
            <summary>
            Called when the <see cref="P:Wpf.Ui.Controls.PasswordBox.Password"/> property changes.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.OnPasswordCharChanged">
            <summary>
            Called when the <see cref="P:Wpf.Ui.Controls.PasswordBox.PasswordChar"/> property changes.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.OnIsPasswordRevealedChanged">
            <summary>
            Called when the <see cref="P:Wpf.Ui.Controls.PasswordBox.IsPasswordRevealed"/> property changes.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.OnTemplateButtonClick(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.UpdateTextContents(System.Collections.Generic.ICollection{System.Windows.Controls.TextChange})">
            <summary>
            Updates the text contents based on the current state.
            </summary>
            <param name="textChanges">The text changes.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.HandleRevealedModeUpdate">
            <summary>
            Handles updates when password is in revealed mode.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.HandleHiddenModeUpdate(System.Collections.Generic.ICollection{System.Windows.Controls.TextChange})">
            <summary>
            Handles updates when password is in hidden mode.
            </summary>
            <param name="textChanges">The text changes.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.UpdateWithLock(System.Action)">
            <summary>
            Executes an action while preventing recursive updates.
            </summary>
            <param name="updateAction">The action to execute.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.RaisePasswordChangedEvent">
            <summary>
            Raises the <see cref="F:Wpf.Ui.Controls.PasswordBox.PasswordChangedEvent"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.OnPasswordChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles changes to the <see cref="P:Wpf.Ui.Controls.PasswordBox.Password"/> dependency property.
            </summary>
            <param name="dependencyObject">The <see cref="T:System.Windows.DependencyObject"/> that raised the event.</param>
            <param name="e">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs"/> containing the event data.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.OnPasswordCharChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles changes to the <see cref="P:Wpf.Ui.Controls.PasswordBox.PasswordChar"/> dependency property.
            </summary>
            <param name="dependencyObject">The <see cref="T:System.Windows.DependencyObject"/> instance where the change occurred.</param>
            <param name="e">Event data that contains information about the property change.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.OnIsPasswordRevealedChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles changes to the <see cref="P:Wpf.Ui.Controls.PasswordBox.IsPasswordRevealed"/> dependency property.
            </summary>
            <param name="dependencyObject">The <see cref="T:System.Windows.DependencyObject"/> instance where the property changed.</param>
            <param name="e">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs"/> containing the old and new values.</param>
        </member>
        <member name="T:Wpf.Ui.Controls.PasswordBox.PasswordHelper">
            <summary>
            Helper class for managing password operations in <see cref="T:Wpf.Ui.Controls.PasswordBox"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.PasswordHelper.#ctor(Wpf.Ui.Controls.PasswordBox)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.PasswordBox.PasswordHelper"/> class.
            </summary>
            <param name="passwordBox">The parent <see cref="T:Wpf.Ui.Controls.PasswordBox"/> control.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.PasswordHelper.GetNewPassword(System.Collections.Generic.ICollection{System.Windows.Controls.TextChange})">
            <summary>
            Calculates and returns the new password value based on current input.
            </summary>
            <param name="textChanges">The text changes.</param>
            <returns>The updated password string.</returns>
            <remarks>
            Handles three scenarios:
            1. When text is being deleted
            2. When password is revealed (plain text mode)
            3. When password is hidden (masked character mode)
            </remarks>
        </member>
        <member name="M:Wpf.Ui.Controls.PasswordBox.PasswordHelper.HandleHiddenModeChanges(System.Collections.Generic.ICollection{System.Windows.Controls.TextChange})">
            <summary>
            Handles password changes when in hidden (masked) mode.
            </summary>
            <param name="textChanges">The text changes.</param>
            <returns>The updated password string.</returns>
        </member>
        <member name="T:Wpf.Ui.Controls.ProgressRing">
            <summary>
            Rotating loading ring.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ProgressRing.ProgressProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ProgressRing.Progress"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ProgressRing.IsIndeterminateProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ProgressRing.IsIndeterminate"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ProgressRing.EngAngleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ProgressRing.EngAngle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ProgressRing.IndeterminateAngleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ProgressRing.IndeterminateAngle"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ProgressRing.CoverRingStrokeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ProgressRing.CoverRingStroke"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ProgressRing.CoverRingVisibilityProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ProgressRing.CoverRingVisibility"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ProgressRing.Progress">
            <summary>
            Gets or sets the progress.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ProgressRing.IsIndeterminate">
            <summary>
            Gets or sets a value indicating whether <see cref="T:Wpf.Ui.Controls.ProgressRing"/> shows actual values (<see langword="false"/>)
            or generic, continuous progress feedback.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ProgressRing.EngAngle">
            <summary>
            Gets or sets the <see cref="P:Wpf.Ui.Controls.Arc.EndAngle"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ProgressRing.IndeterminateAngle">
            <summary>
            Gets the <see cref="P:Wpf.Ui.Controls.Arc.EndAngle"/> when <see cref="P:Wpf.Ui.Controls.ProgressRing.IsIndeterminate"/> is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ProgressRing.CoverRingStroke">
            <summary>
            Gets background ring fill.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ProgressRing.CoverRingVisibility">
            <summary>
            Gets background ring visibility.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ProgressRing.UpdateProgressAngle">
            <summary>
            Re-draws <see cref="P:Wpf.Ui.Controls.Arc.EndAngle"/> depending on <see cref="P:Wpf.Ui.Controls.ProgressRing.Progress"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ProgressRing.OnProgressChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Validates the entered <see cref="P:Wpf.Ui.Controls.ProgressRing.Progress"/> and redraws the <see cref="T:Wpf.Ui.Controls.Arc"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.RatingControl">
            <summary>
            Displays the rating scale with interactions.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.RatingControl.ValueProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.RatingControl.Value"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.RatingControl.MaxRatingProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.RatingControl.MaxRating"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.RatingControl.HalfStarEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.RatingControl.HalfStarEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.RatingControl.ValueChangedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.RatingControl.ValueChanged"/> routed event.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.RatingControl.Value">
            <summary>
            Gets or sets the rating value.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.RatingControl.MaxRating">
            <summary>
            Gets or sets the maximum allowed rating value.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.RatingControl.HalfStarEnabled">
            <summary>
            Gets or sets a value indicating whether half of the star can be selected.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.RatingControl.ValueChanged">
            <summary>
            Occurs after the user selects the rating.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.RatingControl.OnValueChanged(System.Double)">
            <summary>
            Is called when <see cref="P:Wpf.Ui.Controls.RatingControl.Value"/> changes.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.RatingControl.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
            <summary>
            Is called when mouse is moved away from the control.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.RatingControl.OnMouseMove(System.Windows.Input.MouseEventArgs)">
            <summary>
            Is called when mouse is moved around the control.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.RatingControl.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            Is called when mouse is cliked down.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.RatingControl.OnKeyUp(System.Windows.Input.KeyEventArgs)">
            <summary>
            Adjusts the control's <see cref="P:Wpf.Ui.Controls.RatingControl.Value" /> in response to keyboard input, incrementing or decrementing based on the key pressed.
            </summary>
            <param name="e">Key event arguments containing details about the key press.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.RatingControl.OnApplyTemplate">
            <summary>
            Is called when Template is changed.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.RichTextBox">
            <summary>
            Extends the <see cref="T:System.Windows.Controls.RichTextBox"/> control with additional properties.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.RichTextBox.IsTextSelectionEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.RichTextBox.IsTextSelectionEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.RichTextBox.IsTextSelectionEnabled">
            <summary>
            Gets or sets a value indicating whether the user can select text in the control.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ScrollDirection">
            <summary>
            Direction of <see cref="T:System.Windows.Controls.ScrollViewer"/>.
            <para>Based on <see href="https://github.com/sbaeumlisberger/VirtualizingWrapPanel"/>.</para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ScrollDirection.Vertical">
            <summary>
            Vertical scroll direction.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ScrollDirection.Horizontal">
            <summary>
            Horizontal scroll direction.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.Snackbar">
            <summary>
            Snackbar inform user of a process that an app has performed or will perform. It appears temporarily, towards the bottom of the window.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.IsCloseButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.IsCloseButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.SlideTransformProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.SlideTransform"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.IsShownProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.IsShown"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.TimeoutProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.Timeout"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.TitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.Title"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.TitleTemplateProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.TitleTemplate"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.AppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.Appearance"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.TemplateButtonCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.TemplateButtonCommand"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.ContentForegroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.Snackbar.ContentForeground"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.OpenedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.Snackbar.Opened"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.Snackbar.ClosedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.Snackbar.Closed"/> routed event.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.IsCloseButtonEnabled">
            <summary>
            Gets or sets a value indicating whether the <see cref="T:Wpf.Ui.Controls.Snackbar"/> close button should be visible.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.SlideTransform">
            <summary>
            Gets or sets the transform.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.IsShown">
            <summary>
            Gets or sets a value indicating whether the <see cref="T:Wpf.Ui.Controls.Snackbar"/> is visible.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.Timeout">
            <summary>
            Gets or sets a time for which the <see cref="T:Wpf.Ui.Controls.Snackbar"/> should be visible.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.Title">
            <summary>
            Gets or sets the title of the <see cref="T:Wpf.Ui.Controls.Snackbar"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.TitleTemplate">
            <summary>
            Gets or sets the title template of the <see cref="T:Wpf.Ui.Controls.Snackbar"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.Icon">
            <summary>
            Gets or sets the icon
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.Appearance">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.ContentForeground">
            <summary>
            Gets or sets the foreground of the <see cref="P:System.Windows.Controls.ContentControl.Content"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.Snackbar.TemplateButtonCommand">
            <summary>
            Gets the command triggered after clicking the button in the template.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.Snackbar.Opened">
            <summary>
            Occurs when the snackbar is about to open.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.Snackbar.Closed">
            <summary>
            Occurs when the snackbar is about to close.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Snackbar.#ctor(Wpf.Ui.Controls.SnackbarPresenter)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.Snackbar"/> class with a specified presenter.
            </summary>
            <param name="presenter">The <see cref="T:Wpf.Ui.Controls.SnackbarPresenter"/> to manage the snackbar's display and interactions.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.Snackbar.Show">
            <summary>
            Shows the <see cref="T:Wpf.Ui.Controls.Snackbar"/>
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Snackbar.Show(System.Boolean)">
            <summary>
            Shows the <see cref="T:Wpf.Ui.Controls.Snackbar"/>
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Snackbar.ShowAsync">
            <summary>
            Shows the <see cref="T:Wpf.Ui.Controls.Snackbar"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Snackbar.ShowAsync(System.Boolean)">
            <summary>
            Shows the <see cref="T:Wpf.Ui.Controls.Snackbar"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Snackbar.Hide">
            <summary>
            Hides the <see cref="T:Wpf.Ui.Controls.Snackbar"/>
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Snackbar.OnOpened">
            <summary>
            This virtual method is called when <see cref="T:Wpf.Ui.Controls.Snackbar"/> is opening and it raises the <see cref="E:Wpf.Ui.Controls.Snackbar.Opened"/> <see langword="event"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.Snackbar.OnClosed">
            <summary>
            This virtual method is called when <see cref="T:Wpf.Ui.Controls.Snackbar"/> is closing and it raises the <see cref="E:Wpf.Ui.Controls.Snackbar.Closed"/> <see langword="event"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.SpacingMode">
            <summary>
            Specifies how remaining space is distributed.
            <para>Based on <see href="https://github.com/sbaeumlisberger/VirtualizingWrapPanel"/>.</para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SpacingMode.None">
            <summary>
            Spacing is disabled and all items will be arranged as closely as possible.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SpacingMode.Uniform">
            <summary>
            The remaining space is evenly distributed between the items on a layout row, as well as the start and end of each row.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SpacingMode.BetweenItemsOnly">
            <summary>
            The remaining space is evenly distributed between the items on a layout row, excluding the start and end of each row.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SpacingMode.StartAndEndOnly">
            <summary>
            The remaining space is evenly distributed between start and end of each row.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.SplitButton">
            <summary>
            Represents a button with two parts that can be invoked separately. One part behaves like a standard button and the other part invokes a flyout.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SplitButton.TemplateElementToggleButton">
            <summary>
            Template element represented by the <c>ToggleButton</c> name.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.SplitButton.SplitButtonToggleButton">
            <summary>
            Gets or sets control responsible for toggling the drop-down button.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SplitButton.FlyoutProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SplitButton.Flyout"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SplitButton.IsDropDownOpenProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.SplitButton.IsDropDownOpen"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.SplitButton.Flyout">
            <summary>
            Gets or sets the flyout associated with this button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.SplitButton.IsDropDownOpen">
            <summary>
            Gets or sets a value indicating whether the drop-down for a button is currently open.
            </summary>
            <returns>
            <see langword="true" /> if the drop-down is open; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.SplitButton.OnFlyoutChanged(System.Object)">
            <summary>This method is invoked when the <see cref="F:Wpf.Ui.Controls.SplitButton.FlyoutProperty"/> changes.</summary>
            <param name="value">The new value of <see cref="F:Wpf.Ui.Controls.SplitButton.FlyoutProperty"/>.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.SplitButton.OnIsDropDownOpenChanged(System.Boolean)">
            <summary>This method is invoked when the <see cref="F:Wpf.Ui.Controls.SplitButton.IsDropDownOpenProperty"/> changes.</summary>
            <param name="currentValue">The new value of <see cref="F:Wpf.Ui.Controls.SplitButton.IsDropDownOpenProperty"/>.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.SplitButton.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.SplitButton.ReleaseTemplateResources">
            <summary>
            Triggered when the control is unloaded. Releases resource bindings.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.SymbolFilled">
            <summary>
            Represents a list of filled Fluent System Icons <c>v.1.1.271</c>.
            <para>May be converted to <see langword="char"/> using <c>GetGlyph()</c> or to <see langword="string"/> using <c>GetString()</c></para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolFilled.Empty">
            <summary>
            Actually, this icon is not empty, but makes it easier to navigate.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.SymbolGlyph">
            <summary>
            Set of static methods to operate on <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> and <see cref="T:Wpf.Ui.Controls.SymbolFilled"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolGlyph.DefaultIcon">
            <summary>
            If the icon is not found in some places, this one will be displayed.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolGlyph.DefaultFilledIcon">
            <summary>
            If the filled icon is not found in some places, this one will be displayed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.SymbolGlyph.Parse(System.String)">
            <summary>
            Finds icon based on name.
            </summary>
            <param name="name">Name of the icon.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.SymbolGlyph.ParseFilled(System.String)">
            <summary>
            Finds icon based on name.
            </summary>
            <param name="name">Name of the icon.</param>
        </member>
        <member name="T:Wpf.Ui.Controls.SymbolRegular">
            <summary>
            Represents a list of regular Fluent System Icons <c>v.1.1.271</c>.
            <para>May be converted to <see langword="char"/> using <c>GetGlyph()</c> or to <see langword="string"/> using <c>GetString()</c></para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.SymbolRegular.Empty">
            <summary>
            Actually, this icon is not empty, but makes it easier to navigate.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TabView">
            <summary>
            The TabView control is a way to display a set of tabs and their respective content.
            Tab controls are useful for displaying several pages (or documents) of content while
            giving a user the capability to rearrange, open, or close new tabs.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TabViewItem">
            <summary>
            Represents a single tab within a <see cref="T:Wpf.Ui.Controls.TabView"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TextBlock">
            <summary>
            Extended <see cref="T:System.Windows.Controls.TextBlock"/> with additional parameters like <see cref="P:Wpf.Ui.Controls.TextBlock.FontTypography"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBlock.FontTypographyProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBlock.FontTypography"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBlock.AppearanceProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBlock.Appearance"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBlock.FontTypography">
            <summary>
            Gets or sets the <see cref="P:Wpf.Ui.Controls.TextBlock.FontTypography"/> of the text.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBlock.Appearance">
            <summary>
            Gets or sets the color of the text.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TextBox">
            <summary>
            Extended <see cref="T:System.Windows.Controls.TextBox"/> with additional parameters like <see cref="P:Wpf.Ui.Controls.TextBox.PlaceholderText"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.IconPlacementProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.IconPlacement"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.PlaceholderTextProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.PlaceholderText"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.PlaceholderEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.PlaceholderEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.CurrentPlaceholderEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.CurrentPlaceholderEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.ClearButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.ClearButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.ShowClearButtonProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.ShowClearButton"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.IsTextSelectionEnabledProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.IsTextSelectionEnabled"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextBox.TemplateButtonCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TextBox.TemplateButtonCommand"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.IconPlacement">
            <summary>
            Gets or sets which side the icon should be placed on.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.PlaceholderText">
            <summary>
            Gets or sets placeholder text.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.PlaceholderEnabled">
            <summary>
            Gets or sets a value indicating whether to enable the placeholder text.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.CurrentPlaceholderEnabled">
            <summary>
            Gets or sets a value indicating whether to display the placeholder text.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.ClearButtonEnabled">
            <summary>
            Gets or sets a value indicating whether to enable the clear button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.ShowClearButton">
            <summary>
            Gets or sets a value indicating whether to show the clear button when <see cref="T:Wpf.Ui.Controls.TextBox"/> is focused.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.IsTextSelectionEnabled">
            <summary>
            Gets or sets a value indicating whether text selection is enabled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TextBox.TemplateButtonCommand">
            <summary>
            Gets the command triggered when clicking the button.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TextBox.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.TextBox"/> class.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TextBox.OnTextChanged(System.Windows.Controls.TextChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.TextBox.OnGotFocus(System.Windows.RoutedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.TextBox.OnLostFocus(System.Windows.RoutedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.TextBox.RevealClearButton">
            <summary>
            Reveals the clear button by <see cref="P:Wpf.Ui.Controls.TextBox.ShowClearButton"/> property.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TextBox.HideClearButton">
            <summary>
            Hides the clear button by <see cref="P:Wpf.Ui.Controls.TextBox.ShowClearButton"/> property.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TextBox.OnClearButtonClick">
            <summary>
            Triggered when the user clicks the clear text button.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TextBox.OnTemplateButtonClick(System.String)">
            <summary>
            Triggered by clicking a button in the control template.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TextColor">
            <summary>
            Colors for UI labels and static text
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextColor.Primary">
            <summary>
            Rest or Hover
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextColor.Secondary">
            <summary>
            Rest or Hover
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextColor.Tertiary">
            <summary>
            Pressed only (not accessible)
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TextColor.Disabled">
            <summary>
            Disabled only (not accessible)
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ThumbRate">
            <summary>
            Allows to rate positively or negatively by clicking on one of the thumbs.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ThumbRate.StateProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ThumbRate.State"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ThumbRate.StateChangedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.ThumbRate.StateChanged"/> routed event.</summary>
        </member>
        <member name="E:Wpf.Ui.Controls.ThumbRate.StateChanged">
            <summary>
            Occurs when <see cref="P:Wpf.Ui.Controls.ThumbRate.State"/> is changed.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ThumbRate.TemplateButtonCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ThumbRate.TemplateButtonCommand"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ThumbRate.State">
            <summary>
            Gets or sets the value determining the current state of the control.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ThumbRate.TemplateButtonCommand">
            <summary>
            Gets the command triggered when clicking the button.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ThumbRate.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.ThumbRate"/> class and attaches <see cref="P:Wpf.Ui.Controls.ThumbRate.TemplateButtonCommand"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ThumbRate.OnTemplateButtonClick(Wpf.Ui.Controls.ThumbRateState)">
            <summary>
            Triggered by clicking a button in the control template.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.ThumbRate.OnStateChanged(Wpf.Ui.Controls.ThumbRateState,Wpf.Ui.Controls.ThumbRateState)">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.ThumbRate.State"/> is changed.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ThumbRateState">
            <summary>
            States of the <see cref="T:Wpf.Ui.Controls.ThumbRate"/> control.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ThumbRateState.None">
            <summary>
            No thumb has been clicked.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ThumbRateState.Liked">
            <summary>
            The thumb up has been clicked.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ThumbRateState.Disliked">
            <summary>
            The thumb down has been clicked.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ClockIdentifier">
            <summary>
            Clock system.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TimePicker">
            <summary>
            Represents a control that allows a user to pick a time value.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TimePicker.HeaderProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TimePicker.Header"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TimePicker.TimeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TimePicker.Time"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TimePicker.SelectedTimeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TimePicker.SelectedTime"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TimePicker.MinuteIncrementProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TimePicker.MinuteIncrement"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TimePicker.ClockIdentifierProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TimePicker.ClockIdentifier"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TimePicker.Header">
            <summary>
            Gets or sets the content for the control's header.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TimePicker.Time">
            <summary>
            Gets or sets the time currently set in the time picker.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TimePicker.SelectedTime">
            <summary>
            Gets or sets the time currently selected in the time picker
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TimePicker.MinuteIncrement">
            <summary>
            Gets or sets a value that indicates the time increments shown in the minute picker.
            For example, 15 specifies that the TimePicker minute control displays only the choices 00, 15, 30, 45.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TimePicker.ClockIdentifier">
            <summary>
            Gets or sets the clock system to use.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TitleBar">
            <summary>
            Custom navigation buttons for the window.
            </summary>
             <summary>
             Provides optional window-resize related hit-testing support for the <see cref="T:Wpf.Ui.Controls.TitleBar"/> control.
             </summary>
             <remarks>
             This partial class implements logic to return appropriate WM_NCHITTEST results (for example
             <c>HTLEFT</c>, <c>HTBOTTOMRIGHT</c>, etc.) when the mouse is positioned over the window edges
             or corners. This enables intuitive resizing behavior when the user drags the window borders.
            
             Key points:
             - The implementation prefers the <see cref="P:System.Windows.Shell.WindowChrome.ResizeBorderThickness"/>
               value (expressed in device-independent units) when available and translates it into physical pixels;
             - If WindowChrome or DPI information is not available, the code falls back to system metrics via
               <see cref="M:Windows.Win32.PInvoke.GetSystemMetrics(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_METRICS_INDEX)"/>;
             - Because <c>WM_NCHITTEST</c> is raised frequently, computed border pixel sizes are cached to
               reduce overhead; the cache is invalidated when DPI or relevant system parameters change;
             - This component only augments the <see cref="T:Wpf.Ui.Controls.TitleBar"/> control's non-client hit-testing to
               improve resize behavior and does not alter the window style or system behavior itself.
            
             Splitting this functionality into a partial class keeps the resize-related responsibilities
             clearly separated from other TitleBar UI and interaction logic.
             </remarks>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.ApplicationThemeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.ApplicationTheme"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.TitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.Title"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.HeaderProperty">
            <summary>
            Property for <see cref="P:Wpf.Ui.Controls.TitleBar.Header"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.TrailingContentProperty">
            <summary>
            Property for <see cref="P:Wpf.Ui.Controls.TitleBar.TrailingContent"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.ButtonsForegroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.ButtonsForeground"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.ButtonsBackgroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.ButtonsBackground"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.IsMaximizedProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.IsMaximized"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.ForceShutdownProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.ForceShutdown"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.ShowMaximizeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.ShowMaximize"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.ShowMinimizeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.ShowMinimize"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.ShowHelpProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.ShowHelp"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.ShowCloseProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.ShowClose"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.CanMaximizeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.CanMaximize"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.Icon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.CloseWindowByDoubleClickOnIconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.CloseWindowByDoubleClickOnIcon"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.CloseClickedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.TitleBar.CloseClicked"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.MaximizeClickedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.TitleBar.MaximizeClicked"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.MinimizeClickedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.TitleBar.MinimizeClicked"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.HelpClickedEvent">
            <summary>Identifies the <see cref="E:Wpf.Ui.Controls.TitleBar.HelpClicked"/> routed event.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBar.TemplateButtonCommandProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBar.TemplateButtonCommand"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.ApplicationTheme">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.Title">
            <summary>
            Gets or sets title displayed on the left.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.Header">
            <summary>
            Gets or sets the content displayed in the left side of the <see cref="T:Wpf.Ui.Controls.TitleBar"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.TrailingContent">
            <summary>
            Gets or sets the content displayed in right side of the <see cref="T:Wpf.Ui.Controls.TitleBar"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.ButtonsForeground">
            <summary>
            Gets or sets the foreground of the navigation buttons.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.ButtonsBackground">
            <summary>
            Gets or sets the background of the navigation buttons when hovered.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.IsMaximized">
            <summary>
            Gets a value indicating whether the current window is maximized.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.ForceShutdown">
            <summary>
            Gets or sets a value indicating whether the controls affect main application window.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.ShowMaximize">
            <summary>
            Gets or sets a value indicating whether to show the maximize button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.ShowMinimize">
            <summary>
            Gets or sets a value indicating whether to show the minimize button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.ShowHelp">
            <summary>
            Gets or sets a value indicating whether to show the help button
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.ShowClose">
            <summary>
            Gets or sets a value indicating whether to show the close button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.CanMaximize">
            <summary>
            Gets or sets a value indicating whether the maximize functionality is enabled. If disabled the MaximizeActionOverride action won't be called
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.Icon">
            <summary>
            Gets or sets the titlebar icon.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.CloseWindowByDoubleClickOnIcon">
            <summary>
            Gets or sets a value indicating whether the window can be closed by double clicking on the icon
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.TitleBar.CloseClicked">
            <summary>
            Event triggered after clicking close button.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.TitleBar.MaximizeClicked">
            <summary>
            Event triggered after clicking maximize or restore button.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.TitleBar.MinimizeClicked">
            <summary>
            Event triggered after clicking minimize button.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Controls.TitleBar.HelpClicked">
            <summary>
            Event triggered after clicking help button
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.TemplateButtonCommand">
            <summary>
            Gets the command triggered when clicking the titlebar button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.MaximizeActionOverride">
            <summary>
            Gets or sets the <see cref="T:System.Action"/> that should be executed when the Maximize button is clicked."/>
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBar.MinimizeActionOverride">
            <summary>
            Gets or sets what <see cref="T:System.Action"/> should be executed when the Minimize button is clicked.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBar.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.TitleBar"/> class and sets the default <see cref="E:System.Windows.FrameworkElement.Loaded"/> event.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBar.OnInitialized(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBar.OnApplyTemplate">
            <summary>
            Invoked whenever application code or an internal process,
            such as a rebuilding layout pass, calls the ApplyTemplate method.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBar.OnThemeChanged(Wpf.Ui.Appearance.ApplicationTheme,System.Windows.Media.Color)">
            <summary>
            This virtual method is triggered when the app's theme changes.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBar.OnWindowContentRendered(System.Object,System.EventArgs)">
            <summary>
             Listening window hooks after rendering window content to SizeToContent support
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBar.TitleBar_MouseRightButtonUp(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            Show 'SystemMenu' on mouse right button up.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButton.ButtonTypeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBarButton.ButtonType"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButton.ButtonsForegroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBarButton.ButtonsForeground"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButton.MouseOverButtonsForegroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBarButton.MouseOverButtonsForeground"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButton.RenderButtonsForegroundProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TitleBarButton.RenderButtonsForeground"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBarButton.ButtonType">
            <summary>
            Gets or sets the type of the button.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBarButton.ButtonsForeground">
            <summary>
            Gets or sets the foreground of the navigation buttons.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TitleBarButton.MouseOverButtonsForeground">
            <summary>
            Gets or sets the foreground of the navigation buttons when moused over.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBarButton.Hover">
            <summary>
            Forces button background to change.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBarButton.RemoveHover">
            <summary>
            Forces button background to change.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TitleBarButton.InvokeClick">
            <summary>
            Invokes click on the button.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TitleBarButtonType">
            <summary>
            Type of the Title Bar button.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButtonType.Unknown">
            <summary>
            Unknown button.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButtonType.Minimize">
            <summary>
            Maximize button.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButtonType.Close">
            <summary>
            Close button.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButtonType.Maximize">
            <summary>
            Maximize button.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButtonType.Restore">
            <summary>
            Restore button.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TitleBarButtonType.Help">
            <summary>
            Help button.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.ToggleSwitch">
            <summary>
            Use <see cref="T:Wpf.Ui.Controls.ToggleSwitch"/> to present users with two mutally exclusive options (like on/off).
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ToggleSwitch.OffContentProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ToggleSwitch.OffContent"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.ToggleSwitch.OnContentProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.ToggleSwitch.OnContent"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ToggleSwitch.OffContent">
            <summary>
            Gets or sets the content that should be displayed when the <see cref="T:Wpf.Ui.Controls.ToggleSwitch"/> is in the "Off" state.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.ToggleSwitch.OnContent">
            <summary>
            Gets or sets the content that should be displayed when the <see cref="T:Wpf.Ui.Controls.ToggleSwitch"/> is in the "On" state.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TreeGrid">
            <summary>
            TODO: Work in progress.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TreeGrid.HeadersProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TreeGrid.Headers"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TreeGrid.Headers">
            <summary>
            Gets or sets the data used to generate the child elements of this control.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TreeGridHeader">
            <summary>
            Work in progress.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TreeGridHeader.TitleProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TreeGridHeader.Title"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TreeGridHeader.GroupProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TreeGridHeader.Group"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TreeGridHeader.Title">
            <summary>
            Gets or sets the title that will be displayed.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TreeGridHeader.Group">
            <summary>
            Gets or sets the column group name.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.TreeGridHeader.OnTitleChanged">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.TreeGridHeader.Title"/> is changed.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TreeGridItem">
            <summary>
            Work in progress.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TreeViewItem">
            <summary>
            Extended <see cref="T:System.Windows.Controls.TreeViewItem"/> with <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> properties.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.TreeViewItem.IconProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.TreeViewItem.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.TreeViewItem.Icon">
            <summary>
            Gets or sets displayed <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.TypedEventHandler`2">
            <summary>
            Represents a method that handles general events.
            </summary>
            <typeparam name="TSender">The type of the sender.</typeparam>
            <typeparam name="TArgs">The type of the event data.</typeparam>
            <param name="sender">The source of the event.</param>
            <param name="args">An object that contains the event data.</param>
        </member>
        <member name="T:Wpf.Ui.Controls.VirtualizingGridView">
            <summary>
            Simple control that displays a gird of items. Depending on the orientation, the items are either stacked horizontally or vertically
            until the items are wrapped to the next row or column. The control is using virtualization to support large amount of items.
            <para>In order to work properly all items must have the same size.</para>
            <para>Based on <see href="https://github.com/sbaeumlisberger/VirtualizingWrapPanel"/>.</para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingGridView.OrientationProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingGridView.Orientation"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingGridView.SpacingModeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingGridView.SpacingMode"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingGridView.StretchItemsProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingGridView.StretchItems"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingGridView.Orientation">
            <summary>
            Gets or sets a value that specifies the orientation in which items are arranged. The default value is <see cref="F:System.Windows.Controls.Orientation.Vertical"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingGridView.SpacingMode">
            <summary>
            Gets or sets the spacing mode used when arranging the items. The default value is <see cref="F:Wpf.Ui.Controls.SpacingMode.Uniform"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingGridView.StretchItems">
            <summary>
            Gets or sets a value indicating whether the items get stretched to fill up remaining space. The default value is false.
            </summary>
            <remarks>
            The MaxWidth and MaxHeight properties of the ItemContainerStyle can be used to limit the stretching.
            In this case the use of the remaining space will be determined by the SpacingMode property.
            </remarks>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingGridView.InitializeItemsPanel">
            <summary>
            Initializes the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel"/> with <see cref="T:Wpf.Ui.Controls.VirtualizingWrapPanel"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.VirtualizingItemsControl">
            <summary>
            Virtualized <see cref="T:System.Windows.Controls.ItemsControl"/>.
            <para>Based on <see href="https://github.com/sbaeumlisberger/VirtualizingWrapPanel"/>.</para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingItemsControl.CacheLengthUnitProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingItemsControl.CacheLengthUnit"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingItemsControl.CacheLengthUnit">
            <summary>
            Gets or sets the cache length unit.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingItemsControl.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Controls.VirtualizingItemsControl"/> class.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.VirtualizingUniformGrid">
            <summary>
            <para><c>Work in progress.</c></para>
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.VirtualizingPanelBase">
            <summary>
            Base abstract class for creating virtualized panels.
            <para>Based on <see href="https://github.com/sbaeumlisberger/VirtualizingWrapPanel"/>.</para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingPanelBase._itemsOwner">
            <summary>
            Owner of the displayed items.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingPanelBase._itemContainerGenerator">
            <summary>
            Items generator.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingPanelBase._previousVerticalScrollBarVisibility">
            <summary>
            Previously set visibility of the vertical scroll bar.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingPanelBase._previousHorizontalScrollBarVisibility">
            <summary>
            Previously set visibility of the horizontal scroll bar.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.CanHierarchicallyScrollAndVirtualizeCore">
            <inheritdoc />
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollUnit">
            <summary>
            Gets the scroll unit.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelScrollDirection">
            <summary>
            Gets or sets the direction in which the panel scrolls when user turns the mouse wheel.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.IsVirtualizing">
            <summary>
            Gets a value indicating whether the virtualizing is enabled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.VirtualizationMode">
            <summary>
            Gets the virtualization mode.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.IsRecycling">
            <summary>
            Gets a value indicating whether the panel is in VirtualizationMode.Recycling.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.CacheLength">
            <summary>
            Gets the cache length before and after the viewport.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.CacheLengthUnit">
            <summary>
            Gets the Unit of the cache length. Can be Pixel, Item or Page.
            When the ItemsOwner is a group item it can only be pixel or item.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ItemsControl">
            <summary>
            Gets the ItemsControl (e.g. ListView).
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ItemsOwner">
            <summary>
            Gets the ItemsControl (e.g. ListView) or if the ItemsControl is grouping a GroupItem.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.Items">
            <summary>
            Gets items collection.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.Offset">
            <summary>
            Gets the offset.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ItemContainerGenerator">
            <summary>
            Gets items container.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ItemRange">
            <summary>
            Gets or sets the range of items that a realized in <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.Viewport"/> or cache.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.Extent">
            <summary>
            Gets the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.Extent"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.Viewport">
            <summary>
            Gets the viewport.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollLineDeltaProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollLineDelta"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelDeltaProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelDelta"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollLineDeltaItemProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollLineDeltaItem"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelDeltaItemProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelDeltaItem"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollOwner">
            <summary>
            Gets or sets the scroll owner.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.CanVerticallyScroll">
            <summary>
            Gets or sets a value indicating whether the content can be vertically scrolled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.CanHorizontallyScroll">
            <summary>
            Gets or sets a value indicating whether the content can be horizontally scrolled.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollLineDelta">
            <summary>
            Gets or sets the scroll line delta for pixel based scrolling. The default value is 16 dp.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelDelta">
            <summary>
            Gets or sets the mouse wheel delta for pixel based scrolling. The default value is 48 dp.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollLineDeltaItem">
            <summary>
            Gets or sets the scroll line delta for item based scrolling. The default value is 1 item.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelDeltaItem">
            <summary>
            Gets or sets the mouse wheel delta for item based scrolling. The default value is 3 items.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ExtentWidth">
            <summary>
            Gets width of the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.Extent"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ExtentHeight">
            <summary>
            Gets height of the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.Extent"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.HorizontalOffset">
            <summary>
            Gets the horizontal offset.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.VerticalOffset">
            <summary>
            Gets the vertical offset.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ViewportWidth">
            <summary>
            Gets the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.Viewport"/> width.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingPanelBase.ViewportHeight">
            <summary>
            Gets the <see cref="P:Wpf.Ui.Controls.VirtualizingPanelBase.Viewport"/> height.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.MakeVisible(System.Windows.Media.Visual,System.Windows.Rect)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.SetVerticalOffset(System.Double)">
            <summary>
            Sets the vertical offset.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.SetHorizontalOffset(System.Double)">
            <summary>
            Sets the horizontal offset.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.LineUp">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.LineDown">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.LineLeft">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.LineRight">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelUp">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelDown">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelLeft">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.MouseWheelRight">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.PageUp">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.PageDown">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.PageLeft">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.PageRight">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.OnItemsChanged(System.Object,System.Windows.Controls.Primitives.ItemsChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.UpdateScrollInfo(System.Windows.Size,System.Windows.Size)">
            <summary>
            Updates scroll offset, extent and viewport.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetItemIndexFromChildIndex(System.Int32)">
            <summary>
            Gets item index from the generator.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetGeneratorPositionFromChildIndex(System.Int32)">
            <summary>
            Gets the position of children from the generator.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.RealizeItems">
            <summary>
            Realizes visible and cached items.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.VirtualizeItems">
            <summary>
            Virtualizes (cleanups) no longer visible or cached items.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollVertical(System.Double)">
            <summary>
            Sets vertical scroll offset by given amount.
            </summary>
            <param name="amount">The value by which the offset is to be increased.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.ScrollHorizontal(System.Double)">
            <summary>
            Sets horizontal scroll offset by given amount.
            </summary>
            <param name="amount">The value by which the offset is to be increased.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.CalculateExtent(System.Windows.Size)">
            <summary>
            Calculates the extent that would be needed to show all items.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.UpdateItemRange">
            <summary>
            Calculates the item range that is visible in the viewport or cached.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetLineUpScrollAmount">
            <summary>
            Gets line up scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetLineDownScrollAmount">
            <summary>
            Gets line down scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetLineLeftScrollAmount">
            <summary>
            Gets line left scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetLineRightScrollAmount">
            <summary>
            Gets line right scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetMouseWheelUpScrollAmount">
            <summary>
            Gets mouse wheel up scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetMouseWheelDownScrollAmount">
            <summary>
            Gets mouse wheel down scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetMouseWheelLeftScrollAmount">
            <summary>
            Gets mouse wheel left scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetMouseWheelRightScrollAmount">
            <summary>
            Gets mouse wheel right scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetPageUpScrollAmount">
            <summary>
            Gets page up scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetPageDownScrollAmount">
            <summary>
            Gets page down scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetPageLeftScrollAmount">
            <summary>
            Gets page left scroll amount.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingPanelBase.GetPageRightScrollAmount">
            <summary>
            Gets page right scroll amount.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.VirtualizingWrapPanel">
            <summary>
            Extended base class for <see cref="T:System.Windows.Controls.VirtualizingPanel"/>.
            <para>Based on <see href="https://github.com/sbaeumlisberger/VirtualizingWrapPanel"/>.</para>
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingWrapPanel.ChildSize">
            <summary>
            Gets or sets the size of the single child element.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingWrapPanel.RowCount">
            <summary>
            Gets or sets the amount of the displayed rows.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingWrapPanel.ItemsPerRowCount">
            <summary>
            Gets or sets the amount of displayed items per row.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingWrapPanel.SpacingModeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingWrapPanel.SpacingMode"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingWrapPanel.OrientationProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingWrapPanel.Orientation"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingWrapPanel.ItemSizeProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingWrapPanel.ItemSize"/> dependency property.</summary>
        </member>
        <member name="F:Wpf.Ui.Controls.VirtualizingWrapPanel.StretchItemsProperty">
            <summary>Identifies the <see cref="P:Wpf.Ui.Controls.VirtualizingWrapPanel.StretchItems"/> dependency property.</summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingWrapPanel.SpacingMode">
            <summary>
            Gets or sets the spacing mode used when arranging the items. The default value is <see cref="F:Wpf.Ui.Controls.SpacingMode.Uniform"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingWrapPanel.Orientation">
            <summary>
            Gets or sets a value that specifies the orientation in which items are arranged. The default value is <see cref="F:System.Windows.Controls.Orientation.Vertical"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingWrapPanel.ItemSize">
            <summary>
            Gets or sets a value that specifies the size of the items. The default value is <see cref="P:System.Windows.Size.Empty"/>.
            If the value is <see cref="P:System.Windows.Size.Empty"/> the size of the items gots measured by the first realized item.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Controls.VirtualizingWrapPanel.StretchItems">
            <summary>
            Gets or sets a value indicating whether the items get stretched to fill up remaining space. The default value is false.
            </summary>
            <remarks>
            The MaxWidth and MaxHeight properties of the ItemContainerStyle can be used to limit the stretching.
            In this case the use of the remaining space will be determined by the SpacingMode property.
            </remarks>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.OnOrientationChanged">
            <summary>
            This virtual method is called when <see cref="P:Wpf.Ui.Controls.VirtualizingWrapPanel.Orientation"/> is changed.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.OnOrientationChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Private callback for <see cref="F:Wpf.Ui.Controls.VirtualizingWrapPanel.OrientationProperty"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.UpdateChildSize(System.Windows.Size)">
            <summary>
            Updates child size of <see cref="P:Wpf.Ui.Controls.VirtualizingWrapPanel.ItemSize"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.CalculateChildSize(System.Windows.Size)">
            <summary>
            Calculates child size.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.CalculateExtent(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.CalculateSpacing(System.Windows.Size,System.Double@,System.Double@)">
            <summary>
            Calculates desired spacing between items.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.CalculateChildArrangeSize(System.Windows.Size)">
            <summary>
            Calculates desired child arrange size.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.ReadItemContainerStyle``1(System.Windows.DependencyProperty,``0)">
            <summary>
            Gets the style property value for item containers within the <see cref="T:System.Windows.Controls.ItemsControl"/>.
            </summary>
            <typeparam name="T">The expected type of the property value.</typeparam>
            <param name="property">The <see cref="T:System.Windows.DependencyProperty"/> to retrieve the value for.</param>
            <param name="fallbackValue">The value to return if the property is not set.</param>
            <returns>The value of the specified property if found; otherwise, the <paramref name="fallbackValue"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.UpdateItemRange">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetRowIndex(System.Double)">
            <summary>
            Gets item row index.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.BringIndexIntoView(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetLineUpScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetLineDownScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetLineLeftScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetLineRightScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetMouseWheelUpScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetMouseWheelDownScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetMouseWheelLeftScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetMouseWheelRightScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetPageUpScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetPageDownScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetPageLeftScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetPageRightScrollAmount">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetX(System.Windows.Point)">
            <summary>
            Gets X panel orientation.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetY(System.Windows.Point)">
            <summary>
            Gets Y panel orientation.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetWidth(System.Windows.Size)">
            <summary>
            Gets panel width.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.GetHeight(System.Windows.Size)">
            <summary>
            Gets panel height.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.CreateSize(System.Double,System.Double)">
            <summary>
            Defines panel size.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.VirtualizingWrapPanel.CreateRect(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Defines panel coordinates and size.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.WindowBackdrop">
            <summary>
            Applies the chosen backdrop effect to the selected window.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Controls.WindowBackdrop.IsSupported(Wpf.Ui.Controls.WindowBackdropType)">
            <summary>
            Checks whether the selected backdrop type is supported on current platform.
            </summary>
            <returns><see langword="true"/> if the selected backdrop type is supported on current platform.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.WindowBackdrop.ApplyBackdrop(System.Windows.Window,Wpf.Ui.Controls.WindowBackdropType)">
            <summary>
            Applies a backdrop effect to the selected <see cref="T:System.Windows.Window"/>.
            </summary>
            <param name="window">The window to which the backdrop effect will be applied.</param>
            <param name="backdropType">The type of backdrop effect to apply. Determines the visual appearance of the window's backdrop.</param>
            <returns><see langword="true"/> if the operation was successful; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.WindowBackdrop.ApplyBackdrop(System.IntPtr,Wpf.Ui.Controls.WindowBackdropType)">
            <summary>
            Applies backdrop effect to the selected window handle based on the specified backdrop type.
            </summary>
            <param name="hWnd">The window handle to which the backdrop effect will be applied.</param>
            <param name="backdropType">The type of backdrop effect to apply. This determines the visual appearance of the window's backdrop.</param>
            <returns><see langword="true"/> if the operation was successful; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Controls.WindowBackdrop.RemoveBackdrop(System.Windows.Window)">
            <summary>
            Tries to remove backdrop effects if they have been applied to the <see cref="T:System.Windows.Window"/>.
            </summary>
            <param name="window">The window from which the effect should be removed.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.WindowBackdrop.RemoveBackdrop(System.IntPtr)">
            <summary>
            Tries to remove all effects if they have been applied to the <c>hWnd</c>.
            </summary>
            <param name="hWnd">Pointer to the window handle.</param>
        </member>
        <member name="M:Wpf.Ui.Controls.WindowBackdrop.RemoveBackground(System.Windows.Window)">
            <summary>
            Tries to remove background from <see cref="T:System.Windows.Window"/> and it's composition area.
            </summary>
            <param name="window">Window to manipulate.</param>
            <returns><see langword="true"/> if operation was successful.</returns>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowBackdropType.None">
            <summary>
            No backdrop effect.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowBackdropType.Auto">
            <summary>
            Sets <c>DWMWA_SYSTEMBACKDROP_TYPE</c> to <see langword="0"></see>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowBackdropType.Mica">
            <summary>
            Windows 11 Mica effect.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowBackdropType.Acrylic">
            <summary>
            Windows Acrylic effect.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowBackdropType.Tabbed">
            <summary>
            Windows 11 wallpaper blur effect.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Controls.WindowCornerPreference">
            <summary>
            Ways you can round windows.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowCornerPreference.Default">
            <summary>
            Determined by system or application preference.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowCornerPreference.DoNotRound">
            <summary>
            Do not round the corners.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowCornerPreference.Round">
            <summary>
            Round the corners.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Controls.WindowCornerPreference.RoundSmall">
            <summary>
            Round the corners slightly.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Converters.ClipConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Converters.ClipConverter.ConvertBack(System.Object,System.Type[],System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Converters.DatePickerButtonPaddingConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.Converters.DatePickerButtonPaddingConverter.ConvertBack(System.Object,System.Type[],System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.Converters.IconSourceElementConverter">
            <summary>
            Converts an <see cref="T:Wpf.Ui.Controls.IconSourceElement"/> to an <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Converters.IconSourceElementConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Converts a value to an <see cref="T:Wpf.Ui.Controls.IconElement"/>.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="targetType">The type of the binding target property.</param>
            <param name="parameter">The converter parameter.</param>
            <param name="culture">The culture to use in the converter.</param>
            <returns>The converted <see cref="T:Wpf.Ui.Controls.IconElement"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Converters.IconSourceElementConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Converts an <see cref="T:Wpf.Ui.Controls.IconElement"/> back to an IconSourceElement.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="targetType">The type of the binding target property.</param>
            <param name="parameter">The converter parameter.</param>
            <param name="culture">The culture to use in the converter.</param>
            <returns>The converted IconSourceElement.</returns>
        </member>
        <member name="T:Wpf.Ui.Designer.DesignerHelper">
            <summary>
            Helper class for Visual Studio designer.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Designer.DesignerHelper.IsInDesignMode">
            <summary>
            Gets a value indicating whether the project is currently in design mode.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Designer.DesignerHelper.IsDebugging">
            <summary>
            Gets a value indicating whether the project is currently debugged.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Extensions.ColorExtensions">
            <summary>
            Adds an extension for <see cref="T:System.Windows.Media.Color"/> that allows manipulation with HSL and HSV color spaces.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Extensions.ColorExtensions._byteMax">
            <summary>
            Maximum <see cref="T:System.Byte"/> size with the current <see cref="T:System.Single"/> precision.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.ToBrush(System.Windows.Media.Color)">
            <summary>
            Creates a <see cref="T:System.Windows.Media.SolidColorBrush"/> from a <see cref="T:System.Windows.Media.Color"/>.
            </summary>
            <param name="color">Input color.</param>
            <returns>Brush converted to color.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.ToBrush(System.Windows.Media.Color,System.Double)">
            <summary>
            Creates a <see cref="T:System.Windows.Media.SolidColorBrush"/> from a <see cref="T:System.Windows.Media.Color"/> with defined brush opacity.
            </summary>
            <param name="color">Input color.</param>
            <param name="opacity">Degree of opacity.</param>
            <returns>Brush converted to color with modified opacity.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.GetLuminance(System.Windows.Media.Color)">
            <summary>
            Gets <see cref="T:System.Windows.Media.Color"/> luminance based on HSL space.
            </summary>
            <param name="color">Input color.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.GetBrightness(System.Windows.Media.Color)">
            <summary>
            Gets <see cref="T:System.Windows.Media.Color"/> brightness based on HSV space.
            </summary>
            <param name="color">Input color.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.GetHue(System.Windows.Media.Color)">
            <summary>
            Gets <see cref="T:System.Windows.Media.Color"/> hue based on HSV space.
            </summary>
            <param name="color">Input color.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.GetSaturation(System.Windows.Media.Color)">
            <summary>
            Gets <see cref="T:System.Windows.Media.Color"/> saturation based on HSV space.
            </summary>
            <param name="color">Input color.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.UpdateLuminance(System.Windows.Media.Color,System.Single)">
            <summary>
            Allows to change the luminance by a factor based on the HSL color space.
            </summary>
            <param name="color">Input color.</param>
            <param name="factor">The value of the luminance change factor from <see langword="100"/> to <see langword="-100"/>.</param>
            <returns>Updated <see cref="T:System.Windows.Media.Color"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.UpdateSaturation(System.Windows.Media.Color,System.Single)">
            <summary>
            Allows to change the saturation by a factor based on the HSL color space.
            </summary>
            <param name="color">Input color.</param>
            <param name="factor">The value of the saturation change factor from <see langword="100"/> to <see langword="-100"/>.</param>
            <returns>Updated <see cref="T:System.Windows.Media.Color"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.UpdateBrightness(System.Windows.Media.Color,System.Single)">
            <summary>
            Allows to change the brightness by a factor based on the HSV color space.
            </summary>
            <param name="color">Input color.</param>
            <param name="factor">The value of the brightness change factor from <see langword="100"/> to <see langword="-100"/>.</param>
            <returns>Updated <see cref="T:System.Windows.Media.Color"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.Update(System.Windows.Media.Color,System.Single,System.Single,System.Single)">
            <summary>
            Allows to change the brightness, saturation and luminance by a factors based on the HSL and HSV color space.
            </summary>
            <param name="color">Color to convert.</param>
            <param name="brightnessFactor">The value of the brightness change factor from <see langword="100"/> to <see langword="-100"/>.</param>
            <param name="saturationFactor">The value of the saturation change factor from <see langword="100"/> to <see langword="-100"/>.</param>
            <param name="luminanceFactor">The value of the luminance change factor from <see langword="100"/> to <see langword="-100"/>.</param>
            <returns>Updated <see cref="T:System.Windows.Media.Color"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.ToHsl(System.Windows.Media.Color)">
            <summary>
            HSL representation models the way different paints mix together to create colour in the real world,
            with the lightness dimension resembling the varying amounts of black or white paint in the mixture.
            </summary>
            <returns><see langword="float"/> hue, <see langword="float"/> saturation, <see langword="float"/> lightness</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.ToHsv(System.Windows.Media.Color)">
            <summary>
            HSV representation models how colors appear under light.
            </summary>
            <returns><see langword="float"/> hue, <see langword="float"/> saturation, <see langword="float"/> brightness</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.FromHslToRgb(System.Single,System.Single,System.Single)">
            <summary>
            Converts the color values stored as HSL to RGB.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.FromHsvToRgb(System.Single,System.Single,System.Single)">
            <summary>
            Converts the color values stored as HSV (HSB) to RGB.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.CalcHslChannel(System.Single,System.Single,System.Single)">
            <summary>
            Calculates the color component for HSL.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.AlmostEquals(System.Single,System.Single,System.Single)">
            <summary>
            Whether the floating point number is about the same.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.ToPercentage(System.Single)">
            <summary>
            Absolute percentage.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.ColorExtensions.ToColorByte(System.Int32)">
            <summary>
            Absolute byte.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.ContentDialogServiceExtensions.ShowAlertAsync(Wpf.Ui.IContentDialogService,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Shows the simple alert-like dialog.
            </summary>
            <returns>Result of the life cycle of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.ContentDialogServiceExtensions.ShowSimpleDialogAsync(Wpf.Ui.IContentDialogService,Wpf.Ui.SimpleContentDialogCreateOptions,System.Threading.CancellationToken)">
            <summary>
            Shows simple dialog
            </summary>
            <param name="dialogService">The <see cref="T:Wpf.Ui.IContentDialogService"/>.</param>
            <param name="options">Set of parameters of the basic dialog box.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>Result of the life cycle of the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.</returns>
        </member>
        <member name="T:Wpf.Ui.Extensions.ContextMenuExtensions">
            <summary>
            Extensions for the <see cref="T:System.Windows.Controls.ContextMenu"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.ContextMenuExtensions.ApplyMica(System.Windows.Controls.ContextMenu)">
            <summary>
            Tries to apply Mica effect to the <see cref="T:System.Windows.Controls.ContextMenu"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Extensions.DateTimeExtensions">
            <summary>
            A collection of several extensions to the <see cref="T:System.DateTime"/> class.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.DateTimeExtensions.GetTimestamp(System.DateTime)">
            <summary>
            Gets the number of seconds that have elapsed since the Unix epoch, excluding leap seconds. The Unix epoch is 00:00:00 UTC on 1 January 1970.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.DateTimeExtensions.GetMillisTimestamp(System.DateTime)">
            <summary>
            Gets the number of milliseconds that have elapsed since the Unix epoch, excluding leap seconds. The Unix epoch is 00:00:00 UTC on 1 January 1970.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.DateTimeExtensions.GetMicroTimestamp(System.DateTime)">
            <summary>
            Gets the number of microseconds that have elapsed since the Unix epoch, excluding leap seconds. The Unix epoch is 00:00:00 UTC on 1 January 1970.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Extensions.FrameExtensions">
            <summary>
            Set of extensions for <see cref="T:System.Windows.Controls.Frame"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.FrameExtensions.GetDataContext(System.Windows.Controls.Frame)">
            <summary>
            Gets <see cref="P:System.Windows.FrameworkElement.DataContext"/> from <see cref="T:System.Windows.Controls.Frame"/>.
            </summary>
            <param name="frame">Selected frame.</param>
            <returns>DataContext of currently active element, otherwise <see langword="null"/>.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.FrameExtensions.CleanNavigation(System.Windows.Controls.Frame)">
            <summary>
            Cleans <see cref="T:System.Windows.Controls.Frame"/> journal.
            </summary>
            <param name="frame">Selected frame.</param>
        </member>
        <member name="T:Wpf.Ui.Extensions.NavigationServiceExtensions">
            <summary>
            Extensions for the <see cref="T:Wpf.Ui.INavigationService"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.NavigationServiceExtensions.SetPaneDisplayMode(Wpf.Ui.INavigationService,Wpf.Ui.Controls.NavigationViewPaneDisplayMode)">
            <summary>
            Sets the pane display mode of the navigation service.
            </summary>
            <param name="navigationService">The navigation service.</param>
            <param name="paneDisplayMode">The pane display mode.</param>
            <returns>Same <see cref="T:Wpf.Ui.INavigationService"/> so multiple calls can be chained.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.PInvokeExtensions.get_DWMWA_MICA_EFFECT">
            <inheritdoc cref="P:Wpf.Ui.Extensions.PInvokeExtensions.&lt;G&gt;$DCD808F4E0B1DD026AA484D6F8CBBA72.DWMWA_MICA_EFFECT"/>
        </member>
        <member name="M:Wpf.Ui.Extensions.PInvokeExtensions.get_DMWA_USE_IMMERSIVE_DARK_MODE_OLD">
            <inheritdoc cref="P:Wpf.Ui.Extensions.PInvokeExtensions.&lt;G&gt;$DCD808F4E0B1DD026AA484D6F8CBBA72.DMWA_USE_IMMERSIVE_DARK_MODE_OLD"/>
        </member>
        <member name="P:Wpf.Ui.Extensions.PInvokeExtensions.&lt;G&gt;$DCD808F4E0B1DD026AA484D6F8CBBA72.DWMWA_MICA_EFFECT">
            <summary>
            Gets the undocumented window attribute for enabling Mica effect on a window.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Extensions.PInvokeExtensions.&lt;G&gt;$DCD808F4E0B1DD026AA484D6F8CBBA72.DMWA_USE_IMMERSIVE_DARK_MODE_OLD">
            <summary>
            Gets the window attribute used to enable immersive dark mode prior to Windows 11.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Extensions.SnackbarServiceExtensions">
            <summary>
            Extensions for the <see cref="T:Wpf.Ui.ISnackbarService"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.SnackbarServiceExtensions.Show(Wpf.Ui.ISnackbarService,System.String,System.String)">
            <summary>
            Shows the snackbar. If it is already visible, firstly hides it for a moment, changes its content, and then shows it again.
            </summary>
            <param name="snackbarService">The <see cref="T:Wpf.Ui.ISnackbarService"/>.</param>
            <param name="title">Name displayed on top of snackbar.</param>
            <param name="message">Message inside the snackbar.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.SnackbarServiceExtensions.Show(Wpf.Ui.ISnackbarService,System.String,System.String,Wpf.Ui.Controls.ControlAppearance)">
            <summary>
            Shows the snackbar. If it is already visible, firstly hides it for a moment, changes its content, and then shows it again.
            </summary>
            <param name="snackbarService">The <see cref="T:Wpf.Ui.ISnackbarService"/>.</param>
            <param name="title">Name displayed on top of snackbar.</param>
            <param name="message">Message inside the snackbar.</param>
            <param name="appearance">Display style.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.SnackbarServiceExtensions.Show(Wpf.Ui.ISnackbarService,System.String,System.String,Wpf.Ui.Controls.IconElement)">
            <summary>
            Shows the snackbar. If it is already visible, firstly hides it for a moment, changes its content, and then shows it again.
            </summary>
            <param name="snackbarService">The <see cref="T:Wpf.Ui.ISnackbarService"/>.</param>
            <param name="title">Name displayed on top of snackbar.</param>
            <param name="message">Message inside the snackbar.</param>
            <param name="icon">Additional icon on the left.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.SnackbarServiceExtensions.Show(Wpf.Ui.ISnackbarService,System.String,System.String,System.TimeSpan)">
            <summary>
            Shows the snackbar. If it is already visible, firstly hides it for a moment, changes its content, and then shows it again.
            </summary>
            <param name="snackbarService">The <see cref="T:Wpf.Ui.ISnackbarService"/>.</param>
            <param name="title">Name displayed on top of snackbar.</param>
            <param name="message">Message inside the snackbar.</param>
            <param name="timeout">The time after which the snackbar should disappear.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.SnackbarServiceExtensions.Show(Wpf.Ui.ISnackbarService,System.String,System.String,Wpf.Ui.Controls.ControlAppearance,System.TimeSpan)">
            <summary>
            Shows the snackbar. If it is already visible, firstly hides it for a moment, changes its content, and then shows it again.
            </summary>
            <param name="snackbarService">The <see cref="T:Wpf.Ui.ISnackbarService"/>.</param>
            <param name="title">Name displayed on top of snackbar.</param>
            <param name="message">Message inside the snackbar.</param>
            <param name="appearance">Display style.</param>
            <param name="timeout">The time after which the snackbar should disappear.</param>
        </member>
        <member name="M:Wpf.Ui.Extensions.SnackbarServiceExtensions.Show(Wpf.Ui.ISnackbarService,System.String,System.String,Wpf.Ui.Controls.IconElement,System.TimeSpan)">
            <summary>
            Shows the snackbar. If it is already visible, firstly hides it for a moment, changes its content, and then shows it again.
            </summary>
            <param name="snackbarService">The <see cref="T:Wpf.Ui.ISnackbarService"/>.</param>
            <param name="title">Name displayed on top of snackbar.</param>
            <param name="message">Message inside the snackbar.</param>
            <param name="icon">Additional icon on the left.</param>
            <param name="timeout">The time after which the snackbar should disappear.</param>
        </member>
        <member name="T:Wpf.Ui.Extensions.SymbolExtensions">
            <summary>
            Set of extensions for the enumeration of icons to facilitate their management and replacement.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.SymbolExtensions.Swap(Wpf.Ui.Controls.SymbolRegular)">
            <summary>
            Replaces <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> with <see cref="T:Wpf.Ui.Controls.SymbolFilled"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.SymbolExtensions.Swap(Wpf.Ui.Controls.SymbolFilled)">
            <summary>
            Replaces <see cref="T:Wpf.Ui.Controls.SymbolFilled"/> with <see cref="T:Wpf.Ui.Controls.SymbolRegular"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.SymbolExtensions.GetString(Wpf.Ui.Controls.SymbolRegular)">
            <summary>
            Converts <see cref="T:Wpf.Ui.Controls.SymbolRegular"/> to <see langword="string"/> based on the ID.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.SymbolExtensions.GetString(Wpf.Ui.Controls.SymbolFilled)">
            <summary>
            Converts <see cref="T:Wpf.Ui.Controls.SymbolFilled"/> to <see langword="string"/> based on the ID.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Extensions.TextBlockFontTypographyExtensions">
            <summary>
            Extension that converts the typography type enumeration to the name of the resource that represents it.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.TextBlockFontTypographyExtensions.ToResourceValue(Wpf.Ui.Controls.FontTypography)">
            <summary>
             Converts the typography type enumeration to the name of the resource that represents it.
            </summary>
            <returns>Name of the resource matching the <see cref="T:Wpf.Ui.Controls.FontTypography"/>. <see cref="T:System.ArgumentOutOfRangeException"/> otherwise.</returns>
        </member>
        <member name="T:Wpf.Ui.Extensions.TextColorExtensions">
            <summary>
            Extension that converts the text color type enumeration to the name of the resource that represents it.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.TextColorExtensions.ToResourceValue(Wpf.Ui.Controls.TextColor)">
            <summary>
            Converts the text color type enumeration to the name of the resource that represents it.
            </summary>
            <returns>Name of the resource matching the <see cref="T:Wpf.Ui.Controls.TextColor"/>. <see cref="T:System.ArgumentOutOfRangeException"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.Extensions.UiElementExtensions.IsMouseOverElement(System.Windows.UIElement,System.IntPtr)">
            <summary>
            Do not call it outside of NCHITTEST, NCLBUTTONUP, NCLBUTTONDOWN messages!
            </summary>
            <returns><see langword="true" /> if mouse is over the element. <see langword="false" /> otherwise.</returns>
        </member>
        <member name="T:Wpf.Ui.Extensions.UriExtensions">
            <summary>
            Extensions for <see cref="T:System.Uri"/> class.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.UriExtensions.TrimLastSegment(System.Uri)">
            <summary>
            Removes last segment of the <see cref="T:System.Uri"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.UriExtensions.EndsWith(System.Uri,System.String)">
            <summary>
            Determines whether the end of <see cref="T:System.Uri"/> is equal to provided value.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.UriExtensions.Append(System.Uri,System.String[])">
            <summary>
            Append provided segments to the <see cref="T:System.Uri"/>.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Extensions.UriExtensions.Append(System.Uri,System.Uri)">
            <summary>
            Append new <see cref="T:System.Uri"/> to the <see cref="T:System.Uri"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Hardware.DisplayDpi">
            <summary>
            Stores DPI information from which a <see cref="T:System.Windows.Media.Visual"/> or <see cref="T:System.Windows.UIElement"/>
            is rendered.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Hardware.DisplayDpi.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Hardware.DisplayDpi"/> structure.
            </summary>
            <param name="dpiScaleX">The DPI scale on the X axis.</param>
            <param name="dpiScaleY">The DPI scale on the Y axis.</param>
        </member>
        <member name="M:Wpf.Ui.Hardware.DisplayDpi.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Hardware.DisplayDpi"/> structure.
            </summary>
            <param name="dpiX">The DPI on the X axis.</param>
            <param name="dpiY">The DPI on the Y axis.</param>
        </member>
        <member name="P:Wpf.Ui.Hardware.DisplayDpi.DpiX">
            <summary>
            Gets the DPI on the X axis.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Hardware.DisplayDpi.DpiY">
            <summary>
            Gets the DPI on the Y axis.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Hardware.DisplayDpi.DpiScaleX">
            <summary>
            Gets the DPI scale on the X axis.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Hardware.DisplayDpi.DpiScaleY">
            <summary>
            Gets the DPI scale on the Y axis.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Hardware.DpiHelper">
            <summary>
            Provides access to various DPI-related methods.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Hardware.DpiHelper.DefaultDpi">
            <summary>
            Default DPI value.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Hardware.DpiHelper.GetWindowDpi(System.Windows.Window)">
            <summary>
            Gets DPI of the selected <see cref="T:System.Windows.Window"/>.
            </summary>
            <param name="window">The window that you want to get information about.</param>
        </member>
        <member name="M:Wpf.Ui.Hardware.DpiHelper.GetWindowDpi(System.IntPtr)">
            <summary>
            Gets DPI of the selected <see cref="T:System.Windows.Window"/> based on it's handle.
            </summary>
            <param name="windowHandle">Handle of the window that you want to get information about.</param>
        </member>
        <member name="M:Wpf.Ui.Hardware.DpiHelper.GetSystemDpi">
            <summary>
            Gets the DPI values from <see cref="T:System.Windows.SystemParameters"/>.
            </summary>
            <returns>The DPI values from <see cref="T:System.Windows.SystemParameters"/>. If the property cannot be accessed, the default value <see langword="96"/> is returned.</returns>
        </member>
        <member name="M:Wpf.Ui.Hardware.DpiHelper.LogicalPixelsToDevice(System.Windows.Point,System.Double,System.Double)">
            <summary>
            Convert a point in device independent pixels (1/96") to a point in the system coordinates.
            </summary>
            <param name="logicalPoint">A point in the logical coordinate system.</param>
            <param name="dpiScaleX">Horizontal DPI scale.</param>
            <param name="dpiScaleY">Vertical DPI scale.</param>
            <returns>Returns the parameter converted to the system's coordinates.</returns>
        </member>
        <member name="M:Wpf.Ui.Hardware.DpiHelper.DevicePixelsToLogical(System.Windows.Point,System.Double,System.Double)">
            <summary>
            Convert a point in system coordinates to a point in device independent pixels (1/96").
            </summary>
            <returns>Returns the parameter converted to the device independent coordinate system.</returns>
        </member>
        <member name="T:Wpf.Ui.Hardware.HardwareAcceleration">
            <summary>
            Set of tools for hardware acceleration.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Hardware.HardwareAcceleration.IsSupported(Wpf.Ui.Hardware.RenderingTier)">
            <summary>
            Determines whether the provided rendering tier is supported.
            </summary>
            <param name="tier">Hardware acceleration rendering tier to check.</param>
            <returns><see langword="true"/> if tier is supported.</returns>
        </member>
        <member name="T:Wpf.Ui.Hardware.RenderingTier">
            <summary>
            An <see cref="T:System.Int32"/> value whose high-order word corresponds to the rendering tier for the current thread.
            <para>Starting in the .NET Framework 4, rendering tier 1 has been redefined to only include graphics hardware that supports DirectX 9.0 or greater. Graphics hardware that supports DirectX 7 or 8 is now defined as rendering tier 0.</para>
            </summary>
        </member>
        <member name="F:Wpf.Ui.Hardware.RenderingTier.NoAcceleration">
            <summary>
            No graphics hardware acceleration is available for the application on the device.
            All graphics features use software acceleration. The DirectX version level is less than version 9.0.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Hardware.RenderingTier.PartialAcceleration">
            <summary>
            Most of the graphics features of WPF will use hardware acceleration
            if the necessary system resources are available and have not been exhausted.
            This corresponds to a DirectX version that is greater than or equal to 9.0.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Hardware.RenderingTier.FullAcceleration">
            <summary>
            Most of the graphics features of WPF will use hardware acceleration provided the
            necessary system resources have not been exhausted.
            This corresponds to a DirectX version that is greater than or equal to 9.0.
            </summary>
        </member>
        <member name="T:Wpf.Ui.IContentDialogService">
             <summary>
             Represents a contract with the service that creates <see cref="T:Wpf.Ui.Controls.ContentDialog"/>.
             </summary>
             <example>
             <code lang="xml">
             &lt;ContentPresenter x:Name="RootContentDialogPresenter" Grid.Row="0" /&gt;
             </code>
             <code lang="csharp">
             IContentDialogService contentDialogService = new ContentDialogService();
             contentDialogService.SetContentPresenter(RootContentDialogPresenter);
            
             await _contentDialogService.ShowAsync(
                 new ContentDialog(){
                     Title = "The cake?",
                     Content = "IS A LIE!",
                     PrimaryButtonText = "Save",
                     SecondaryButtonText = "Don't Save",
                     CloseButtonText = "Cancel"
                 }
             );
             </code>
             </example>
        </member>
        <member name="M:Wpf.Ui.IContentDialogService.SetDialogHost(System.Windows.Controls.ContentPresenter)">
            <summary>
            Sets the <see cref="T:System.Windows.Controls.ContentPresenter"/>
            </summary>
            <param name="dialogHost"><see cref="T:System.Windows.Controls.ContentPresenter"/> inside of which the dialogue will be placed. The new <see cref="T:Wpf.Ui.Controls.ContentDialog"/> will replace the current <see cref="P:System.Windows.Controls.ContentPresenter.Content"/>.</param>
        </member>
        <member name="M:Wpf.Ui.IContentDialogService.GetDialogHost">
            <summary>
            Provides direct access to the <see cref="T:System.Windows.Controls.ContentPresenter"/>
            </summary>
            <returns>Reference to the currently selected <see cref="T:System.Windows.Controls.ContentPresenter"/> which displays the <see cref="T:Wpf.Ui.Controls.ContentDialog"/>'s.</returns>
        </member>
        <member name="M:Wpf.Ui.IContentDialogService.ShowAsync(Wpf.Ui.Controls.ContentDialog,System.Threading.CancellationToken)">
            <summary>
            Asynchronously shows the specified dialog.
            </summary>
            <param name="dialog">The dialog to be displayed.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the operation.</param>
            <returns>A task that represents the asynchronous operation. The task result contains the dialog result.</returns>
        </member>
        <member name="T:Wpf.Ui.INavigationService">
            <summary>
            Represents a contract with a <see cref="T:System.Windows.FrameworkElement"/> that contains <see cref="T:Wpf.Ui.Controls.INavigationView"/>.
            Through defined <see cref="T:Wpf.Ui.Abstractions.INavigationViewPageProvider"/> service allows you to use the Dependency Injection pattern in <c>WPF UI</c> navigation.
            </summary>
        </member>
        <member name="M:Wpf.Ui.INavigationService.Navigate(System.Type)">
            <summary>
            Lets you navigate to the selected page based on it's type. Should be used with <see cref="T:Wpf.Ui.Abstractions.INavigationViewPageProvider"/>.
            </summary>
            <param name="pageType"><see langword="Type"/> of the page.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationService.Navigate(System.Type,System.Object)">
            <summary>
            Lets you navigate to the selected page based on it's type, Should be used with <see cref="T:Wpf.Ui.Abstractions.INavigationViewPageProvider"/>.
            </summary>
            <param name="pageType"><see langword="Type"/> of the page.</param>
            <param name="dataContext">DataContext <see cref="T:System.Object"/></param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationService.Navigate(System.String)">
            <summary>
            Lets you navigate to the selected page based on it's tag. Should be used with <see cref="T:Wpf.Ui.Abstractions.INavigationViewPageProvider"/>.
            </summary>
            <param name="pageIdOrTargetTag">Id or tag of the page.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationService.Navigate(System.String,System.Object)">
            <summary>
            Lets you navigate to the selected page based on it's tag. Should be used with <see cref="T:Wpf.Ui.Abstractions.INavigationViewPageProvider"/>.
            </summary>
            <param name="pageIdOrTargetTag">Id or tag of the page.</param>
            <param name="dataContext">DataContext <see cref="T:System.Object"/></param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationService.NavigateWithHierarchy(System.Type)">
            <summary>
            Synchronously adds an element to the navigation stack and navigates current navigation Frame to the
            </summary>
            <param name="pageType">Type of control to be synchronously added to the navigation stack</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationService.NavigateWithHierarchy(System.Type,System.Object)">
            <summary>
            Synchronously adds an element to the navigation stack and navigates current navigation Frame to the
            </summary>
            <param name="pageType">Type of control to be synchronously added to the navigation stack</param>
            <param name="dataContext">DataContext <see cref="T:System.Object"/></param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationService.GetNavigationControl">
            <summary>
            Provides direct access to the control responsible for navigation.
            </summary>
            <returns>Instance of the <see cref="T:Wpf.Ui.Controls.INavigationView"/> control.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationService.SetNavigationControl(Wpf.Ui.Controls.INavigationView)">
            <summary>
            Lets you attach the control that represents the <see cref="T:Wpf.Ui.Controls.INavigationView"/>.
            </summary>
            <param name="navigation">Instance of the <see cref="T:Wpf.Ui.Controls.INavigationView"/>.</param>
        </member>
        <member name="M:Wpf.Ui.INavigationService.GoBack">
            <summary>
            Navigates the NavigationView to the previous journal entry.
            </summary>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:Wpf.Ui.INavigationWindow">
            <summary>
            Represents a contract with a <see cref="T:System.Windows.Window"/> that contains <see cref="T:Wpf.Ui.Controls.INavigationView"/>.
            Through defined <see cref="T:Wpf.Ui.Abstractions.INavigationViewPageProvider"/> service allows you to use the MVVM model in <c>WPF UI</c> navigation.
            </summary>
        </member>
        <member name="M:Wpf.Ui.INavigationWindow.GetNavigation">
            <summary>
            Provides direct access to the control responsible for navigation.
            </summary>
            <returns>Instance of the <see cref="T:Wpf.Ui.Controls.INavigationView"/> control.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationWindow.Navigate(System.Type)">
            <summary>
            Lets you navigate to the selected page based on it's type. Should be used with <see cref="T:Wpf.Ui.Abstractions.INavigationViewPageProvider"/>.
            </summary>
            <param name="pageType"><see langword="Type"/> of the page.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.INavigationWindow.SetServiceProvider(System.IServiceProvider)">
            <summary>
            Lets you attach the service provider that delivers page instances to <see cref="T:Wpf.Ui.Controls.INavigationView"/>.
            </summary>
            <param name="serviceProvider">Instance of the <see cref="T:System.IServiceProvider"/>.</param>
        </member>
        <member name="M:Wpf.Ui.INavigationWindow.SetPageService(Wpf.Ui.Abstractions.INavigationViewPageProvider)">
            <summary>
            Lets you attach the service that delivers page instances to <see cref="T:Wpf.Ui.Controls.INavigationView"/>.
            </summary>
            <param name="navigationViewPageProvider">Instance of the <see cref="T:Wpf.Ui.Abstractions.INavigationViewPageProvider"/> with attached service provider.</param>
        </member>
        <member name="M:Wpf.Ui.INavigationWindow.ShowWindow">
            <summary>
            Triggers the command to open a window.
            </summary>
        </member>
        <member name="M:Wpf.Ui.INavigationWindow.CloseWindow">
            <summary>
            Triggers the command to close a window.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Input.IRelayCommand">
            <summary>
            An interface expanding <see cref="T:System.Windows.Input.ICommand"/> with the ability to raise
            the <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged"/> event externally.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Input.IRelayCommand.NotifyCanExecuteChanged">
            <summary>
            Notifies that the <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)"/> property has changed.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Input.IRelayCommand`1">
            <summary>
            A generic interface representing a more specific version of <see cref="T:Wpf.Ui.Input.IRelayCommand"/>.
            </summary>
            <typeparam name="T">The type used as argument for the interface methods.</typeparam>
        </member>
        <member name="M:Wpf.Ui.Input.IRelayCommand`1.CanExecute(`0)">
            <summary>
            Provides a strongly-typed variant of <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)"/>.
            </summary>
            <param name="parameter">The input parameter.</param>
            <returns>Whether or not the current command can be executed.</returns>
            <remarks>Use this overload to avoid boxing, if <typeparamref name="T"/> is a value type.</remarks>
        </member>
        <member name="M:Wpf.Ui.Input.IRelayCommand`1.Execute(`0)">
            <summary>
            Provides a strongly-typed variant of <see cref="M:System.Windows.Input.ICommand.Execute(System.Object)"/>.
            </summary>
            <param name="parameter">The input parameter.</param>
            <remarks>Use this overload to avoid boxing, if <typeparamref name="T"/> is a value type.</remarks>
        </member>
        <member name="T:Wpf.Ui.Input.RelayCommand`1">
            <summary>
            A generic command whose sole purpose is to relay its functionality to other
            objects by invoking delegates. The default return value for the CanExecute
            method is <see langword="true"/>. This class allows you to accept command parameters
            in the <see cref="M:Wpf.Ui.Input.RelayCommand`1.Execute(`0)"/> and <see cref="M:Wpf.Ui.Input.RelayCommand`1.CanExecute(`0)"/> callback methods.
            </summary>
            <typeparam name="T">The type of parameter being passed as input to the callbacks.</typeparam>
        </member>
        <member name="F:Wpf.Ui.Input.RelayCommand`1._execute">
            <summary>
            The <see cref="T:System.Action"/> to invoke when <see cref="M:Wpf.Ui.Input.RelayCommand`1.Execute(`0)"/> is used.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Input.RelayCommand`1._canExecute">
            <summary>
            The optional action to invoke when <see cref="M:Wpf.Ui.Input.RelayCommand`1.CanExecute(`0)"/> is used.
            </summary>
        </member>
        <member name="E:Wpf.Ui.Input.RelayCommand`1.CanExecuteChanged">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.#ctor(System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Input.RelayCommand`1"/> class that can always execute.
            </summary>
            <param name="execute">The execution logic.</param>
            <remarks>
            Due to the fact that the <see cref="T:System.Windows.Input.ICommand"/> interface exposes methods that accept a
            nullable <see cref="T:System.Object"/> parameter, it is recommended that if <typeparamref name="T"/> is a reference type,
            you should always declare it as nullable, and to always perform checks within <paramref name="execute"/>.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="execute"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.#ctor(System.Action{`0},System.Predicate{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Input.RelayCommand`1"/> class.
            </summary>
            <param name="execute">The execution logic.</param>
            <param name="canExecute">The execution status logic.</param>
            <remarks>
            Due to the fact that the <see cref="T:System.Windows.Input.ICommand"/> interface exposes methods that accept a
            nullable <see cref="T:System.Object"/> parameter, it is recommended that if <typeparamref name="T"/> is a reference type,
            you should always declare it as nullable, and to always perform checks within <paramref name="execute"/>.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="execute"/> or <paramref name="canExecute"/> are <see langword="null"/>.</exception>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.NotifyCanExecuteChanged">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.CanExecute(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.CanExecute(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.Execute(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.Execute(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.TryGetCommandArgument(System.Object,`0@)">
            <summary>
            Tries to get a command argument of compatible type <typeparamref name="T"/> from an input <see cref="T:System.Object"/>.
            </summary>
            <param name="parameter">The input parameter.</param>
            <param name="result">The resulting <typeparamref name="T"/> value, if any.</param>
            <returns>Whether or not a compatible command argument could be retrieved.</returns>
        </member>
        <member name="M:Wpf.Ui.Input.RelayCommand`1.ThrowArgumentExceptionForInvalidCommandArgument(System.Object)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if an invalid command argument is used.
            </summary>
            <param name="parameter">The input parameter.</param>
            <exception cref="T:System.ArgumentException">Thrown with an error message to give info on the invalid parameter.</exception>
        </member>
        <member name="T:Wpf.Ui.Interop.UnsafeNativeMethods">
            <summary>
            A set of dangerous methods to modify the appearance.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.ApplyWindowCornerPreference(System.IntPtr,Wpf.Ui.Controls.WindowCornerPreference)">
            <summary>
            Tries to set the corner preference of the selected window.
            </summary>
            <param name="handle">Selected window handle.</param>
            <param name="cornerPreference">Window corner preference.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.ApplyBorderColor(System.Windows.Window,System.Windows.Media.Color)">
            <summary>
            Tries to apply the color of the border.
            </summary>
            <param name="window">The window.</param>
            <param name="color">The color.</param>
            <returns><see langword="true" /> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.ApplyBorderColor(System.Windows.Window,System.Int32)">
            <summary>
            Tries to apply the color of the border.
            </summary>
            <param name="window">The window.</param>
            <param name="color">The color.</param>
            <returns><see langword="true" /> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.ApplyBorderColor(System.IntPtr,System.Windows.Media.Color)">
            <summary>
            Tries to apply the color of the border.
            </summary>
            <param name="handle">The handle.</param>
            <param name="color">The color.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.ApplyBorderColor(System.IntPtr,System.Int32)">
            <summary>
            Tries to apply the color of the border.
            </summary>
            <param name="handle">The handle.</param>
            <param name="color">The color.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.IsAccentColorOnTitleBarsEnabled">
            <summary>
            Checks whether accent color on title bars and window borders is enabled in Windows settings.
            </summary>
            <returns><see langword="true"/> if accent color on title bars is enabled.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.RemoveWindowDarkMode(System.Windows.Window)">
            <summary>
            Tries to remove ImmersiveDarkMode effect from the <see cref="T:System.Windows.Window"/>.
            </summary>
            <param name="window">The window to which the effect is to be applied.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.RemoveWindowDarkMode(System.IntPtr)">
            <summary>
            Tries to remove ImmersiveDarkMode effect from the window handle.
            </summary>
            <param name="handle">Window handle.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.ApplyWindowDarkMode(System.Windows.Window)">
            <summary>
            Tries to apply ImmersiveDarkMode effect for the <see cref="T:System.Windows.Window"/>.
            </summary>
            <param name="window">The window to which the effect is to be applied.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.ApplyWindowDarkMode(System.IntPtr)">
            <summary>
            Tries to apply ImmersiveDarkMode effect for the window handle.
            </summary>
            <param name="handle">Window handle.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.RemoveWindowTitlebarContents(System.Windows.Window)">
            <summary>
            Tries to remove titlebar from selected <see cref="T:System.Windows.Window"/>.
            </summary>
            <param name="window">The window to which the effect is to be applied.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.RemoveWindowTitlebarContents(System.IntPtr)">
            <summary>
            Tries to remove titlebar from selected window handle.
            </summary>
            <param name="handle">Window handle.</param>
            <returns><see langword="true"/> if invocation of native Windows function succeeds.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.GetAccentColor">
            <summary>
            Tries to get currently selected Window accent color.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.SetTaskbarState(System.IntPtr,Windows.Win32.UI.Shell.TBPFLAG)">
            <summary>
            Tries to set taskbar state for the selected window handle.
            </summary>
            <param name="hWnd">Window handle.</param>
            <param name="taskbarFlag">Taskbar flag.</param>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.SetTaskbarValue(System.IntPtr,Windows.Win32.UI.Shell.TBPFLAG,System.Int32,System.Int32)">
            <summary>
            Updates the taskbar progress bar value for a window.
            </summary>
            <param name="hWnd">The handle to the window.</param>
            <param name="taskbarFlag">Progress state flag (paused, etc).</param>
            <param name="current">Current progress value.</param>
            <param name="total">Maximum progress value.</param>
            <returns>True if successful updated, otherwise false.</returns>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.IsValidWindow(System.IntPtr)">
            <summary>
            Checks if provided pointer represents existing window.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeNativeMethods.GetHandle(System.Windows.Window,System.IntPtr@)">
            <summary>
            Tries to get the pointer to the window handle.
            </summary>
            <returns><see langword="true"/> if the handle is not <see cref="F:System.IntPtr.Zero"/>.</returns>
        </member>
        <member name="T:Wpf.Ui.Interop.UnsafeReflection">
            <summary>
            A set of dangerous methods to modify the appearance.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeReflection.Cast(Wpf.Ui.Controls.WindowCornerPreference)">
            <summary>
            Casts <see cref="T:Wpf.Ui.Controls.WindowCornerPreference" /> to <see cref="T:Windows.Win32.Graphics.Dwm.DWM_WINDOW_CORNER_PREFERENCE" />.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Interop.UnsafeReflection.Cast(Wpf.Ui.TaskBar.TaskBarProgressState)">
            <summary>
            Casts <see cref="T:Wpf.Ui.TaskBar.TaskBarProgressState" /> to <see cref="T:Windows.Win32.UI.Shell.TBPFLAG" />.
            </summary>
        </member>
        <member name="T:Wpf.Ui.ISnackbarService">
            <summary>
            Represents a contract with the service that provides global <see cref="T:Wpf.Ui.Controls.Snackbar"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.ISnackbarService.DefaultTimeOut">
            <summary>
            Gets or sets a time for which the <see cref="T:Wpf.Ui.Controls.Snackbar"/> should be visible. (By default 2 seconds)
            </summary>
        </member>
        <member name="M:Wpf.Ui.ISnackbarService.SetSnackbarPresenter(Wpf.Ui.Controls.SnackbarPresenter)">
            <summary>
            Sets the <see cref="T:Wpf.Ui.Controls.SnackbarPresenter"/>
            </summary>
            <param name="contentPresenter"><see cref="T:System.Windows.Controls.ContentPresenter"/> inside of which the snackbar will be placed. The new <see cref="T:Wpf.Ui.Controls.Snackbar"/> will replace the current <see cref="P:System.Windows.Controls.ContentPresenter.Content"/>.</param>
        </member>
        <member name="M:Wpf.Ui.ISnackbarService.GetSnackbarPresenter">
            <summary>
            Provides direct access to the <see cref="T:System.Windows.Controls.ContentPresenter"/>
            </summary>
            <returns><see cref="T:Wpf.Ui.Controls.Snackbar"/> currently in use.</returns>
        </member>
        <member name="M:Wpf.Ui.ISnackbarService.Show(System.String,System.String,Wpf.Ui.Controls.ControlAppearance,Wpf.Ui.Controls.IconElement,System.TimeSpan)">
            <summary>
            Shows the snackbar. If it is already visible, firstly hides it for a moment, changes its content, and then shows it again.
            </summary>
            <param name="title">Name displayed on top of snackbar.</param>
            <param name="message">Message inside the snackbar.</param>
            <param name="appearance">Display style.</param>
            <param name="icon">Additional icon on the left.</param>
            <param name="timeout">The time after which the snackbar should disappear.</param>
        </member>
        <member name="T:Wpf.Ui.ITaskBarService">
            <summary>
            Represents a contract with a service that provides methods for manipulating the taskbar.
            </summary>
        </member>
        <member name="M:Wpf.Ui.ITaskBarService.GetState(System.IntPtr)">
            <summary>
            Gets taskbar state of the selected window handle.
            </summary>
            <param name="hWnd">Window handle.</param>
            <returns>The current state of system TaskBar.</returns>
        </member>
        <member name="M:Wpf.Ui.ITaskBarService.GetState(System.Windows.Window)">
            <summary>
            Gets taskbar state of the selected window.
            </summary>
            <param name="window">Selected window.</param>
            <returns>The current state of system TaskBar.</returns>
        </member>
        <member name="M:Wpf.Ui.ITaskBarService.SetState(System.IntPtr,Wpf.Ui.TaskBar.TaskBarProgressState)">
            <summary>
            Sets taskbar state of the selected window handle.
            </summary>
            <param name="hWnd">Window handle to modify.</param>
            <param name="taskBarProgressState">Progress sate to set.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.ITaskBarService.SetValue(System.IntPtr,Wpf.Ui.TaskBar.TaskBarProgressState,System.Int32,System.Int32)">
            <summary>
            Sets taskbar value of the selected window handle.
            </summary>
            <param name="hWnd">Window handle to modify.</param>
            <param name="taskBarProgressState">Progress sate to set.</param>
            <param name="current">Current value to display.</param>
            <param name="total">Maximum number for division.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.ITaskBarService.SetValue(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sets taskbar value of the selected window handle.
            </summary>
            <param name="hWnd">Window handle to modify.</param>
            <param name="current">Current value to display.</param>
            <param name="max">Maximum number for division.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.ITaskBarService.SetState(System.Windows.Window,Wpf.Ui.TaskBar.TaskBarProgressState)">
            <summary>
            Sets taskbar state of the selected window.
            </summary>
            <param name="window">Window to modify.</param>
            <param name="taskBarProgressState">Progress sate to set.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.ITaskBarService.SetValue(System.Windows.Window,Wpf.Ui.TaskBar.TaskBarProgressState,System.Int32,System.Int32)">
            <summary>
            Sets taskbar value of the selected window.
            </summary>
            <param name="window">Window to modify.</param>
            <param name="taskBarProgressState">Progress sate to set.</param>
            <param name="current">Current value to display.</param>
            <param name="total">Maximum number for division.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.ITaskBarService.SetValue(System.Windows.Window,System.Int32,System.Int32)">
            <summary>
            Sets taskbar value of the selected window.
            </summary>
            <param name="window">Window to modify.</param>
            <param name="current">Current value to display.</param>
            <param name="total">Maximum number for division.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:Wpf.Ui.IThemeService">
            <summary>
            Represents a contract with a service that provides tools for manipulating the theme.
            </summary>
        </member>
        <member name="M:Wpf.Ui.IThemeService.GetTheme">
            <summary>
            Gets current application theme.
            </summary>
            <returns>Currently set application theme.</returns>
        </member>
        <member name="M:Wpf.Ui.IThemeService.GetSystemTheme">
            <summary>
            Gets current system theme.
            </summary>
            <returns>Currently set Windows theme.</returns>
        </member>
        <member name="M:Wpf.Ui.IThemeService.GetNativeSystemTheme">
            <summary>
            Gets current system theme.
            </summary>
            <returns>Currently set Windows theme using system enumeration.</returns>
        </member>
        <member name="M:Wpf.Ui.IThemeService.SetTheme(Wpf.Ui.Appearance.ApplicationTheme)">
            <summary>
            Sets current application theme.
            </summary>
            <param name="applicationTheme">Theme type to set.</param>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.IThemeService.SetSystemAccent">
            <summary>
            Sets currently used Windows OS accent.
            </summary>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.IThemeService.SetAccent(System.Windows.Media.Color)">
            <summary>
            Sets current application accent.
            </summary>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Wpf.Ui.IThemeService.SetAccent(System.Windows.Media.SolidColorBrush)">
            <summary>
            Sets current application accent.
            </summary>
            <returns><see langword="true"/> if the operation succeeds. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:Wpf.Ui.Markup.ControlsDictionary">
            <summary>
            Provides a dictionary implementation that contains <c>WPF UI</c> controls resources used by components and other elements of a WPFapplication.
            </summary>
            <example>
            <code lang="xml">
            &lt;Application
                xmlns:ui="http://schemas.lepo.co/wpfui/2022/xaml"&gt;
                &lt;Application.Resources&gt;
                    &lt;ResourceDictionary&gt;
                        &lt;ResourceDictionary.MergedDictionaries&gt;
                            &lt;ui:ControlsDictionary /&gt;
                        &lt;/ResourceDictionary.MergedDictionaries&gt;
                    &lt;/ResourceDictionary&gt;
                &lt;/Application.Resources&gt;
            &lt;/Application&gt;
            </code>
            </example>
        </member>
        <member name="M:Wpf.Ui.Markup.ControlsDictionary.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Markup.ControlsDictionary"/> class.
            Default constructor defining <see cref="P:System.Windows.ResourceDictionary.Source"/> of the <c>WPF UI</c> controls dictionary.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Markup.Design">
            <summary>
            Custom design time attributes based on Marcin Najder implementation.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:FluentWindow
                xmlns:ui="http://schemas.lepo.co/wpfui/2022/xaml"
                ui:Design.Background="{DynamicResource ApplicationBackgroundBrush}"
                ui:Design.Foreground="{DynamicResource TextFillColorPrimaryBrush}"&gt;
                &lt;Button Content="Hello World" /&gt;
            &lt;/FluentWindow&gt;
            </code>
            </example>
        </member>
        <member name="P:Wpf.Ui.Markup.Design.InDesignMode">
            <summary>
            Gets a value indicating whether the framework is in design-time mode. (Caliburn.Micro implementation)
            </summary>
        </member>
        <member name="M:Wpf.Ui.Markup.Design.GetBackground(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Wpf.Ui.Markup.Design.BackgroundProperty"/> from <paramref name="dependencyObject"/>.</summary>
            <param name="dependencyObject"><see cref="T:System.Windows.DependencyObject"/> to read <see cref="F:Wpf.Ui.Markup.Design.BackgroundProperty"/> from.</param>
            <returns>Background property value.</returns>
        </member>
        <member name="M:Wpf.Ui.Markup.Design.SetBackground(System.Windows.DependencyObject,System.Windows.Media.Brush)">
            <summary>Helper for setting <see cref="F:Wpf.Ui.Markup.Design.BackgroundProperty"/> on <paramref name="dependencyObject"/>.</summary>
            <param name="dependencyObject"><see cref="T:System.Windows.DependencyObject"/> to set <see cref="F:Wpf.Ui.Markup.Design.BackgroundProperty"/> on.</param>
            <param name="value">Background property value.</param>
        </member>
        <member name="M:Wpf.Ui.Markup.Design.GetForeground(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Wpf.Ui.Markup.Design.ForegroundProperty"/> from <paramref name="dependencyObject"/>.</summary>
            <param name="dependencyObject"><see cref="T:System.Windows.DependencyObject"/> to read <see cref="F:Wpf.Ui.Markup.Design.ForegroundProperty"/> from.</param>
            <returns>Foreground property value.</returns>
        </member>
        <member name="M:Wpf.Ui.Markup.Design.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)">
            <summary>Helper for setting <see cref="F:Wpf.Ui.Markup.Design.ForegroundProperty"/> on <paramref name="dependencyObject"/>.</summary>
            <param name="dependencyObject"><see cref="T:System.Windows.DependencyObject"/> to set <see cref="F:Wpf.Ui.Markup.Design.ForegroundProperty"/> on.</param>
            <param name="value">Foreground property value.</param>
        </member>
        <member name="T:Wpf.Ui.Markup.FontIconExtension">
            <summary>
            Custom <see cref="T:System.Windows.Markup.MarkupExtension"/> which can provide <see cref="T:Wpf.Ui.Controls.FontIcon"/>.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:Button
                Appearance="Primary"
                Content="WPF UI button with font icon"
                Icon="{ui:FontIcon '&#x1F308;'}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:Button Icon="{ui:FontIcon '&amp;#x1F308;'}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:HyperlinkButton Icon="{ui:FontIcon '&amp;#x1F308;'}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:TitleBar Icon="{ui:FontIcon '&amp;#x1F308;'}" /&gt;
            </code>
            </example>
        </member>
        <member name="T:Wpf.Ui.Markup.ImageIconExtension">
            <summary>
            Custom <see cref="T:System.Windows.Markup.MarkupExtension"/> which can provide <see cref="T:Wpf.Ui.Controls.ImageIcon"/>.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:Button
                Appearance="Primary"
                Content="WPF UI button with font icon"
                Icon="{ui:ImageIcon '/my-icon.png'}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:Button Icon="{ui:ImageIcon 'pack://application:,,,/Assets/wpfui.png'}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:HyperlinkButton Icon="{ui:ImageIcon 'pack://application:,,,/Assets/wpfui.png'}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:TitleBar Icon="{ui:ImageIcon 'pack://application:,,,/Assets/wpfui.png'}" /&gt;
            </code>
            </example>
        </member>
        <member name="T:Wpf.Ui.Markup.SymbolIconExtension">
            <summary>
            Custom <see cref="T:System.Windows.Markup.MarkupExtension"/> which can provide <see cref="T:Wpf.Ui.Controls.SymbolIcon"/>.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:Button
                Appearance="Primary"
                Content="WPF UI button with font icon"
                Icon="{ui:SymbolIcon Symbol=Fluent24}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:Button Icon="{ui:SymbolIcon Fluent24}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:HyperlinkButton Icon="{ui:SymbolIcon Fluent24}" /&gt;
            </code>
            <code lang="xml">
            &lt;ui:TitleBar Icon="{ui:SymbolIcon Fluent24}" /&gt;
            </code>
            </example>
        </member>
        <member name="T:Wpf.Ui.Markup.ThemeResource">
            <summary>
            Collection of theme resources.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:TextBox Foreground={ui:ThemeResource TextFillColorSecondaryBrush} /&gt;
            </code>
            </example>
        </member>
        <member name="F:Wpf.Ui.Markup.ThemeResource.Unknown">
            <summary>
            Unspecified theme resource.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Markup.ThemeResource.ControlElevationBorderBrush">
            <summary>
            Gradient <see cref="T:System.Windows.Media.Brush"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Markup.ThemeResource.CircleElevationBorderBrush">
            <summary>
            Gradient <see cref="T:System.Windows.Media.Brush"/>.
            </summary>
        </member>
        <member name="F:Wpf.Ui.Markup.ThemeResource.AccentControlElevationBorderBrush">
            <summary>
            Gradient <see cref="T:System.Windows.Media.Brush"/>.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Markup.ThemeResourceExtension">
            <summary>
            Class for Xaml markup extension for static resource references.
            </summary>
            <example>
            <code lang="xml">
            &lt;ui:Button
                Appearance="Primary"
                Content="WPF UI button with font icon"
                Foreground={ui:ThemeResource SystemAccentColorPrimaryBrush} /&gt;
            </code>
            <code lang="xml">
            &lt;ui:TextBox Foreground={ui:ThemeResource TextFillColorSecondaryBrush} /&gt;
            </code>
            </example>
        </member>
        <member name="M:Wpf.Ui.Markup.ThemeResourceExtension.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Markup.ThemeResourceExtension"/> class.
            </summary>
        </member>
        <member name="M:Wpf.Ui.Markup.ThemeResourceExtension.#ctor(Wpf.Ui.Markup.ThemeResource)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.Markup.ThemeResourceExtension"/> class.
            Takes the resource key that this is a static reference to.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Markup.ThemesDictionary">
            <summary>
            Provides a dictionary implementation that contains <c>WPF UI</c> theme resources used by components and other elements of a WPFapplication.
            </summary>
            <example>
            <code lang="xml">
            &lt;Application
                xmlns:ui="http://schemas.lepo.co/wpfui/2022/xaml"&gt;
                &lt;Application.Resources&gt;
                    &lt;ResourceDictionary&gt;
                        &lt;ResourceDictionary.MergedDictionaries&gt;
                            &lt;ui:ThemesDictionary Theme = "Dark" /&gt;
                        &lt;/ResourceDictionary.MergedDictionaries&gt;
                    &lt;/ResourceDictionary&gt;
                &lt;/Application.Resources&gt;
            &lt;/Application&gt;
            </code>
            </example>
        </member>
        <member name="P:Wpf.Ui.Markup.ThemesDictionary.Theme">
            <summary>
            Sets the default application theme.
            </summary>
        </member>
        <member name="T:Wpf.Ui.NavigationService">
            <summary>
            A service that provides methods related to navigation.
            </summary>
        </member>
        <member name="M:Wpf.Ui.NavigationService.#ctor(Wpf.Ui.Abstractions.INavigationViewPageProvider)">
            <summary>
            A service that provides methods related to navigation.
            </summary>
        </member>
        <member name="P:Wpf.Ui.NavigationService.NavigationControl">
            <summary>
            Gets or sets the control representing navigation.
            </summary>
        </member>
        <member name="M:Wpf.Ui.NavigationService.GetNavigationControl">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.NavigationService.SetNavigationControl(Wpf.Ui.Controls.INavigationView)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.NavigationService.Navigate(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.NavigationService.Navigate(System.Type,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.NavigationService.Navigate(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.NavigationService.Navigate(System.String,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.NavigationService.GoBack">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.NavigationService.NavigateWithHierarchy(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.NavigationService.NavigateWithHierarchy(System.Type,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.SimpleContentDialogCreateOptions">
            <summary>
            Set of properties used when creating a new simple content dialog.
            </summary>
        </member>
        <member name="P:Wpf.Ui.SimpleContentDialogCreateOptions.Title">
            <summary>
            Gets or sets a name at the top of the content dialog.
            </summary>
        </member>
        <member name="P:Wpf.Ui.SimpleContentDialogCreateOptions.Content">
            <summary>
            Gets or sets a message displayed in the content dialog.
            </summary>
        </member>
        <member name="P:Wpf.Ui.SimpleContentDialogCreateOptions.CloseButtonText">
            <summary>
            Gets or sets the name of the button that closes the content dialog.
            </summary>
        </member>
        <member name="P:Wpf.Ui.SimpleContentDialogCreateOptions.PrimaryButtonText">
            <summary>
            Gets or sets the default text of the primary button at the bottom of the content dialog.
            <para>If not added, or <see cref="F:System.String.Empty"/>, it will not be displayed.</para>
            </summary>
        </member>
        <member name="P:Wpf.Ui.SimpleContentDialogCreateOptions.SecondaryButtonText">
            <summary>
            Gets or sets the default text of the secondary button at the bottom of the content dialog.
            <para>If not added, or <see cref="F:System.String.Empty"/>, it will not be displayed.</para>
            </summary>
        </member>
        <member name="T:Wpf.Ui.SnackbarService">
            <summary>
            A service that provides methods related to displaying the <see cref="T:Wpf.Ui.Controls.Snackbar"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.SnackbarService.DefaultTimeOut">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.SnackbarService.SetSnackbarPresenter(Wpf.Ui.Controls.SnackbarPresenter)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.SnackbarService.GetSnackbarPresenter">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.SnackbarService.Show(System.String,System.String,Wpf.Ui.Controls.ControlAppearance,Wpf.Ui.Controls.IconElement,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.TaskBarService">
            <summary>
            Allows you to manage the animations of the window icon in the taskbar.
            </summary>
        </member>
        <member name="M:Wpf.Ui.TaskBarService.GetState(System.IntPtr)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.TaskBarService.GetState(System.Windows.Window)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.TaskBarService.SetState(System.Windows.Window,Wpf.Ui.TaskBar.TaskBarProgressState)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.TaskBarService.SetValue(System.Windows.Window,Wpf.Ui.TaskBar.TaskBarProgressState,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.TaskBarService.SetValue(System.Windows.Window,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.TaskBarService.SetState(System.IntPtr,Wpf.Ui.TaskBar.TaskBarProgressState)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.TaskBarService.SetValue(System.IntPtr,Wpf.Ui.TaskBar.TaskBarProgressState,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Wpf.Ui.TaskBarService.SetValue(System.IntPtr,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.TaskBar.TaskBarProgress">
            <summary>
            Allows to change the status of the displayed notification in the application icon on the TaskBar.
            </summary>
        </member>
        <member name="M:Wpf.Ui.TaskBar.TaskBarProgress.IsSupported">
            <summary>
            Gets a value indicating whether the current operating system supports task bar manipulation.
            </summary>
        </member>
        <member name="M:Wpf.Ui.TaskBar.TaskBarProgress.SetState(System.Windows.Window,Wpf.Ui.TaskBar.TaskBarProgressState)">
            <summary>
            Allows to change the status of the progress bar in the task bar.
            </summary>
            <param name="window">Window to manipulate.</param>
            <param name="taskBarProgressState">State of the progress indicator.</param>
        </member>
        <member name="M:Wpf.Ui.TaskBar.TaskBarProgress.SetState(System.IntPtr,Wpf.Ui.TaskBar.TaskBarProgressState)">
            <summary>
            Allows to change the status of the progress bar in the task bar.
            </summary>
            <param name="hWnd">Window handle.</param>
            <param name="taskBarProgressState">State of the progress indicator.</param>
        </member>
        <member name="M:Wpf.Ui.TaskBar.TaskBarProgress.SetValue(System.Windows.Window,Wpf.Ui.TaskBar.TaskBarProgressState,System.Int32)">
            <summary>
            Allows to change the fill of the task bar.
            </summary>
            <param name="window">Window to manipulate.</param>
            <param name="taskBarProgressState">Progress sate to set.</param>
            <param name="current">Current value to display</param>
        </member>
        <member name="M:Wpf.Ui.TaskBar.TaskBarProgress.SetValue(System.Windows.Window,Wpf.Ui.TaskBar.TaskBarProgressState,System.Int32,System.Int32)">
            <summary>
            Allows to change the fill of the task bar.
            </summary>
            <param name="window">Window to manipulate.</param>
            <param name="taskBarProgressState">Progress sate to set.</param>
            <param name="current">Current value to display</param>
            <param name="total">Total number for division.</param>
        </member>
        <member name="M:Wpf.Ui.TaskBar.TaskBarProgress.SetValue(System.IntPtr,Wpf.Ui.TaskBar.TaskBarProgressState,System.Int32)">
            <summary>
            Allows to change the fill of the task bar.
            </summary>
            <param name="hWnd">Window handle.</param>
            <param name="taskBarProgressState">Progress sate to set.</param>
            <param name="current">Current value to display</param>
        </member>
        <member name="M:Wpf.Ui.TaskBar.TaskBarProgress.SetValue(System.IntPtr,Wpf.Ui.TaskBar.TaskBarProgressState,System.Int32,System.Int32)">
            <summary>
            Allows to change the fill of the task bar.
            </summary>
            <param name="hWnd">Window handle.</param>
            <param name="taskBarProgressState">Progress sate to set.</param>
            <param name="current">Current value to display</param>
            <param name="total">Total number for division.</param>
        </member>
        <member name="T:Wpf.Ui.TaskBar.TaskBarProgressState">
            <summary>
            Specifies the state of the progress indicator in the Windows task bar.
            <see href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.shell.taskbaritemprogressstate?view=windowsdesktop-5.0"/>
            </summary>
        </member>
        <member name="F:Wpf.Ui.TaskBar.TaskBarProgressState.None">
            <summary>
            No progress indicator is displayed in the task bar area.
            </summary>
        </member>
        <member name="F:Wpf.Ui.TaskBar.TaskBarProgressState.Indeterminate">
            <summary>
            A pulsing green (W10) or gray (W11) indicator is displayed in the task bar area.
            </summary>
        </member>
        <member name="F:Wpf.Ui.TaskBar.TaskBarProgressState.Normal">
            <summary>
            A green progress indicator is displayed in the task bar area.
            </summary>
        </member>
        <member name="F:Wpf.Ui.TaskBar.TaskBarProgressState.Error">
            <summary>
            A red progress indicator is displayed in the task bar area.
            </summary>
        </member>
        <member name="F:Wpf.Ui.TaskBar.TaskBarProgressState.Paused">
            <summary>
            A yellow progress indicator is displayed in the task bar area.
            </summary>
        </member>
        <member name="T:Wpf.Ui.ThemeService">
            <summary>
            Lets you set the app theme.
            </summary>
        </member>
        <member name="M:Wpf.Ui.ThemeService.GetTheme">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.ThemeService.GetNativeSystemTheme">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.ThemeService.GetSystemTheme">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.ThemeService.SetTheme(Wpf.Ui.Appearance.ApplicationTheme)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.ThemeService.SetSystemAccent">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.ThemeService.SetAccent(System.Windows.Media.Color)">
            <inheritdoc />
        </member>
        <member name="M:Wpf.Ui.ThemeService.SetAccent(System.Windows.Media.SolidColorBrush)">
            <inheritdoc />
        </member>
        <member name="T:Wpf.Ui.UiApplication">
            <summary>
            Represents a UI application.
            </summary>
        </member>
        <member name="M:Wpf.Ui.UiApplication.#ctor(System.Windows.Application)">
            <summary>
            Initializes a new instance of the <see cref="T:Wpf.Ui.UiApplication"/> class.
            </summary>
        </member>
        <member name="P:Wpf.Ui.UiApplication.IsApplication">
            <summary>
            Gets a value indicating whether the application is running outside of the desktop app context.
            </summary>
        </member>
        <member name="P:Wpf.Ui.UiApplication.Current">
            <summary>
            Gets the current application.
            </summary>
        </member>
        <member name="P:Wpf.Ui.UiApplication.MainWindow">
            <summary>
            Gets or sets the application's main window.
            </summary>
        </member>
        <member name="P:Wpf.Ui.UiApplication.Resources">
            <summary>
            Gets or sets the application's resources.
            </summary>
        </member>
        <member name="M:Wpf.Ui.UiApplication.TryFindResource(System.Object)">
            <summary>
            Gets or sets the application's main window.
            </summary>
        </member>
        <member name="M:Wpf.Ui.UiApplication.Shutdown">
            <summary>
            Turns the application's into shutdown mode.
            </summary>
        </member>
        <member name="T:Wpf.Ui.UiAssembly">
            <summary>
            Allows to get the WPF UI assembly through <see cref="P:Wpf.Ui.UiAssembly.Assembly"/>.
            </summary>
        </member>
        <member name="P:Wpf.Ui.UiAssembly.Assembly">
            <summary>
            Gets the WPF UI assembly.
            </summary>
        </member>
        <member name="T:Wpf.Ui.Win32.Utilities">
            <summary>
            Common Window utilities.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsNT">
            <summary>
            Gets a value indicating whether the operating system is NT or newer.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsOSVistaOrNewer">
            <summary>
            Gets a value indicating whether the operating system version is greater than or equal to 6.0.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsOSWindows7OrNewer">
            <summary>
            Gets a value indicating whether the operating system version is greater than or equal to 6.1.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsOSWindows8OrNewer">
            <summary>
            Gets a value indicating whether the operating system version is greater than or equal to 6.2.
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsOSWindows10OrNewer">
            <summary>
            Gets a value indicating whether the operating system version is greater than or equal to 10.0* (build 10240).
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsOSWindows11OrNewer">
            <summary>
            Gets a value indicating whether the operating system version is greater than or equal to 10.0* (build 22000).
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsOSWindows11Insider1OrNewer">
            <summary>
            Gets a value indicating whether the operating system version is greater than or equal to 10.0* (build 22523).
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsOSWindows11Insider2OrNewer">
            <summary>
            Gets a value indicating whether the operating system version is greater than or equal to 10.0* (build 22557).
            </summary>
        </member>
        <member name="P:Wpf.Ui.Win32.Utilities.IsCompositionEnabled">
            <summary>
            Gets a value indicating whether Desktop Window Manager (DWM) composition is enabled.
            </summary>
        </member>
        <member name="T:Windows.Win32.PInvoke">
            <content>
            Contains extern methods from "COMCTL32.dll".
            </content>
            <content>
            Contains extern methods from "dwmapi.dll".
            </content>
            <content>
            Contains extern methods from "GDI32.dll".
            </content>
            <content>
            Contains extern methods from "KERNEL32.dll".
            </content>
            <content>
            Contains extern methods from "USER32.dll".
            </content>
            <content>
            Contains extern methods from "UXTHEME.dll".
            </content>
        </member>
        <member name="M:Windows.Win32.PInvoke.ImageList_Destroy(Windows.Win32.UI.Controls.HIMAGELIST)">
            <summary>Destroys an image list.</summary>
            <param name="himl">
            <para>Type: <b>HIMAGELIST</b> A handle to the image list to destroy.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-imagelist_destroy#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b> Returns nonzero if successful, or zero otherwise.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-imagelist_destroy">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DwmIsCompositionEnabled(Windows.Win32.Foundation.BOOL@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.DwmIsCompositionEnabled(Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.DwmIsCompositionEnabled(Windows.Win32.Foundation.BOOL*)">
            <summary>Obtains a value that indicates whether Desktop Window Manager (DWM) composition is enabled. Applications on machines running Windows7 or earlier can listen for composition state changes by handling the WM_DWMCOMPOSITIONCHANGED notification.</summary>
            <param name="pfEnabled">
            <para>A pointer to a value that, when this function returns successfully, receives <b>TRUE</b> if DWM composition is enabled; otherwise, <b>FALSE</b>.</para>
            <para><div class="alert"><b>Note</b>As of Windows8, DWM composition is always enabled. If an app declares Windows8 compatibility in their manifest, this function will receive a value of <b>TRUE</b> through <i>pfEnabled</i>. If no such manifest entry is found, Windows8 compatibility is not assumed and this function receives a value of <b>FALSE</b> through <i>pfEnabled</i>. This is done so that older programs that interpret a value of <b>TRUE</b> to imply that high contrast mode is off can continue to make the correct decisions about rendering their images. (Note that this is a bad practiceyou should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> function with the <b>SPI_GETHIGHCONTRAST</b> flag to determine the state of high contrast mode.)</div> <div></div> For more information, see <a href="https://docs.microsoft.com/windows/win32/controls/supporting-high-contrast-themes">Supporting High Contrast Themes</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/nf-dwmapi-dwmiscompositionenabled#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/nf-dwmapi-dwmiscompositionenabled">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DwmExtendFrameIntoClientArea(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.MARGINS@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.DwmExtendFrameIntoClientArea(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.MARGINS*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.DwmExtendFrameIntoClientArea(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.MARGINS*)">
            <summary>Extends the window frame into the client area.</summary>
            <param name="hWnd">The handle to the window in which the frame will be extended into the client area.</param>
            <param name="pMarInset">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/uxtheme/ns-uxtheme-margins">MARGINS</a> structure that describes the margins to use when extending the frame into the client area.</param>
            <returns>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</returns>
            <remarks>
            <para>This function must be called whenever Desktop Window Manager (DWM) composition is toggled. Handle the <a href="https://docs.microsoft.com/windows/desktop/dwm/wm-dwmcompositionchanged">WM_DWMCOMPOSITIONCHANGED</a> message for composition change notification. Use negative margin values to create the "sheet of glass" effect where the client area is rendered as a solid surface with no window border.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/nf-dwmapi-dwmextendframeintoclientarea#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DwmSetWindowAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE,System.ReadOnlySpan{System.Byte})">
            <inheritdoc cref="M:Windows.Win32.PInvoke.DwmSetWindowAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE,System.Void*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.DwmSetWindowAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE,System.Void*,System.UInt32)">
            <summary>Sets the value of Desktop Window Manager (DWM) non-client rendering attributes for a window.</summary>
            <param name="hwnd">The handle to the window for which the attribute value is to be set.</param>
            <param name="dwAttribute">A flag describing which value to set, specified as a value of the [DWMWINDOWATTRIBUTE](/windows/desktop/api/dwmapi/ne-dwmapi-dwmwindowattribute) enumeration. This parameter specifies which attribute to set, and the *pvAttribute* parameter points to an object containing the attribute value.</param>
            <param name="pvAttribute">A pointer to an object containing the attribute value to set. The type of the value set depends on the value of the *dwAttribute* parameter. The [**DWMWINDOWATTRIBUTE**](/windows/desktop/api/Dwmapi/ne-dwmapi-dwmwindowattribute) enumeration topic indicates, in the row for each flag, what type of value you should pass a pointer to in the *pvAttribute* parameter.</param>
            <param name="cbAttribute">The size, in bytes, of the attribute value being set via the *pvAttribute* parameter. The type of the value set, and therefore its size in bytes, depends on the value of the *dwAttribute* parameter.</param>
            <returns>
            <para>Type: **[HRESULT](/windows/desktop/com/structure-of-com-error-codes)** If the function succeeds, it returns **S_OK**. Otherwise, it returns an [**HRESULT**](/windows/desktop/com/structure-of-com-error-codes) [error code](/windows/desktop/com/com-error-codes-10). If Desktop Composition has been disabled (Windows7 and earlier), then this function returns **DWM_E_COMPOSITIONDISABLED**.</para>
            </returns>
            <remarks>It's not valid to call this function with the *dwAttribute* parameter set to **DWMWA_NCRENDERING_ENABLED**. To enable or disable non-client rendering, you should use the **DWMWA_NCRENDERING_POLICY** attribute, and set the desired value. For more info, and a code example, see [Controlling non-client region rendering](/windows/desktop/dwm/composition-ovw#controlling-non-client-region-rendering).</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DwmGetWindowAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE,System.Span{System.Byte})">
            <inheritdoc cref="M:Windows.Win32.PInvoke.DwmGetWindowAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE,System.Void*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.DwmGetWindowAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE,System.Void*,System.UInt32)">
            <summary>Retrieves the current value of a specified Desktop Window Manager (DWM) attribute applied to a window.</summary>
            <param name="hwnd">The handle to the window from which the attribute value is to be retrieved.</param>
            <param name="dwAttribute">A flag describing which value to retrieve, specified as a value of the [DWMWINDOWATTRIBUTE](/windows/desktop/api/dwmapi/ne-dwmapi-dwmwindowattribute) enumeration. This parameter specifies which attribute to retrieve, and the *pvAttribute* parameter points to an object into which the attribute value is retrieved.</param>
            <param name="pvAttribute">A pointer to a value which, when this function returns successfully, receives the current value of the attribute. The type of the retrieved value depends on the value of the *dwAttribute* parameter. The [**DWMWINDOWATTRIBUTE**](/windows/desktop/api/Dwmapi/ne-dwmapi-dwmwindowattribute) enumeration topic indicates, in the row for each flag, what type of value you should pass a pointer to in the *pvAttribute* parameter.</param>
            <param name="cbAttribute">The size, in bytes, of the attribute value being received via the *pvAttribute* parameter. The type of the retrieved value, and therefore its size in bytes, depends on the value of the *dwAttribute* parameter.</param>
            <returns>
            <para>Type: **[HRESULT](/windows/desktop/com/structure-of-com-error-codes)** If the function succeeds, it returns **S_OK**. Otherwise, it returns an [**HRESULT**](/windows/desktop/com/structure-of-com-error-codes) [error code](/windows/desktop/com/com-error-codes-10).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/nf-dwmapi-dwmgetwindowattribute">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_INITIATE">
            <summary>A Dynamic Data Exchange (DDE) client application sends a WM\_DDE\_INITIATE message to initiate a conversation with a server application responding to the specified application and topic names.</summary>
            <remarks>If the low-order word of *lParam* is **NULL**, any server application can respond. If the high-order word of *lParam* is **NULL**, any topic is valid. Upon receiving a **WM\_DDE\_INITIATE** request with the high-order word of the *lParam* parameter set to **NULL**, a server must send a [**WM\_DDE\_ACK**](wm-dde-ack.md) message for each of the topics it supports.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_TERMINATE">
            <summary>A Dynamic Data Exchange (DDE) application (client or server) posts a WM\_DDE\_TERMINATE message to terminate a conversation. To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_ADVISE">
            <summary>A Dynamic Data Exchange (DDE) client application posts the WM\_DDE\_ADVISE message to a DDE server application to request the server to supply an update for a data item whenever the item changes.</summary>
            <remarks>If a client application supports more than one clipboard format for a single topic and item, it can post multiple **WM\_DDE\_ADVISE** messages for the topic and item, specifying a different clipboard format with each message. Note that a server can support multiple formats only for hot data links, not warm data links.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_UNADVISE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_UNADVISE message to inform a DDE server application that the specified item or a particular clipboard format for the item should no longer be updated.</summary>
            <remarks>
            <para>The client application allocates the high-order word of *lParam* by calling the [**GlobalAddAtom**](/windows/desktop/api/Winbase/nf-winbase-globaladdatoma) function. The server application posts the [**WM\_DDE\_ACK**](wm-dde-ack.md) message to respond positively or negatively. When posting **WM\_DDE\_ACK**, the server can either reuse the atom, or it can delete the atom and create a new one.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-dde-unadvise#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_ACK">
            <summary>The WM\_DDE\_ACK message notifies a Dynamic Data Exchange (DDE) application of the receipt and processing of the following messages WM\_DDE\_POKE, WM\_DDE\_EXECUTE, WM\_DDE\_DATA, WM\_DDE\_ADVISE, WM\_DDE\_UNADVISE, WM\_DDE\_INITIATE, or WM\_DDE\_REQUEST (in some cases). To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_DATA">
            <summary>A Dynamic Data Exchange (DDE) server application posts a WM\_DDE\_DATA message to a DDE client application to pass a data item to the client or to notify the client of the availability of a data item.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_REQUEST">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_REQUEST message to a DDE server application to request the value of a data item. To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_POKE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_POKE message to a DDE server application.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_EXECUTE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_EXECUTE message to a DDE server application to send a string to the server to be processed as a series of commands.</summary>
            <remarks>
            <para>The command string is a null-terminated string consisting of one or more opcode strings enclosed in single brackets (\[ \]). Each opcode string has the following syntax, where the *parameters* list is optional: *opcode parameters* The *opcode* is any application-defined single token. It cannot include spaces, commas, parentheses, brackets, or quotation marks. The *parameters* list can contain any application-defined value or values. Multiple parameters are separated by commas, and the entire parameter list is enclosed in parentheses. Parameters cannot include commas or parentheses except inside a quoted string. If a bracket or parenthesis character is to appear in a quoted string, it need not be doubled, as was the case under the old rules. The following are valid command strings:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-dde-execute#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLOR">
            <summary>The WM\_CTLCOLOR message is used in 16-bit versions of Windows to change the color scheme of list boxes, the list boxes of combo boxes, message boxes, button controls, edit controls, static controls, and dialog boxes.NoteFor information related to this message and 32-bit versions of Windows, see Remarks.</summary>
            <returns>If an application processes this message, it returns a handle to a brush. The system uses the brush to paint the background of the control.</returns>
            <remarks>
            <para>The **WM\_CTLCOLOR** message from 16-bit Windows has been replaced by more specific notifications. These replacements include the following: -   [**WM\_CTLCOLORBTN**](../controls/wm-ctlcolorbtn.md) -   [**WM\_CTLCOLOREDIT**](../controls/wm-ctlcoloredit.md) -   [**WM\_CTLCOLORDLG**](../dlgbox/wm-ctlcolordlg.md) -   [**WM\_CTLCOLORLISTBOX**](../controls/wm-ctlcolorlistbox.md) -   [**WM\_CTLCOLORSCROLLBAR**](../controls/wm-ctlcolorscrollbar.md) -   [**WM\_CTLCOLORSTATIC**](../controls/wm-ctlcolorstatic.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/DevNotes/wm-ctlcolor-#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEHOVER">
            <summary>Posted to a window when the cursor hovers over the client area of the window for the period of time specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Hover tracking stops when **WM\_MOUSEHOVER** is generated. The application must call [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) again if it requires further tracking of mouse hover behavior. Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousehover#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSELEAVE">
            <summary>Posted to a window when the cursor leaves the client area of the window specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>All tracking requested by [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) is canceled when this message is generated. The application must call **TrackMouseEvent** when the mouse reenters its window if it requires further tracking of mouse hover behavior.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHOOSEFONT_GETLOGFONT">
            <summary>An application sends the WM\_CHOOSEFONT\_GETLOGFONT message to a Font dialog box to retrieve information about the user's current font selections.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function creates a **Font** dialog box. When the user closes the **Font** dialog box, the **ChooseFont** function returns information about the user's font selections in the [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure. The **lpLogFont** member of the **CHOOSEFONT** structure is a pointer to a [**LOGFONT**](/windows/win32/api/wingdi/ns-wingdi-logfonta) structure. Use the **WM\_CHOOSEFONT\_GETLOGFONT** message to get information about the user's current font selections while the **Font** dialog box is open. For example, if you enable the **Apply** button in the **Font** dialog box, send the message to get the font information to apply to the current text selection. Typically, you enable a [*CFHookProc*](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure to process [**WM\_COMMAND**](/windows/desktop/menurc/wm-command) messages for the **Apply** button. When the user clicks the **Apply** button, the hook procedure sends the **WM\_CHOOSEFONT\_GETLOGFONT** message to the dialog box.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-getlogfont#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHOOSEFONT_SETLOGFONT">
            <summary>An application sends the WM\_CHOOSEFONT\_SETLOGFONT message to a Font dialog box to set the current logical font information.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>When you call the [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function to create a **Font** dialog box, you can use the **lpLogFont** member of the [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure to specify a [**LOGFONT**](/windows/win32/api/wingdi/ns-wingdi-logfonta) structure containing initial values for the dialog box. Use the **WM\_CHOOSEFONT\_SETLOGFONT** message to specify a **LOGFONT** structure with different values while the **Font** dialog box is open. Typically, you would send the **WM\_CHOOSEFONT\_SETLOGFONT** message from a [**CFHookProc**](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure. The hook procedure can also send the [**WM\_CHOOSEFONT\_GETLOGFONT**](wm-choosefont-getlogfont.md) and [**WM\_CHOOSEFONT\_SETFLAGS**](wm-choosefont-setflags.md) messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-setlogfont#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHOOSEFONT_SETFLAGS">
            <summary>An application sends the WM\_CHOOSEFONT\_SETFLAGS message to a Font dialog box to set the display options for the dialog box.</summary>
            <returns>No return value.</returns>
            <remarks>
            <para>The [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function creates a **Font** dialog box and uses a [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure to specify the initial values for the **Flags** member. Use the **WM\_CHOOSEFONT\_SETFLAGS** message to specify different values for the **Flags** member while the **Font** dialog box is open. Typically, you should send the **WM\_CHOOSEFONT\_SETFLAGS** message from a [**CFHookProc**](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-setflags#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_FULLPAGERECT">
            <summary>Notifies a PagePaintHook hook procedure of the coordinates of the sample page rectangle in the Page Setup dialog box. The dialog box sends this message when it is about to draw the contents of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box sends no more messages and does not draw in the sample page until the next time the system needs to redraw the sample page. If the hook procedure returns **FALSE**, the dialog box sends the remaining messages of the drawing sequence.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_MINMARGINRECT">
            <summary>Notifies a PagePaintHook hook procedure of the coordinates of the margin rectangle in the sample page. A Page Setup dialog box sends this message when it is about to draw the contents of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box sends no more messages and does not draw in the sample page until the next time the system needs to redraw the sample page. If the hook procedure returns **FALSE**, the dialog box sends the remaining messages of the drawing sequence.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_MARGINRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the margin rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the margin rectangle in the sample page. If the hook procedure returns **FALSE**, the dialog box draws the margin rectangle in the sample page.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_GREEKTEXTRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw Greek text inside the margin rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the Greek text portion of the sample page. If the hook procedure returns **FALSE**, the dialog box draws the Greek text portion of the sample page.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_ENVSTAMPRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the envelope-stamp rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the envelope-stamp portion of the sample page. If the hook procedure returns **FALSE**, the dialog box draws the envelope-stamp portion of the sample page.</para>
            </returns>
            <remarks>
            <para>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure. A hook procedure receives this message only if the selected paper type is an envelope.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-psd-envstamprect#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_YAFULLPAGERECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the return address portion of an envelope sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the return address portion of an envelope sample page. If the hook procedure returns **FALSE**, the dialog box draws the return address portion of an envelope sample page. If the paper type is not an envelope, the return value has no effect.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CPL_LAUNCH">
            <summary>WM_CPL_LAUNCH message - This message is not supported.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-cpl-launch">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CPL_LAUNCHED">
            <summary>WM_CPL_LAUNCHED message - This message is not supported.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-cpl-launched">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TABLET_ADDED">
            <summary>The WM\_TABLET\_ADDED message is posted when a tablet device is added to Windows.</summary>
            <remarks>
            <para>This message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows. The indexes passed in *wParam* are related to the index used by the [**ITabletManager::GetTablet**](/previous-versions/windows/desktop/legacy/aa373683(v=vs.85)) method.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-added#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TABLET_DELETED">
            <summary>The WM\_TABLET\_DELETED message is posted when a tablet device is removed from Windows.</summary>
            <remarks>
            <para>This message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows. The indexes passed in *wParam* are related to the index used by the [**ITabletManager::GetTablet**](/previous-versions/windows/desktop/legacy/aa373683(v=vs.85)) method.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-deleted#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TABLET_FLICK">
            <summary>Sent when a user performs a pen flick. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>A pen flick is a unidirectional pen gesture that requires the user to contact the digitizer in a quick, straight flicking motion. A flick is characterized by high speed and a high degree of straightness. A flick is identified by its direction. Flicks can be made in eight directions corresponding to the cardinal and secondary compass directions. When a pen flick occurs, Windows first notifies an application by sending a **WM\_TABLET\_FLICK** message, which a window receives through its [*WindowProc*](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. Return the **FLICK\_WM\_HANDLED\_MASK** constant, described in [Flicks Constants](flicks-constants.md), to indicate that the application responded to the **WM\_TABLET\_FLICK** message. If the application does not return **FLICK\_WM\_HANDLED\_MASK**, Windows performs the default action specified in the flicks control panel by sending a follow-up notification, such as [**WM\_APPCOMMAND**](../inputdev/wm-appcommand.md), [**WM\_VSCROLL**](../controls/wm-vscroll.md), or [**WM\_KEYDOWN**](../inputdev/wm-keydown.md), depending on which action is associated with the pen flick. Use caution when handling the **WM\_TABLET\_FLICK** message. **WM\_TABLET\_FLICK** is passed via the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function. If you call methods on a COM interface, that object must be within the same process. If not, COM throws an exception.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-flick-message#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TABLET_QUERYSYSTEMGESTURESTATUS">
            <summary>Sent when the system asks a window which system gestures it would like to receive.</summary>
            <remarks>
            <para>By handling this message, you can dynamically disable flicks for regions of a window. > [!Note] > The *lParam* can be converted to x-coordinates and y-coordinates by using the `GET_X_LPARAM` and `GET_Y_LPARAM` macros.</para>
            <para>By default, your window will receive all system gesture events. You can choose which events you would like your window to receive and which events you would like disabled by responding to the **WM\_TABLET\_QUERYSYSTEMGESTURESTATUS** message in your **WndProc**. The **WM\_TABLET\_QUERYSYSTEMGESTURESTATUS** message is defined in tpcshrd.h. The values to enable and disable system tablet system gestures are also defined in tpcshrd.h as follows: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-querysystemgesturestatus-message#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CONTEXTMENU">
            <summary>Notifies a window that the user clicked the right mouse button (right-clicked) in the window.</summary>
            <returns>No return value.</returns>
            <remarks>
            <para>A window can process this message by displaying a shortcut menu using the [**TrackPopupMenu**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenu) or [**TrackPopupMenuEx**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenuex) functions. To obtain the horizontal and vertical positions, use the following code.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-contextmenu#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_UNICHAR">
            <summary>The WM\_UNICHAR message can be used by an application to post input to other windows.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_UNICHAR** message is similar to [**WM\_CHAR**](wm-char.md), but it uses Unicode Transformation Format (UTF)-32, whereas **WM\_CHAR** uses UTF-16. This message is designed to send or post Unicode characters to ANSI windows and can handle Unicode Supplementary Plane characters. Because there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_UNICHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-unichar#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PRINTCLIENT">
            <summary>The WM\_PRINTCLIENT message is sent to a window to request that it draw its client area in the specified device context, most commonly in a printer device context.</summary>
            <remarks>
            <para>A window can process this message in much the same manner as [**WM\_PAINT**](./wm-paint.md), except that [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) and [**EndPaint**](/windows/desktop/api/Winuser/nf-winuser-endpaint) need not be called (a device context is provided), and the window should draw its entire client area rather than just the invalid region. Windows that can be used anywhere in the system, such as controls, should process this message. It is probably worthwhile for other windows to process this message as well because it is relatively easy to implement. The [AnimateWindow](/windows/desktop/api/winuser/nf-winuser-animatewindow) function requires that the window being animated implements the **WM\_PRINTCLIENT** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-printclient#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NOTIFY">
            <summary>Sent by a common control to its parent window when an event has occurred or the control requires some information.</summary>
            <returns>The return value is ignored except for notification messages that specify otherwise.</returns>
            <remarks>
            <para>The destination of the message must be the **HWND** of the parent of the control. This value can be obtained by using [**GetParent**](/windows/desktop/api/winuser/nf-winuser-getparent), as shown in the following example, where *m\_controlHwnd* is the **HWND** of the control itself.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-notify#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DEVICECHANGE">
            <summary>Notifies an application of a change to the hardware configuration of a device or the computer.</summary>
            <returns>
            <para>Return **TRUE** to grant the request. Return **BROADCAST\_QUERY\_DENY** to deny the request.</para>
            </returns>
            <remarks>For devices that offer software-controllable features, such as ejection and locking, the system typically sends a [DBT\_DEVICEREMOVEPENDING](dbt-deviceremovepending.md) message to let applications and device drivers end their use of the device gracefully. If the system forcibly removes a device, it may not send a [DBT\_DEVICEQUERYREMOVE](dbt-devicequeryremove.md) message before doing so.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NULL">
            <summary>Performs no operation. An application sends the WM\_NULL message if it wants to post a message that the recipient window will ignore.</summary>
            <returns>
            <para>Type: **LRESULT** An application returns zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>For example, if an application has installed a **WH\_GETMESSAGE** hook and wants to prevent a message from being processed, the [**GetMsgProc**](/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)) callback function can change the message number to **WM\_NULL** so the recipient will ignore it. As another example, an application can check if a window is responding to messages by sending the **WM\_NULL** message with the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-null#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CREATE">
            <summary>Sent when an application requests that a window be created by calling the CreateWindowEx or CreateWindow function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero to continue creation of the window. If the application returns 1, the window is destroyed and the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) or [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) function returns a **NULL** handle.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-create">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DESTROY">
            <summary>Sent when a window is being destroyed. It is sent to the window procedure of the window being destroyed after the window is removed from the screen.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>If the window being destroyed is part of the clipboard viewer chain (set by calling the [**SetClipboardViewer**](/windows/win32/api/winuser/nf-winuser-setclipboardviewer) function), the window must remove itself from the chain by processing the [**ChangeClipboardChain**](/windows/win32/api/winuser/nf-winuser-changeclipboardchain) function before returning from the **WM\_DESTROY** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOVE">
            <summary>Sent after a window has been moved.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>The parameters are given in screen coordinates for overlapped and pop-up windows and in parent-client coordinates for child windows. The following example demonstrates how to obtain the position from the *lParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-move#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SIZE">
            <summary>Sent to a window after its size has changed.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>If the [**SetScrollPos**](https://msdn.microsoft.com/library/Cc411085(v=MSDN.10).aspx) or [**MoveWindow**](/windows/win32/api/winuser/nf-winuser-movewindow) function is called for a child window as a result of the **WM\_SIZE** message, the *bRedraw* or *bRepaint* parameter should be nonzero to cause the window to be repainted. Although the width and height of a window are 32-bit values, the *lParam* parameter contains only the low-order 16 bits of each. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the **WM\_SIZE** and **WM\_MOVE** messages when it processes the [**WM\_WINDOWPOSCHANGED**](wm-windowposchanged.md) message. The **WM\_SIZE** and **WM\_MOVE** messages are not sent if an application handles the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-size#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ACTIVATE">
            <summary>Sent to both the window being activated and the window being deactivated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>If the window is being activated and is not minimized, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets the keyboard focus to the window. If the window is activated by a mouse click, it also receives a [**WM\_MOUSEACTIVATE**](wm-mouseactivate.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETFOCUS">
            <summary>Sent to a window after it has gained the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>To display a caret, an application should call the appropriate caret functions when it receives the **WM\_SETFOCUS** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_KILLFOCUS">
            <summary>Sent to a window immediately before it loses the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>If an application is displaying a caret, the caret should be destroyed at this point. While processing this message, do not make any function calls that display or activate a window. This causes the thread to yield control and can cause the application to stop responding to messages. For more information, see [Message Deadlocks](/windows/desktop/winmsg/about-messages-and-message-queues).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-killfocus#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENABLE">
            <summary>Sent when an application changes the enabled state of a window.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-enable">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETREDRAW">
            <summary>You send the **WM_SETREDRAW** message to a window to allow changes in that window to be redrawn, or to prevent changes in that window from being redrawn.</summary>
            <returns>Your application should return 0 if it processes this message.</returns>
            <remarks>
            <para>This message can be useful if your application must add several items to a list box. Your application can call this message with *wParam* set to **FALSE**, add the items, and then call the message again with *wParam* set to **TRUE**. Finally, your application can call [**RedrawWindow**](/windows/win32/api/Winuser/nf-winuser-redrawwindow)(*hWnd*, **NULL**, **NULL**, RDW\_ERASE \| RDW\_FRAME \| RDW\_INVALIDATE \| RDW\_ALLCHILDREN) to cause the list box to be repainted. > [!NOTE] > You should use [**RedrawWindow**](/windows/win32/api/Winuser/nf-winuser-redrawwindow) with the specified flags, instead of [**InvalidateRect**](/windows/win32/api/Winuser/nf-winuser-invalidaterect), because the former is necessary for some controls that have nonclient area of their own, or have window styles that cause them to be given a nonclient area (such as **WS_THICKFRAME**, **WS_BORDER**, or **WS_EX_CLIENTEDGE**). If the control does not have a nonclient area, then **RedrawWindow** with these flags will do only as much invalidation as **InvalidateRect** would. Passing a **WM_SETREDRAW** message to the **DefWindowProc** function removes the **WS_VISIBLE** style from the window when *wParam* is set to **FALSE**. Although the window content remains visible on screen, the [**IsWindowVisible**](/windows/win32/api/winuser/nf-winuser-iswindowvisible) function returns **FALSE** when called on a window in this state. Passing a **WM_SETREDRAW** message to the **DefWindowProc** function adds the **WS_VISIBLE** style to the window, if not set, when *wParam* is set to **TRUE**. If your application sends the **WM_SETREDRAW** message with *wParam* set to **TRUE** to a hidden window, then the window becomes visible. **Windows 10 and later; Windows Server 2016 and later**. The system sets a property named *SysSetRedraw* on a window whose window procedure passes **WM_SETREDRAW** messages to **DefWindowProc**. You can use the [**GetProp**](/windows/win32/api/Winuser/nf-winuser-getpropa) function to get the property value when it's available. **GetProp** returns a non-zero value when redraw is disabled. **GetProp** will return zero when redraw is enabled, or when the window property doesn't exist.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-setredraw#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETTEXT">
            <summary>Sets the text of a window.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is **TRUE** if the text is set. It is **FALSE** (for an edit control), **LB\_ERRSPACE** (for a list box), or **CB\_ERRSPACE** (for a combo box) if insufficient space is available to set the text in the edit control. It is **CB\_ERR** if this message is sent to a combo box without an edit control.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets and displays the window text. For an edit control, the text is the contents of the edit control. For a combo box, the text is the contents of the edit-control portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. This message does not change the current selection in the list box of a combo box. An application should use the [**CB\_SELECTSTRING**](../controls/cb-selectstring.md) message to select the item in a list box that matches the text in the edit control.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-settext#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETTEXT">
            <summary>Copies the text that corresponds to a window into a buffer provided by the caller.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is the number of characters copied, not including the terminating null character.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function copies the text associated with the window into the specified buffer and returns the number of characters copied. Note, for non-text static controls this gives you the text with which the control was originally created, that is, the ID number. However, it gives you the ID of the non-text static control as originally created. That is, if you subsequently used a **STM\_SETIMAGE** to change it the original ID would still be returned. For an edit control, the text to be copied is the content of the edit control. For a combo box, the text is the content of the edit control (or static-text) portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. To copy the text of an item in a list box, an application can use the [**LB\_GETTEXT**](../controls/lb-gettext.md) message. When the **WM\_GETTEXT** message is sent to a static control with the **SS\_ICON** style, a handle to the icon will be returned in the first four bytes of the buffer pointed to by *lParam*. This is true only if the [**WM\_SETTEXT**](wm-settext.md) message has been used to set the icon. **Rich Edit:** If the text to be copied exceeds 64K, use either the [**EM\_STREAMOUT**](../controls/em-streamout.md) or [**EM\_GETSELTEXT**](../controls/em-getseltext.md) message. Sending a **WM\_GETTEXT** message to a non-text static control, such as a static bitmap or static icon control, does not return a string value. Instead, it returns zero. In addition, in early versions of Windows, applications could send a **WM\_GETTEXT** message to a non-text static control to retrieve the control's ID. To retrieve a control's ID, applications can use [**GetWindowLong**](/windows/win32/api/winuser/nf-winuser-getwindowlonga) passing **GWL\_ID** as the index value or [**GetWindowLongPtr**](/windows/win32/api/winuser/nf-winuser-getwindowlongptra) using **GWLP\_ID**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-gettext#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETTEXTLENGTH">
            <summary>Determines the length, in characters, of the text associated with a window.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is the length of the text in characters, not including the terminating null character.</para>
            </returns>
            <remarks>
            <para>For an edit control, the text to be copied is the content of the edit control. For a combo box, the text is the content of the edit control (or static-text) portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. To determine the length of an item in a list box, an application can use the [**LB\_GETTEXTLEN**](../controls/lb-gettextlen.md) message. When the **WM\_GETTEXTLENGTH** message is sent, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns the length, in characters, of the text. Under certain conditions, the **DefWindowProc** function returns a value that is larger than the actual length of the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common dialogs, which use Unicode. To obtain the exact length of the text, use the [**WM\_GETTEXT**](wm-gettext.md), [**LB\_GETTEXT**](../controls/lb-gettext.md), or [**CB\_GETLBTEXT**](../controls/cb-getlbtext.md) messages, or the [**GetWindowText**](/windows/win32/api/winuser/nf-winuser-getwindowtexta) function. Sending a **WM\_GETTEXTLENGTH** message to a non-text static control, such as a static bitmap or static icon controlc, does not return a string value. Instead, it returns zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-gettextlength#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PAINT">
            <summary>The WM\_PAINT message is sent when the system or another application makes a request to paint a portion of an application's window.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_PAINT** message is generated by the system and should not be sent by an application. To force a window to draw into a specific device context, use the [**WM\_PRINT**](wm-print.md) or [**WM\_PRINTCLIENT**](wm-printclient.md) message. Note that this requires the target window to support the **WM\_PRINTCLIENT** message. Most common controls support the **WM\_PRINTCLIENT** message. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function validates the update region. The function may also send the [**WM\_NCPAINT**](wm-ncpaint.md) message to the window procedure if the window frame must be painted and send the [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message if the window background must be erased. The system sends this message when there are no other messages in the application's message queue. [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage) determines where to send the message; [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) determines which message to dispatch. **GetMessage** returns the **WM\_PAINT** message when there are no other messages in the application's message queue, and **DispatchMessage** sends the message to the appropriate window procedure. A window may receive internal paint messages as a result of calling [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) with the RDW\_INTERNALPAINT flag set. In this case, the window may not have an update region. An application may call the [**GetUpdateRect**](/windows/desktop/api/Winuser/nf-winuser-getupdaterect) function to determine whether the window has an update region. If **GetUpdateRect** returns zero, the application need not call the [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) and [**EndPaint**](/windows/desktop/api/Winuser/nf-winuser-endpaint) functions. An application must check for any necessary internal painting by looking at its internal data structures for each **WM\_PAINT** message, because a **WM\_PAINT** message may have been caused by both a non-NULL update region and a call to [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) with the RDW\_INTERNALPAINT flag set. The system sends an internal **WM\_PAINT** message only once. After an internal **WM\_PAINT** message is returned from [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) or is sent to a window by [**UpdateWindow**](/windows/desktop/api/Winuser/nf-winuser-updatewindow), the system does not post or send further **WM\_PAINT** messages until the window is invalidated or until [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) is called again with the RDW\_INTERNALPAINT flag set. For some common controls, the default **WM\_PAINT** message processing checks the *wParam* parameter. If *wParam* is non-NULL, the control assumes that the value is an HDC and paints using that device context.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-paint#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CLOSE">
            <summary>Sent as a signal that a window or an application should terminate.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>An application can prompt the user for confirmation, prior to destroying a window, by processing the **WM\_CLOSE** message and calling the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function only if the user confirms the choice. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function calls the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function to destroy the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-close#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYENDSESSION">
            <summary>The WM\_QUERYENDSESSION message is sent when the user chooses to end the session or when an application calls one of the system shutdown functions.</summary>
            <returns>
            <para>Applications should respect the user's intentions and return **TRUE**. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns **TRUE** for this message. If shutting down would corrupt the system or media that is being burned, the application can return **FALSE**. However, it is good practice to respect the user's actions.</para>
            </returns>
            <remarks>
            <para>When an application returns **TRUE** for this message, it receives the [**WM\_ENDSESSION**](wm-endsession.md) message, regardless of how the other applications respond to the **WM\_QUERYENDSESSION** message. Each application should return **TRUE** or **FALSE** immediately upon receiving this message, and defer any cleanup operations until it receives the **WM\_ENDSESSION** message. Applications can display a user interface prompting the user for information at shutdown, however it is not recommended. After five seconds, the system displays information about the applications that are preventing shutdown and allows the user to terminate them. For example, WindowsXP displays a dialog box, while WindowsVista displays a full screen with additional information about the applications blocking shutdown. If your application must block or postpone system shutdown, use the [**ShutdownBlockReasonCreate**](/windows/desktop/api/Winuser/nf-winuser-shutdownblockreasoncreate) function. For more information, see [Shutdown Changes for Windows Vista](shutdown-changes-for-windows-vista.md). Console applications can use the [**SetConsoleCtrlHandler**](/windows/console/setconsolectrlhandler) function to receive shutdown notification. Service applications can use the [**RegisterServiceCtrlHandlerEx**](/windows/win32/api/winsvc/nf-winsvc-registerservicectrlhandlerexa) function to receive shutdown notifications in a handler routine.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Shutdown/wm-queryendsession#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYOPEN">
            <summary>Sent to an icon when the user requests that the window be restored to its previous size and position.</summary>
            <returns>
            <para>Type: **LRESULT** If the icon can be opened, an application that processes this message should return **TRUE**; otherwise, it should return **FALSE** to prevent the icon from being opened.</para>
            </returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns **TRUE**. While processing this message, the application should not perform any action that would cause an activation or focus change (for example, creating a dialog box).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-queryopen#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENDSESSION">
            <summary>The WM\_ENDSESSION message is sent to an application after the system processes the results of the WM\_QUERYENDSESSION message. The WM\_ENDSESSION message informs the application whether the session is ending.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Applications that have unsaved data could save the data to a temporary location and restore it the next time the application starts. It is recommended that applications save their data and state frequently; for example, automatically save data between save operations initiated by the user to reduce the amount of data to be saved at shutdown. The application need not call the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) or [**PostQuitMessage**](/windows/win32/api/winuser/nf-winuser-postquitmessage) function when the session is ending.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Shutdown/wm-endsession#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUIT">
            <summary>Indicates a request to terminate an application, and is generated when the application calls the PostQuitMessage function. This message causes the GetMessage function to return zero.</summary>
            <returns>
            <para>Type: **LRESULT** This message does not have a return value because it causes the message loop to terminate before the message is sent to the application's window procedure.</para>
            </returns>
            <remarks>
            <para>The **WM\_QUIT** message is not associated with a window and therefore will never be received through a window's window procedure. It is retrieved only by the [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) functions. Do not post the **WM\_QUIT** message using the [**PostMessage**](/windows/win32/api/winuser/nf-winuser-postmessagea) function; use [**PostQuitMessage**](/windows/win32/api/winuser/nf-winuser-postquitmessage).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-quit#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ERASEBKGND">
            <summary>Sent when the window background must be erased (for example, when a window is resized). The message is sent to prepare an invalidated portion of a window for painting.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return nonzero if it erases the background; otherwise, it should return zero.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function erases the background by using the class background brush specified by the **hbrBackground** member of the [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa) structure. If **hbrBackground** is **NULL**, the application should process the **WM\_ERASEBKGND** message and erase the background. An application should return nonzero in response to **WM\_ERASEBKGND** if it processes the message and erases the background; this indicates that no further erasing is required. If the application returns zero, the window will remain marked for erasing. (Typically, this indicates that the **fErase** member of the [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) structure will be **TRUE**.)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-erasebkgnd#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSCOLORCHANGE">
            <summary>The WM\_SYSCOLORCHANGE message is sent to all top-level windows when a change is made to a system color setting.</summary>
            <remarks>
            <para>The system sends a [**WM\_PAINT**](wm-paint.md) message to any window that is affected by a system color change. Applications that have brushes using the existing system colors should delete those brushes and re-create them using the new system colors. Top level windows that use common controls must forward the **WM\_SYSCOLORCHANGE** message to the controls; otherwise, the controls will not be notified of the color change. This ensures that the colors used by your common controls are consistent with those used by other user interface objects. For example, a toolbar control uses the "3D Objects" color to draw its buttons. If the user changes the 3D Objects color but the **WM\_SYSCOLORCHANGE** message is not forwarded to the toolbar, the toolbar buttons will remain in their original color while the color of other buttons in the system changes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-syscolorchange#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SHOWWINDOW">
            <summary>Sent to a window when the window is about to be hidden or shown.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function hides or shows the window, as specified by the message. If a window has the [**WS\_VISIBLE**](window-styles.md) style when it is created, the window receives this message after it is created, but before it is displayed. A window also receives this message when its visibility state is changed by the [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow) or [**ShowOwnedPopups**](/windows/win32/api/winuser/nf-winuser-showownedpopups) function. The **WM\_SHOWWINDOW** message is not sent under the following circumstances: -   When a top-level, overlapped window is created with the [**WS\_MAXIMIZE**](window-styles.md) or **WS\_MINIMIZE** style. -   When the **SW\_SHOWNORMAL** flag is specified in the call to the [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-showwindow#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_WININICHANGE">
            <summary>An application sends the WM\_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.</summary>
            <returns>
            <para>Type: **LRESULT** If you process this message, return zero.</para>
            </returns>
            <remarks>
            <para>To send the **WM\_WININICHANGE** message to all top-level windows, use the [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) function with the *hWnd* parameter set to **HWND\_BROADCAST**. Calls to functions that change WIN.INI may be mapped to the registry instead. This mapping occurs when WIN.INI and the section being changed are specified in the registry under the following key: **HKEY\_LOCAL\_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping** The change in the storage location has no effect on the behavior of this message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-wininichange#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETTINGCHANGE">
            <summary>A message that is sent to all top-level windows when the SystemParametersInfo function changes a system-wide setting or when policy settings have changed.</summary>
            <returns>
            <para>Type: **LRESULT** If you process this message, return zero.</para>
            </returns>
            <remarks>The *lParam* parameter indicates which system metric has changed, for example, "ConvertibleSlateMode" if the CONVERTIBLESLATEMODE indicator was toggled or "SystemDockMode" if the DOCKED indicator was toggled.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DEVMODECHANGE">
            <summary>The WM\_DEVMODECHANGE message is sent to all top-level windows whenever the user changes device-mode settings.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>This message cannot be sent directly to a window. To send the **WM\_DEVMODECHANGE** message to all top-level windows, use the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function with the *hWnd* parameter set to HWND\_BROADCAST.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ACTIVATEAPP">
            <summary>Sent when a window belonging to a different application than the active window is about to be activated. The message is sent to the application whose window is being activated and to the application whose window is being deactivated.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-activateapp">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_FONTCHANGE">
            <summary>An application sends the WM\_FONTCHANGE message to all top-level windows in the system after changing the pool of font resources.</summary>
            <remarks>
            <para>An application that adds or removes fonts from the system (for example, by using the [**AddFontResource**](/windows/desktop/api/Wingdi/nf-wingdi-addfontresourcea) or [**RemoveFontResource**](/windows/desktop/api/Wingdi/nf-wingdi-removefontresourcea) function) should send this message to all top-level windows. To send the **WM\_FONTCHANGE** message to all top-level windows, an application can call the **SendMessage** function with the *hwnd* parameter set to HWND\_BROADCAST.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-fontchange#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TIMECHANGE">
            <summary>A message that is sent whenever there is a change in the system time.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>An application should not broadcast this message, because the system will broadcast this message when the application changes the system time.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CANCELMODE">
            <summary>Sent to cancel certain modes, such as mouse capture.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>When the **WM\_CANCELMODE** message is sent, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function cancels internal processing of standard scroll bar input, cancels internal menu processing, and releases the mouse capture.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETCURSOR">
            <summary>Sent to a window if the mouse causes the cursor to move within a window and mouse input is not captured.</summary>
            <returns>If an application processes this message, it should return **TRUE** to halt further processing or **FALSE** to continue.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowprocw) function passes the **WM\_SETCURSOR** message to a parent window before processing. If the parent window returns **TRUE**, further processing is halted. Passing the message to a window's parent window gives the parent window control over the cursor's setting in a child window. The **DefWindowProc** function also uses this message to set the cursor to an arrow if it is not in the client area, or to the registered class cursor if it is in the client area. If the low-order word of the *lParam* parameter is **HTERROR** and the high-order word of *lParam* specifies that one of the mouse buttons is pressed, **DefWindowProc** calls the [**MessageBeep**](/windows/desktop/api/winuser/nf-winuser-messagebeep) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEACTIVATE">
            <summary>Sent when the cursor is in an inactive window and the user presses a mouse button. The parent window receives this message only if the child window passes it to the DefWindowProc function.</summary>
            <returns>
            <para>The return value specifies whether the window should be activated and whether the identifier of the mouse message should be discarded. It must be one of the following values.</para>
            <para>| Return code/value                                                                                                                                          | Description                                                                      | |------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------| | <dl> <dt>**MA\_ACTIVATE**</dt> <dt>1</dt> </dl>         | Activates the window, and does not discard the mouse message.<br/>         | | <dl> <dt>**MA\_ACTIVATEANDEAT**</dt> <dt>2</dt> </dl>   | Activates the window, and discards the mouse message.<br/>                 | | <dl> <dt>**MA\_NOACTIVATE**</dt> <dt>3</dt> </dl>       | Does not activate the window, and does not discard the mouse message.<br/> | | <dl> <dt>**MA\_NOACTIVATEANDEAT**</dt> <dt>4</dt> </dl> | Does not activate the window, but discards the mouse message.<br/>         |</para>
            </returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function passes the message to a child window's parent window before any processing occurs. The parent window determines whether to activate the child window. If it activates the child window, the parent window should return **MA\_NOACTIVATE** or **MA\_NOACTIVATEANDEAT** to prevent the system from processing the message further.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHILDACTIVATE">
            <summary>Sent to a child window when the user clicks the window's title bar or when the window is activated, moved, or sized.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-childactivate">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUEUESYNC">
            <summary>Sent by a computer-based training (CBT) application to separate user-input messages from other messages sent through the WH\_JOURNALPLAYBACK procedure.</summary>
            <returns>
            <para>Type: **void** A CBT application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>Whenever a CBT application uses the [**WH\_JOURNALPLAYBACK**](about-hooks.md) procedure, the first and last messages are **WM\_QUEUESYNC**. This allows the CBT application to intercept and examine user-initiated messages without doing so for events that it sends. If an application specifies a **NULL** window handle, the message is posted to the message queue of the active window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-queuesync#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETMINMAXINFO">
            <summary>Sent to a window when the size or position of the window is about to change. An application can use this message to override the window's default maximized size and position, or its default minimum or maximum tracking size.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>The maximum tracking size is the largest window size that can be produced by using the borders to size the window. The minimum tracking size is the smallest window size that can be produced by using the borders to size the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NEXTDLGCTL">
            <summary>Sent to a dialog box procedure to set the keyboard focus to a different control in the dialog box.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>This message performs additional dialog box management operations beyond those performed by the [**SetFocus**](/windows/desktop/api/winuser/nf-winuser-setfocus) function **WM\_NEXTDLGCTL** updates the default pushbutton border, sets the default control identifier, and automatically selects the text of an edit control (if the target window is an edit control). Do not use the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to send a **WM\_NEXTDLGCTL** message if your application will concurrently process other messages that set the focus. Use the [**PostMessage**](/windows/desktop/api/winuser/nf-winuser-postmessagea) function instead.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-nextdlgctl#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SPOOLERSTATUS">
            <summary>The WM\_SPOOLERSTATUS message is sent from Print Manager whenever a job is added to or removed from the Print Manager queue.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>This message is for informational purposes only. This message is advisory and does not have guaranteed delivery semantics. Applications should not assume that they will receive a WM\_SPOOLERSTATUS message for every change in spooler status. The WM\_SPOOLERSTATUS message is not supported after Windows XP. To be notified of changes to the print queue status, you can use [**FindFirstPrinterChangeNotification**](findfirstprinterchangenotification.md) and [**FindNextPrinterChangeNotification**](findnextprinterchangenotification.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/printdocs/wm-spoolerstatus#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DRAWITEM">
            <summary>Sent to the parent window of an owner-drawn button, combo box, list box, or menu when a visual aspect of the button, combo box, list box, or menu has changed.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function draws the focus rectangle for an owner-drawn list box item. The *itemAction* member of the [**DRAWITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-drawitemstruct) structure specifies the drawing operation that an application should perform. Before returning from processing this message, an application should ensure that the device context identified by the *hDC* member of the [**DRAWITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-drawitemstruct) structure is in the default state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-drawitem#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MEASUREITEM">
            <summary>Sent to the owner window of a combo box, list box, list-view control, or menu item when the control or menu is created.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para>When the owner window receives the **WM\_MEASUREITEM** message, the owner fills in the [**MEASUREITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-measureitemstruct) structure pointed to by the *lParam* parameter of the message and returns; this informs the system of the dimensions of the control. If a list box or combo box is created with the [**LBS\_OWNERDRAWVARIABLE**](list-box-styles.md) or [**CBS\_OWNERDRAWVARIABLE**](combo-box-styles.md) style, this message is sent to the owner for each item in the control; otherwise, this message is sent once. The system sends the **WM\_MEASUREITEM** message to the owner window of combo boxes and list boxes created with the OWNERDRAWFIXED style before sending the [**WM\_INITDIALOG**](/windows/desktop/dlgbox/wm-initdialog) message. As a result, when the owner receives this message, the system has not yet determined the height and width of the font used in the control; function calls and calculations requiring these values should occur in the main function of the application or library.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-measureitem#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DELETEITEM">
            <summary>Sent to the owner of a list box or combo box when the list box or combo box is destroyed or when items are removed by the LB\_DELETESTRING, LB\_RESETCONTENT, CB\_DELETESTRING, or CB\_RESETCONTENT message.</summary>
            <returns>An application should return **TRUE** if it processes this message.</returns>
            <remarks>
            <para>Microsoft Windows NT and later: Windows sends a **WM\_DELETEITEM** message only for items deleted from an owner-drawn list box (with the [**LBS\_OWNERDRAWFIXED**](list-box-styles.md) or [**LBS\_OWNERDRAWVARIABLE**](list-box-styles.md) style) or owner-drawn combo box (with the [**CBS\_OWNERDRAWFIXED**](combo-box-styles.md) or [**CBS\_OWNERDRAWVARIABLE**](combo-box-styles.md) style). Windows 95: Windows sends the **WM\_DELETEITEM** message for any deleted list box or combo box item with nonzero item data.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-deleteitem#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_VKEYTOITEM">
            <summary>Sent by a list box with the LBS\_WANTKEYBOARDINPUT style to its owner in response to a WM\_KEYDOWN message.</summary>
            <returns>The return value specifies the action that the application performed in response to the message. A return value of -2 indicates that the application handled all aspects of selecting the item and requires no further action by the list box. (See Remarks.) A return value of -1 indicates that the list box should perform the default action in response to the keystroke. A return value of 0 or greater specifies the index of an item in the list box and indicates that the list box should perform the default action for the keystroke on the specified item.</returns>
            <remarks>
            <para>A return value of -2 is valid only for keys that are not translated into characters by the list box control. If the [**WM\_KEYDOWN**](/windows/desktop/inputdev/wm-keydown) message translates to a [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) message and the application processes the **WM\_VKEYTOITEM** message generated as a result of the key press, the list box ignores the return value and does the default processing for that character). **WM\_KEYDOWN** messages generated by keys such as VK\_UP, VK\_DOWN, VK\_NEXT, and VK\_PREVIOUS are not translated to **WM\_CHAR** messages. In such cases, trapping the **WM\_VKEYTOITEM** message and returning -2 prevents the list box from doing the default processing for that key. To trap keys that generate a char message and do special processing, the application must subclass the list box, trap both the [**WM\_KEYDOWN**](/windows/desktop/inputdev/wm-keydown) and [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) messages, and process the messages appropriately in the subclass procedure. The preceding remarks apply to regular list boxes that are created with the [**LBS\_WANTKEYBOARDINPUT**](list-box-styles.md) style. If the list box is owner-drawn, the application must process the [**WM\_CHARTOITEM**](wm-chartoitem.md) message. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns -1. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-vkeytoitem#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHARTOITEM">
            <summary>Sent by a list box with the LBS\_WANTKEYBOARDINPUT style to its owner in response to a WM\_CHAR message.</summary>
            <returns>The return value specifies the action that the application performed in response to the message. A return value of -1 or -2 indicates that the application handled all aspects of selecting the item and requires no further action by the list box. A return value of 0 or greater specifies the zero-based index of an item in the list box and indicates that the list box should perform the default action for the keystroke on the specified item.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns -1. Only owner-drawn list boxes that do not have the [**LBS\_HASSTRINGS**](list-box-styles.md) style can receive this message. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The *DWL\_MSGRESULT* value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-chartoitem#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETFONT">
            <summary>Sets the font that a control is to use when drawing text.</summary>
            <returns>
            <para>Type: **LRESULT** This message does not return a value.</para>
            </returns>
            <remarks>
            <para>The **WM\_SETFONT** message applies to all controls, not just those in dialog boxes. The best time for the owner of a dialog box control to set the font of the control is when it receives the [**WM\_INITDIALOG**](../dlgbox/wm-initdialog.md) message. The application should call the [**DeleteObject**](/windows/win32/api/wingdi/nf-wingdi-deleteobject) function to delete the font when it is no longer needed; for example, after it destroys the control. The size of the control does not change as a result of receiving this message. To avoid clipping text that does not fit within the boundaries of the control, the application should correct the size of the control window before it sets the font. When a dialog box uses the [DS\_SETFONT](../dlgbox/about-dialog-boxes.md) style to set the text in its controls, the system sends the **WM\_SETFONT** message to the dialog box procedure before it creates the controls. An application can create a dialog box that contains the DS\_SETFONT style by calling any of the following functions: -   [**CreateDialogIndirect**](/windows/win32/api/winuser/nf-winuser-createdialogindirecta) -   [**CreateDialogIndirectParam**](/windows/win32/api/winuser/nf-winuser-createdialogindirectparama) -   [**DialogBoxIndirect**](/windows/win32/api/winuser/nf-winuser-dialogboxindirecta) -   [**DialogBoxIndirectParam**](/windows/win32/api/winuser/nf-winuser-dialogboxindirectparama)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-setfont#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETFONT">
            <summary>Retrieves the font with which the control is currently drawing its text.</summary>
            <returns>
            <para>Type: **HFONT** The return value is a handle to the font used by the control, or **NULL** if the control is using the system font.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-getfont">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETHOTKEY">
            <summary>Sent to a window to associate a hot key with the window. When the user presses the hot key, the system activates the window.</summary>
            <returns>
            <para>The return value is one of the following.</para>
            <para>| Return value                                                                  | Description                                                                             | |-------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------| | <dl> <dt>-1</dt> </dl> | The function is unsuccessful; the hot key is invalid.<br/>                        | | <dl> <dt>0</dt> </dl>  | The function is unsuccessful; the window is invalid.<br/>                         | | <dl> <dt>1</dt> </dl>  | The function is successful, and no other window has the same hot key.<br/>        | | <dl> <dt>2</dt> </dl>  | The function is successful, but another window already has the same hot key.<br/> |</para>
            </returns>
            <remarks>
            <para>A hot key cannot be associated with a child window. **VK\_ESCAPE**, **VK\_SPACE**, and **VK\_TAB** are invalid hot keys. When the user presses the hot key, the system generates a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message with *wParam* equal to **SC\_HOTKEY** and *lParam* equal to the window's handle. If this message is passed on to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), the system will bring the window's last active popup (if it exists) or the window itself (if there is no popup window) to the foreground. A window can only have one hot key. If the window already has a hot key associated with it, the new hot key replaces the old one. If more than one window has the same hot key, the window that is activated by the hot key is random. These hot keys are unrelated to the hot keys set by [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-sethotkey#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETHOTKEY">
            <summary>Sent to determine the hot key associated with a window.</summary>
            <returns>
            <para>The return value is the virtual-key code and modifiers for the hot key, or **NULL** if no hot key is associated with the window. The virtual-key code is in the low byte of the return value and the modifiers are in the high byte. The modifiers can be a combination of the following flags from CommCtrl.h.</para>
            <para>| Return code/value                                                                                                                                         | Description             | |-----------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------| | <dl> <dt>**HOTKEYF\_ALT**</dt> <dt>0x04</dt> </dl>     | ALT key<br/>      | | <dl> <dt>**HOTKEYF\_CONTROL**</dt> <dt>0x02</dt> </dl> | CTRL key<br/>     | | <dl> <dt>**HOTKEYF\_EXT**</dt> <dt>0x08</dt> </dl>     | Extended key<br/> | | <dl> <dt>**HOTKEYF\_SHIFT**</dt> <dt>0x01</dt> </dl>   | SHIFT key<br/>    |</para>
            </returns>
            <remarks>These hot keys are unrelated to the hot keys set by the [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYDRAGICON">
            <summary>Sent to a minimized (iconic) window.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return a handle to a cursor or icon that the system is to display while the user drags the icon. The cursor or icon must be compatible with the display driver's resolution. If the application returns **NULL**, the system displays the default cursor.</para>
            </returns>
            <remarks>
            <para>When the user drags the icon of a window without a class icon, the system replaces the icon with a default cursor. If the application requires a different cursor to be displayed during dragging, it must return a handle to the cursor or icon compatible with the display driver's resolution. If an application returns a handle to a color cursor or icon, the system converts the cursor or icon to black and white. The application can call the [**LoadCursor**](/windows/win32/api/winuser/nf-winuser-loadcursora) or [**LoadIcon**](/windows/win32/api/winuser/nf-winuser-loadicona) function to load a cursor or icon from the resources in its executable (.exe) file and to retrieve this handle. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-querydragicon#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COMPAREITEM">
            <summary>Sent to determine the relative position of a new item in the sorted list of an owner-drawn combo box or list box.</summary>
            <returns>
            <para>The return value indicates the relative position of the two items. It may be any of the values shown in the following table.</para>
            <para>| Return code                                                                          | Description                                                  | |--------------------------------------------------------------------------------------|--------------------------------------------------------------| | <dl> <dt>**Value**</dt> </dl> | Meaning<br/>                                           | | <dl> <dt>**-1**</dt> </dl>    | Item 1 precedes item 2 in the sorted order.<br/>       | | <dl> <dt>**0**</dt> </dl>     | Items 1 and 2 are equivalent in the sorted order.<br/> | | <dl> <dt>**1**</dt> </dl>     | Item 1 follows item 2 in the sorted order.<br/>        |</para>
            </returns>
            <remarks>
            <para>When the owner of an owner-drawn combo box or list box receives this message, the owner returns a value indicating which of the items specified by the [**COMPAREITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-compareitemstruct) structure will appear before the other. Typically, the system sends this message several times until it determines the exact position for the new item. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-compareitem#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETOBJECT">
            <summary>Sent by both Microsoft Active Accessibility and Microsoft UI Automation to obtain information about an accessible object contained in a server application.</summary>
            <returns>
            <para>If the window or control does not need to respond to this message, it should pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function; otherwise, the window or control should return a value that corresponds to the request specified by *dwObjId*: -   If the window or control implements UI Automation, the window or control should return the value obtained by a call to the [**UiaReturnRawElementProvider**](/windows/desktop/api/UIAutomationCoreApi/nf-uiautomationcoreapi-uiareturnrawelementprovider) function. -   If *dwObjId* is [**OBJID\_NATIVEOM**](object-identifiers.md) and the window exposes a native Object Model, the windows should return the value obtained by a call to the [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) function. -   If *dwObjId* is [**OBJID\_CLIENT**](object-identifiers.md) and the window implements [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible), the window should return the value obtained by a call to the [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) function.</para>
            </returns>
            <remarks>
            <para>When a client calls [**AccessibleObjectFromWindow**](/windows/desktop/api/Oleacc/nf-oleacc-accessibleobjectfromwindow) or any of the other **AccessibleObjectFrom***X* functions that retrieve an interface to an object, Microsoft Active Accessibility sends the **WM\_GETOBJECT** message to the appropriate window procedure within the appropriate server application. While processing **WM\_GETOBJECT**, server applications call [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) and use the return value of this function as the return value for the message. Microsoft Active Accessibility, in conjunction with the COM library, performs the appropriate marshaling and passes the interface pointer from the server back to the client. Servers do not respond to **WM\_GETOBJECT** before the object is fully initialized or after it begins to close down. When an application creates a new window, the system sends [**EVENT\_OBJECT\_CREATE**](event-constants.md) to notify clients before it sends the [WM\_CREATE](../winmsg/wm-create.md) message to the application's window procedure. Because many applications use WM\_CREATE to start their initialization process, servers do not respond to the **WM\_GETOBJECT** message until finished processing the **WM\_CREATE** message. A server uses **WM\_GETOBJECT** to perform the following tasks: -   [Create New Accessible Objects](create-new-accessible-objects.md) -   [Reuse Existing Pointers to Objects](reuse-existing-pointers-to-objects.md) -   [Create New Interfaces to the Same Object](create-new-interfaces-to-the-same-object.md) For clients, this means that they might receive distinct interface pointers for the same user interface element, depending on the server's action. To determine if two interface pointers point to the same user interface element, clients compare [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) properties of the object. Comparing pointers does not work.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/WinAuto/wm-getobject#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COMPACTING">
            <summary>Sent to all top-level windows when the system detects more than 12.5 percent of system time over a 30- to 60-second interval is being spent compacting memory. This indicates that system memory is low.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>When an application receives this message, it should free as much memory as possible, taking into account the current level of activity of the application and the total number of applications running on the system.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_WINDOWPOSCHANGING">
            <summary>Sent to a window whose size, position, or place in the Z order is about to change as a result of a call to the SetWindowPos function or another window-management function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>For a window with the [**WS\_OVERLAPPED**](window-styles.md) or **WS\_THICKFRAME** style, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the [**WM\_GETMINMAXINFO**](wm-getminmaxinfo.md) message to the window. This is done to validate the new size and position of the window and to enforce the [CS\_BYTEALIGNCLIENT](about-window-classes.md) and CS\_BYTEALIGNWINDOW client styles. By not passing the **WM\_WINDOWPOSCHANGING** message to the **DefWindowProc** function, an application can override these defaults. While this message is being processed, modifying any of the values in [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) affects the window's new size, position, or place in the Z order. An application can prevent changes to the window by setting or clearing the appropriate bits in the **flags** member of **WINDOWPOS**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-windowposchanging#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_WINDOWPOSCHANGED">
            <summary>Sent to a window whose size, position, or place in the Z order has changed as a result of a call to the SetWindowPos function or another window-management function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the [**WM\_SIZE**](wm-size.md) and [**WM\_MOVE**](wm-move.md) messages to the window. The **WM\_SIZE** and **WM\_MOVE** messages are not sent if an application handles the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**. It is more efficient to perform any move or size change processing during the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POWER">
            <summary>Notifies applications that the system, typically a battery-powered personal computer, is about to enter a suspended mode.</summary>
            <returns>The value an application returns depends on the value of the *wParam* parameter. If *wParam* is **PWR\_SUSPENDREQUEST**, the return value is **PWR\_FAIL** to prevent the system from entering the suspended state; otherwise, it is **PWR\_OK**. If *wParam* is **PWR\_SUSPENDRESUME** or **PWR\_CRITICALRESUME**, the return value is zero.</returns>
            <remarks>
            <para>This message is broadcast only to an application that is running on a system that conforms to the Advanced Power Management (APM) basic input/output system (BIOS) specification. The message is broadcast by the power-management driver to each window returned by the **EnumWindows** function. The suspended mode is the state in which the greatest amount of power savings occurs, but all operational data and parameters are preserved. Random-access memory (RAM) contents are preserved, but many devices are likely to be turned off.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Power/wm-power#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COPYDATA">
            <summary>An application sends the WM\_COPYDATA message to pass data to another application.</summary>
            <returns>If the receiving application processes this message, it should return **TRUE**; otherwise, it should return **FALSE**.</returns>
            <remarks>
            <para>The data being passed must not contain pointers or other references to objects not accessible to the application receiving the data. While this message is being sent, the referenced data must not be changed by another thread of the sending process. The receiving application should consider the data read-only. The *lParam* parameter is valid only during the processing of the message. The receiving application should not free the memory referenced by *lParam*. If the receiving application must access the data after [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) returns, it must copy the data into a local buffer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-copydata#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CANCELJOURNAL">
            <summary>Posted to an application when a user cancels the application's journaling activities. The message is posted with a NULL window handle.</summary>
            <returns>
            <para>Type: **void** This message does not return a value. It is meant to be processed from within an application's main loop or a [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) hook procedure, not from a window procedure.</para>
            </returns>
            <remarks>
            <para>Journal record and playback modes are modes imposed on the system that let an application sequentially record or play back user input. The system enters these modes when an application installs a [*JournalRecordProc*](/previous-versions/windows/desktop/legacy/ms644983(v=vs.85)) or [*JournalPlaybackProc*](/previous-versions/windows/desktop/legacy/ms644982(v=vs.85)) hook procedure. When the system is in either of these journaling modes, applications must take turns reading input from the input queue. If any one application stops reading input while the system is in a journaling mode, other applications are forced to wait. To ensure a robust system, one that cannot be made unresponsive by any one application, the system automatically cancels any journaling activities when a user presses CTRL+ESC or CTRL+ALT+DEL. The system then unhooks any journaling hook procedures, and posts a **WM\_CANCELJOURNAL** message, with a **NULL** window handle, to the application that set the journaling hook. The **WM\_CANCELJOURNAL** message has a **NULL** window handle, therefore it cannot be dispatched to a window procedure. There are two ways for an application to see a **WM\_CANCELJOURNAL** message: If the application is running in its own main loop, it must catch the message between its call to [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) and its call to [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage). If the application is not running in its own main loop, it must set a [*GetMsgProc*](/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)) hook procedure (through a call to [**SetWindowsHookEx**](/windows/win32/api/winuser/nf-winuser-setwindowshookexa) specifying the **WH\_GETMESSAGE** hook type) that watches for the message. When an application sees a **WM\_CANCELJOURNAL** message, it can assume two things: the user has intentionally canceled the journal record or playback mode, and the system has already unhooked any journal record or playback hook procedures. Note that the key combinations mentioned above (CTRL+ESC or CTRL+ALT+DEL) cause the system to cancel journaling. If any one application is made unresponsive, they give the user a means of recovery. The [**VK\_CANCEL**](../inputdev/virtual-key-codes.md) virtual key code (usually implemented as the CTRL+BREAK key combination) is what an application that is in journal record mode should watch for as a signal that the user wishes to cancel the journaling activity. The difference is that watching for **VK\_CANCEL** is a suggested behavior for journaling applications, whereas CTRL+ESC or CTRL+ALT+DEL cause the system to cancel journaling regardless of a journaling application's behavior.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-canceljournal#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INPUTLANGCHANGEREQUEST">
            <summary>Posted to the window with the focus when the user chooses a new input language, either with the hotkey (specified in the Keyboard control panel application) or from the indicator on the system taskbar.</summary>
            <returns>
            <para>Type: **LRESULT** This message is posted, not sent, to the application, so the return value is ignored. To accept the change, the application should pass the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). To reject the change, the application should return zero without calling **DefWindowProc**.</para>
            </returns>
            <remarks>
            <para>When the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function receives the **WM\_INPUTLANGCHANGEREQUEST** message, it activates the new input locale and notifies the application of the change by sending the [**WM\_INPUTLANGCHANGE**](wm-inputlangchange.md) message. The language indicator is present on the taskbar only if you have installed more than one keyboard layout and if you have enabled the indicator using the Keyboard control panel application.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-inputlangchangerequest#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INPUTLANGCHANGE">
            <summary>Sent to the topmost affected window after an application's input language has been changed. You should make any application-specific settings and pass the message to the DefWindowProc function, which passes the message to all first-level child windows.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return nonzero if it processes this message.</para>
            </returns>
            <remarks>
            <para>You can retrieve the [BCP 47](https://www.rfc-editor.org/info/bcp47) [locale name](../Intl/locale-names.md) from the language identifier by calling the [LCIDToLocaleName](/windows/win32/api/winnls/nf-winnls-lcidtolocalename) function. Once you have the locale name, you can then use [modern locale functions](/windows/win32/intl/calling-the--locale-name--functions) to extract additional locale information. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-inputlangchange#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TCARD">
            <summary>Sent to an application that has initiated a training card with Windows Help.</summary>
            <returns>The return value is ignored; use zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-tcard">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_HELP">
            <summary>Indicates that the user pressed the F1 key.</summary>
            <returns>Returns **TRUE**.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function passes **WM\_HELP** to the parent window of a child window or to the owner of a top-level window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_USERCHANGED">
            <summary>Sent to all windows after the user has logged on or off. When the user logs on or off, the system updates the user-specific settings. The system sends this message immediately after updating the settings.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-userchanged">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NOTIFYFORMAT">
            <summary>Determines if a window accepts ANSI or Unicode structures in the WM\_NOTIFY notification message. WM\_NOTIFYFORMAT messages are sent from a common control to its parent window and from the parent window to the common control.</summary>
            <returns>
            <para>Returns one of the following values.</para>
            <para>| Return code                                                                                 | Description                                                                                                    | |---------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------| | <dl> <dt>**NFR\_ANSI**</dt> </dl>    | ANSI structures should be used in [**WM\_NOTIFY**](wm-notify.md) messages sent by the control.<br/>     | | <dl> <dt>**NFR\_UNICODE**</dt> </dl> | Unicode structures should be used in [**WM\_NOTIFY**](wm-notify.md) messages sent by the control. <br/> | | <dl> <dt>**0**</dt> </dl>            | An error occurred.<br/>                                                                                  |</para>
            </returns>
            <remarks>
            <para>When a common control is created, the control sends a **WM\_NOTIFYFORMAT** message to its parent window to determine the type of structures to use in [**WM\_NOTIFY**](wm-notify.md) messages. If the parent window does not handle this message, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function responds according to the type of the parent window. That is, if the parent window is a Unicode window, **DefWindowProc** returns NFR\_UNICODE, and if the parent window is an ANSI window, **DefWindowProc** returns NFR\_ANSI. If the parent window is a dialog box and does not handle this message, the [**DefDlgProc**](/windows/desktop/api/winuser/nf-winuser-defdlgprocw) function similarly responds according to the type of the dialog box (Unicode or ANSI). A parent window can change the type of structures a common control uses in [**WM\_NOTIFY**](wm-notify.md) messages by setting *lParam* to NF\_REQUERY and sending a **WM\_NOTIFYFORMAT** message to the control. This causes the control to send an NF\_QUERY form of the **WM\_NOTIFYFORMAT** message to the parent window. All common controls will send **WM\_NOTIFYFORMAT** messages. However, the standard Windows controls (edit controls, combo boxes, list boxes, buttons, scroll bars, and static controls) do not.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-notifyformat#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_STYLECHANGING">
            <summary>Sent to a window when the SetWindowLong function is about to change one or more of the window's styles.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-stylechanging">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_STYLECHANGED">
            <summary>Sent to a window after the SetWindowLong function has changed one or more of the window's styles.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-stylechanged">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DISPLAYCHANGE">
            <summary>The WM\_DISPLAYCHANGE message is sent to all windows when the display resolution has changed.</summary>
            <remarks>This message is only sent to top-level windows. For all other windows it is posted.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETICON">
            <summary>Sent to a window to retrieve a handle to the large or small icon associated with a window. The system displays the large icon in the ALT+TAB dialog, and the small icon in the window caption.</summary>
            <returns>
            <para>Type: **HICON** The return value is a handle to the large or small icon, depending on the value of *wParam*. When an application receives this message, it can return a handle to a large or small icon, or pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function.</para>
            </returns>
            <remarks>
            <para>When an application receives this message, it can return a handle to a large or small icon, or pass the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) returns a handle to the large or small icon associated with the window, depending on the value of *wParam*. A window that has no icon explicitly set (with **WM\_SETICON**) uses the icon for the registered window class, and in this case [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) will return 0 for a **WM\_GETICON** message. If sending a **WM\_GETICON** message to a window returns 0, next try calling the [**GetClassLongPtr**](/windows/win32/api/winuser/nf-winuser-getclasslongptra) function for the window. If that returns 0 then try the [**LoadIcon**](/windows/win32/api/winuser/nf-winuser-loadicona) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-geticon#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETICON">
            <summary>Associates a new large or small icon with a window. The system displays the large icon in the ALT+TAB dialog box, and the small icon in the window caption.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is a handle to the previous large or small icon, depending on the value of *wParam*. It is **NULL** if the window previously had no icon of the type indicated by *wParam*.</para>
            </returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns a handle to the previous large or small icon associated with the window, depending on the value of *wParam*.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCCREATE">
            <summary>Sent prior to the WM\_CREATE message when a window is first created.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return **TRUE** to continue creation of the window. If the application returns **FALSE**, the [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) or [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function will return a **NULL** handle.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-nccreate">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCDESTROY">
            <summary>Notifies a window that its nonclient area is being destroyed. The DestroyWindow function sends the WM\_NCDESTROY message to the window following the WM\_DESTROY message.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>This message frees any memory internally allocated for the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCCALCSIZE">
            <summary>Sent when the size and position of a window's client area must be calculated. By processing this message, an application can control the content of the window's client area when the size or position of the window changes.</summary>
            <returns>
            <para>Type: **LRESULT** If the *wParam* parameter is **FALSE**, the application should return zero. If *wParam* is **TRUE**, the application should return zero or a combination of the following values. If *wParam* is **TRUE** and an application returns zero, the old client area is preserved and is aligned with the upper-left corner of the new client area.</para>
            <para>| Return code/value                                                                                                                                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | |-------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**WVR\_ALIGNTOP**</dt> <dt>0x0010</dt> </dl>    | Specifies that the client area of the window is to be preserved and aligned with the top of the new position of the window. For example, to align the client area to the upper-left corner, return the WVR\_ALIGNTOP and **WVR\_ALIGNLEFT** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | | <dl> <dt>**WVR\_ALIGNRIGHT**</dt> <dt>0x0080</dt> </dl>  | Specifies that the client area of the window is to be preserved and aligned with the right side of the new position of the window. For example, to align the client area to the lower-right corner, return the **WVR\_ALIGNRIGHT** and WVR\_ALIGNBOTTOM values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | | <dl> <dt>**WVR\_ALIGNLEFT**</dt> <dt>0x0020</dt> </dl>   | Specifies that the client area of the window is to be preserved and aligned with the left side of the new position of the window. For example, to align the client area to the lower-left corner, return the **WVR\_ALIGNLEFT** and **WVR\_ALIGNBOTTOM** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | | <dl> <dt>**WVR\_ALIGNBOTTOM**</dt> <dt>0x0040</dt> </dl> | Specifies that the client area of the window is to be preserved and aligned with the bottom of the new position of the window. For example, to align the client area to the top-left corner, return the WVR\_ALIGNTOP and **WVR\_ALIGNLEFT** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | | <dl> <dt>**WVR\_HREDRAW**</dt> <dt>0x0100</dt> </dl>     | Used in combination with any other values, except **WVR\_VALIDRECTS**, causes the window to be completely redrawn if the client rectangle changes size horizontally. This value is similar to [CS\_HREDRAW](about-window-classes.md)class style<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | | <dl> <dt>**WVR\_VREDRAW**</dt> <dt>0x0200</dt> </dl>     | Used in combination with any other values, except **WVR\_VALIDRECTS**, causes the window to be completely redrawn if the client rectangle changes size vertically. This value is similar to [CS\_VREDRAW](about-window-classes.md)class style<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | | <dl> <dt>**WVR\_REDRAW**</dt> <dt>0x0300</dt> </dl>      | This value causes the entire window to be redrawn. It is a combination of **WVR\_HREDRAW** and **WVR\_VREDRAW** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | | <dl> <dt>**WVR\_VALIDRECTS**</dt> <dt>0x0400</dt> </dl>  | This value indicates that, upon return from [**WM\_NCCALCSIZE**](wm-nccalcsize.md), the rectangles specified by the **rgrc**\[1\] and **rgrc**\[2\] members of the [**NCCALCSIZE\_PARAMS**](/windows/win32/api/winuser/ns-winuser-nccalcsize_params) structure contain valid destination and source area rectangles, respectively. The system combines these rectangles to calculate the area of the window to be preserved. The system copies any part of the window image that is within the source rectangle and clips the image to the destination rectangle. Both rectangles are in parent-relative or screen-relative coordinates. This flag cannot be combined with any other flags. <br/> This return value allows an application to implement more elaborate client-area preservation strategies, such as centering or preserving a subset of the client area.<br/> |</para>
            </returns>
            <remarks>
            <para>The window may be redrawn, depending on whether the [CS\_HREDRAW](about-window-classes.md) or CS\_VREDRAW class style is specified. This is the default, backward-compatible processing of this message by the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function (in addition to the usual client rectangle calculation described in the preceding table). When *wParam* is **TRUE**, simply returning 0 without processing the [**NCCALCSIZE\_PARAMS**](/windows/win32/api/winuser/ns-winuser-nccalcsize_params) rectangles will cause the client area to resize to the size of the window, including the window frame. This will remove the window frame and caption items from your window, leaving only the client area displayed. Starting with Windows Vista, removing the standard frame by simply returning 0 when the *wParam* is **TRUE** does not affect frames that are extended into the client area using the [**DwmExtendFrameIntoClientArea**](/windows/win32/api/dwmapi/nf-dwmapi-dwmextendframeintoclientarea) function. Only the standard frame will be removed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-nccalcsize#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCHITTEST">
            <summary>Sent to a window in order to determine what part of the window corresponds to a particular screen coordinate.</summary>
            <returns>
            <para>The return value of the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function is one of the following values, indicating the position of the cursor hot spot.</para>
            <para>| Return code/value                                                                                                                                    | Description                                                                                                                                                                                                        | |------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**HTBORDER**</dt> <dt>18</dt> </dl>      | In the border of a window that does not have a sizing border.<br/>                                                                                                                                           | | <dl> <dt>**HTBOTTOM**</dt> <dt>15</dt> </dl>      | In the lower-horizontal border of a resizable window (the user can click the mouse to resize the window vertically).<br/>                                                                                    | | <dl> <dt>**HTBOTTOMLEFT**</dt> <dt>16</dt> </dl>  | In the lower-left corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).<br/>                                                                              | | <dl> <dt>**HTBOTTOMRIGHT**</dt> <dt>17</dt> </dl> | In the lower-right corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).<br/>                                                                             | | <dl> <dt>**HTCAPTION**</dt> <dt>2</dt> </dl>      | In a title bar.<br/>                                                                                                                                                                                         | | <dl> <dt>**HTCLIENT**</dt> <dt>1</dt> </dl>       | In a client area.<br/>                                                                                                                                                                                       | | <dl> <dt>**HTCLOSE**</dt> <dt>20</dt> </dl>       | In a **Close** button.<br/>                                                                                                                                                                                  | | <dl> <dt>**HTERROR**</dt> <dt>-2</dt> </dl>       | On the screen background or on a dividing line between windows (same as **HTNOWHERE**, except that the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function produces a system beep to indicate an error).<br/> | | <dl> <dt>**HTGROWBOX**</dt> <dt>4</dt> </dl>      | In a size box (same as **HTSIZE**).<br/>                                                                                                                                                                     | | <dl> <dt>**HTHELP**</dt> <dt>21</dt> </dl>        | In a **Help** button.<br/>                                                                                                                                                                                   | | <dl> <dt>**HTHSCROLL**</dt> <dt>6</dt> </dl>      | In a horizontal scroll bar.<br/>                                                                                                                                                                             | | <dl> <dt>**HTLEFT**</dt> <dt>10</dt> </dl>        | In the left border of a resizable window (the user can click the mouse to resize the window horizontally).<br/>                                                                                              | | <dl> <dt>**HTMENU**</dt> <dt>5</dt> </dl>         | In a menu.<br/>                                                                                                                                                                                              | | <dl> <dt>**HTMAXBUTTON**</dt> <dt>9</dt> </dl>    | In a **Maximize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTMINBUTTON**</dt> <dt>8</dt> </dl>    | In a **Minimize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTNOWHERE**</dt> <dt>0</dt> </dl>      | On the screen background or on a dividing line between windows.<br/>                                                                                                                                         | | <dl> <dt>**HTREDUCE**</dt> <dt>8</dt> </dl>       | In a **Minimize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTRIGHT**</dt> <dt>11</dt> </dl>       | In the right border of a resizable window (the user can click the mouse to resize the window horizontally).<br/>                                                                                             | | <dl> <dt>**HTSIZE**</dt> <dt>4</dt> </dl>         | In a size box (same as **HTGROWBOX**).<br/>                                                                                                                                                                  | | <dl> <dt>**HTSYSMENU**</dt> <dt>3</dt> </dl>      | In a window menu or in a **Close** button in a child window.<br/>                                                                                                                                            | | <dl> <dt>**HTTOP**</dt> <dt>12</dt> </dl>         | In the upper-horizontal border of a window.<br/>                                                                                                                                                             | | <dl> <dt>**HTTOPLEFT**</dt> <dt>13</dt> </dl>     | In the upper-left corner of a window border.<br/>                                                                                                                                                            | | <dl> <dt>**HTTOPRIGHT**</dt> <dt>14</dt> </dl>    | In the upper-right corner of a window border.<br/>                                                                                                                                                           | | <dl> <dt>**HTTRANSPARENT**</dt> <dt>-1</dt> </dl> | In a window currently covered by another window in the same thread (the message will be sent to underlying windows in the same thread until one of them returns a code that is not **HTTRANSPARENT**).<br/>  | | <dl> <dt>**HTVSCROLL**</dt> <dt>7</dt> </dl>      | In the vertical scroll bar.<br/>                                                                                                                                                                             | | <dl> <dt>**HTZOOM**</dt> <dt>9</dt> </dl>         | In a **Maximize** button.<br/>                                                                                                                                                                               |</para>
            </returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nchittest#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCPAINT">
            <summary>The WM\_NCPAINT message is sent to a window when its frame must be painted.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function paints the window frame. An application can intercept the **WM\_NCPAINT** message and paint its own custom window frame. The clipping region for a window is always rectangular, even if the shape of the frame is altered. The *wParam* value can be passed to [**GetDCEx**](/windows/desktop/api/Winuser/nf-winuser-getdcex) as in the following example.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-ncpaint#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCACTIVATE">
            <summary>Sent to a window when its nonclient area needs to be changed to indicate an active or inactive state.</summary>
            <returns>
            <para>Type: **LRESULT** When the *wParam* parameter is **FALSE**, an application should return **TRUE** to indicate that the system should proceed with the default processing, or it should return **FALSE** to prevent the change. When *wParam* is **TRUE**, the return value is ignored.</para>
            </returns>
            <remarks>
            <para>Processing messages related to the nonclient area of a standard window is not recommended, because the application must be able to draw all the required parts of the nonclient area for the window. If an application does process this message, it must return **TRUE** to direct the system to complete the change of active window. If the window is minimized when this message is received, the application should pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function draws the title bar or icon title in its active colors when the *wParam* parameter is **TRUE** and in its inactive colors when *wParam* is **FALSE**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-ncactivate#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETDLGCODE">
            <summary>Sent to the window procedure associated with a control.</summary>
            <returns>
            <para>The return value is one or more of the following values, indicating which type of input the application processes.</para>
            <para>| Return code/value                                                                                                                                                | Description                                                                                                                | |------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**DLGC\_BUTTON**</dt> <dt>0x2000</dt> </dl>          | Button.<br/>                                                                                                         | | <dl> <dt>**DLGC\_DEFPUSHBUTTON**</dt> <dt>0x0010</dt> </dl>   | Default push button.<br/>                                                                                            | | <dl> <dt>**DLGC\_HASSETSEL**</dt> <dt>0x0008</dt> </dl>       | [**EM\_SETSEL**](/windows/desktop/Controls/em-setsel) messages.<br/>                                                           | | <dl> <dt>**DLGC\_RADIOBUTTON**</dt> <dt>0x0040</dt> </dl>     | Radio button.<br/>                                                                                                   | | <dl> <dt>**DLGC\_STATIC**</dt> <dt>0x0100</dt> </dl>          | Static control.<br/>                                                                                                 | | <dl> <dt>**DLGC\_UNDEFPUSHBUTTON**</dt> <dt>0x0020</dt> </dl> | Non-default push button.<br/>                                                                                        | | <dl> <dt>**DLGC\_WANTALLKEYS**</dt> <dt>0x0004</dt> </dl>     | All keyboard input.<br/>                                                                                             | | <dl> <dt>**DLGC\_WANTARROWS**</dt> <dt>0x0001</dt> </dl>      | Direction keys.<br/>                                                                                                 | | <dl> <dt>**DLGC\_WANTCHARS**</dt> <dt>0x0080</dt> </dl>       | [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) messages.<br/>                                                                      | | <dl> <dt>**DLGC\_WANTMESSAGE**</dt> <dt>0x0004</dt> </dl>     | All keyboard input (the application passes this message in the [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure to the control).<br/> | | <dl> <dt>**DLGC\_WANTTAB**</dt> <dt>0x0002</dt> </dl>         | TAB key.<br/>                                                                                                        |</para>
            </returns>
            <remarks>
            <para>Although the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function always returns zero in response to the **WM\_GETDLGCODE** message, the window procedure for the predefined control classes return a code appropriate for each class. The **WM\_GETDLGCODE** message and the returned values are useful only with user-defined dialog box controls or standard controls modified by subclassing.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-getdlgcode#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYNCPAINT">
            <summary>The WM\_SYNCPAINT message is used to synchronize painting while avoiding linking independent GUI threads.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>When a window has been hidden, shown, moved, or sized, the system may determine that it is necessary to send a **WM\_SYNCPAINT** message to the top-level windows of other threads. Applications must pass **WM\_SYNCPAINT** to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  for processing. The **DefWindowProc** function will send a [**WM\_NCPAINT**](wm-ncpaint.md) message to the window procedure if the window frame must be painted and send a [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message if the window background must be erased.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMOUSEMOVE">
            <summary>Posted to a window when the cursor is moved within the nonclient area of the window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>If it is appropriate to do so, the system sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmousemove#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCLBUTTONDOWN">
            <summary>Posted when the user presses the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function tests the specified point to find the location of the cursor and performs the appropriate action. If appropriate, **DefWindowProc** sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttondown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCLBUTTONUP">
            <summary>Posted when the user releases the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function tests the specified point to find out the location of the cursor and performs the appropriate action. If appropriate, **DefWindowProc** sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttonup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCLBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttondblclk#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCRBUTTONDOWN">
            <summary>Posted when the user presses the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttondown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCRBUTTONUP">
            <summary>Posted when the user releases the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttonup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCRBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window need not have the **CS\_DBLCLKS** style to receive **WM\_NCRBUTTONDBLCLK** messages. The system generates a **WM\_NCRBUTTONDBLCLK** message when the user presses, releases, and again presses the right mouse button within the system's double-click time limit. Double-clicking the right mouse button actually generates four messages: [**WM\_NCRBUTTONDOWN**](wm-ncrbuttondown.md), [**WM\_NCRBUTTONUP**](wm-ncrbuttonup.md), **WM\_NCRBUTTONDBLCLK**, and **WM\_NCRBUTTONUP** again. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttondblclk#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMBUTTONDOWN">
            <summary>Posted when the user presses the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttondown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMBUTTONUP">
            <summary>Posted when the user releases the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttonup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window need not have the **CS\_DBLCLKS** style to receive **WM\_NCMBUTTONDBLCLK** messages. The system generates a **WM\_NCMBUTTONDBLCLK** message when the user presses, releases, and again presses the middle mouse button within the system's double-click time limit. Double-clicking the middle mouse button actually generates four messages: [**WM\_NCMBUTTONDOWN**](wm-ncmbuttondown.md), [**WM\_NCMBUTTONUP**](wm-ncmbuttonup.md), **WM\_NCMBUTTONDBLCLK**, and **WM\_NCMBUTTONUP** again. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttondblclk#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCXBUTTONDOWN">
            <summary>Posted when the user presses the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttondown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCXBUTTONUP">
            <summary>Posted when the user releases the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttonup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCXBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttondblclk#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INPUT_DEVICE_CHANGE">
            <summary>Sent to the window that registered to receive raw input. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-input-device-change">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INPUT">
            <summary>Sent to the window that is getting raw input. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>Raw input is available only when the application calls [**RegisterRawInputDevices**](/windows/win32/api/winuser/nf-winuser-registerrawinputdevices) with valid device specifications.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_KEYDOWN">
            <summary>Posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>If the F10 key is pressed, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets an internal flag. When **DefWindowProc** receives the [**WM\_KEYUP**](wm-keyup.md) message, the function checks whether the internal flag is set and, if so, sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window. The **WM\_SYSCOMMAND** parameter of the message is set to SC\_KEYMENU. Because of the autorepeat feature, more than one **WM\_KEYDOWN** message may be posted before a [**WM\_KEYUP**](wm-keyup.md) message is posted. The previous key state (bit 30) can be used to determine whether the **WM\_KEYDOWN** message indicates the first down transition or a repeated down transition. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. Applications must pass *wParam* to [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) without altering it at all.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-keydown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_KEYUP">
            <summary>Posted to the window with the keyboard focus when a nonsystem key is released. A nonsystem key is a key that is pressed when the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window if the F10 key or the ALT key was released. The *wParam* parameter of the message is set to SC\_KEYMENU. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. Applications must pass *wParam* to [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) without altering it at all.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-keyup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_KEYDOWN message is translated by the TranslateMessage function. The WM\_CHAR message contains the character code of the key that was pressed.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_CHAR** message uses UTF-16 (16-bit Unicode Transformation Format) code units in its **wParam** if the Unicode version of the [**RegisterClass**](/windows/win32/api/winuser/nf-winuser-registerclassw) function was used to register the window class. Otherwise, the system provides characters in the current process code page, which can be set to UTF-8 in Windows Version 1903 (May 2019 Update) and newer. For more information, see [Registering Window Classes](/windows/win32/intl/registering-window-classes) and [Use UTF-8 code pages in Windows apps](/windows/apps/design/globalizing/use-utf8-code-page). Starting with Windows Vista, **WM\_CHAR** message can send [UTF-16 surrogate pairs](/windows/win32/intl/surrogates-and-supplementary-characters) to Unicode windows. Use the [IS_HIGH_SURROGATE](/windows/win32/api/Winnls/nf-winnls-is_high_surrogate), [IS_LOW_SURROGATE](/windows/win32/api/winnls/nf-winnls-is_low_surrogate), and [IS_SURROGATE_PAIR](/windows/win32/api/winnls/nf-winnls-is_surrogate_pair) macros to detect such cases, if necessary. There is not necessarily a one-to-one correspondence between keys pressed and character messages generated, and so the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_CHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter. The [**WM\_UNICHAR**](wm-unichar.md) message is the same as **WM\_CHAR**, except it uses UTF-32. It is designed to send or post Unicode characters to ANSI windows, and it can handle Unicode Supplementary Plane characters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-char#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DEADCHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_KEYUP message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_DEADCHAR** message typically is used by applications to give the user feedback about each key pressed. For example, an application can display the accent in the current character position without moving the caret. Because there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_DEADCHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-deadchar#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSKEYDOWN">
            <summary>Posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar) or holds down the ALT key and then presses another key.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function examines the specified key and generates a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message if the key is either TAB or ENTER. When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a normal key message instead of a character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. Because of automatic repeat, more than one **WM\_SYSKEYDOWN** message may occur before a [**WM\_SYSKEYUP**](wm-syskeyup.md) message is sent. The previous key state (bit 30) can be used to determine whether the **WM\_SYSKEYDOWN** message indicates the first down transition or a repeated down transition. For enhanced 101- and 102-key keyboards, enhanced keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. This message is also sent whenever the user presses the F10 key without the ALT key.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-syskeydown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSKEYUP">
            <summary>Posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window if the F10 key or the ALT key was released. The *wParam* parameter of the message is set to **SC\_KEYMENU**. When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a normal key message instead of a character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. For non-U.S. enhanced 102-key keyboards, the right ALT key is handled as a CTRL+ALT key. The following table shows the sequence of messages that result when the user presses and releases this key.</para>
            <para>| Message                           | Virtual-key code | |-----------------------------------|------------------| | [**WM\_KEYDOWN**](wm-keydown.md) | **VK\_CONTROL**  | | [**WM\_KEYDOWN**](wm-keydown.md) | **VK\_MENU**     | | [**WM\_KEYUP**](wm-keyup.md)     | **VK\_CONTROL**  | | **WM\_SYSKEYUP**                  | **VK\_MENU**     |</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-syskeyup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSCHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_SYSKEYDOWN message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/Winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a standard key message instead of a system character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; the PRINT SCRN key; the BREAK key; the NUMLOCK key; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-syschar#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSDEADCHAR">
            <summary>Sent to the window with the keyboard focus when a WM\_SYSKEYDOWN message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_STARTCOMPOSITION">
            <summary>Sent immediately before the IME generates the composition string as a result of a keystroke. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>This message is a notification to an IME window to open its composition window. An application should process this message if it displays composition characters itself. If an application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function processes the message by passing it to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-startcomposition#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_ENDCOMPOSITION">
            <summary>Sent to an application when the IME ends composition. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>An application should process this message if it displays composition characters itself. If the application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing it to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-endcomposition#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_COMPOSITION">
            <summary>Sent to an application when the IME changes composition status as a result of a keystroke. A window receives this message through its WindowProc function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>An application should process this message if it displays composition characters itself. Otherwise, it should send the message to the IME window. If the application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing it to the default IME window. The IME window processes this message by updating its appearance based on the change flag specified. An application can call [**ImmGetCompositionString**](/windows/desktop/api/Imm/nf-imm-immgetcompositionstringa) to retrieve the new composition status. If none of the GCS\_ values are set, the message indicates that the current composition has been canceled and applications that draw the composition string should delete the string.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-composition#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INITDIALOG">
            <summary>Sent to the dialog box procedure immediately before a dialog box is displayed. Dialog box procedures typically use this message to initialize controls and carry out any other initialization tasks that affect the appearance of the dialog box.</summary>
            <returns>
            <para>The dialog box procedure should return **TRUE** to direct the system to set the keyboard focus to the control specified by *wParam*. Otherwise, it should return **FALSE** to prevent the system from setting the default keyboard focus. The dialog box procedure should return the value directly. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            </returns>
            <remarks>
            <para>The control to receive the default keyboard focus is always the first control in the dialog box that is visible, not disabled, and that has the **WS\_TABSTOP** style. When the dialog box procedure returns **TRUE**, the system checks the control to ensure that the procedure has not disabled it. If it has been disabled, the system sets the keyboard focus to the next control that is visible, not disabled, and has the **WS\_TABSTOP**. An application can return **FALSE** only if it has set the keyboard focus to one of the controls of the dialog box.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-initdialog#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COMMAND">
            <summary>Sent when the user selects a command item from a menu, when a control sends a notification message to its parent window, or when an accelerator keystroke is translated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use of the *wParam* and *lParam* parameters are summarized here.</para>
            <para>| Message Source | wParam (high word)                | wParam (low word)                | lParam                       | |----------------|-----------------------------------|----------------------------------|------------------------------| | Menu           | 0                                 | Menu identifier (IDM\_\*)        | 0                            | | Accelerator    | 1                                 | Accelerator identifier (IDM\_\*) | 0                            | | Control        | Control-defined notification code | Control identifier               | Handle to the control window |</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-command#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSCOMMAND">
            <summary>A window receives this message when the user chooses a command from the Window menu (formerly known as the system or control menu) or when the user chooses the maximize button, minimize button, restore button, or close button.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>To obtain the position coordinates in screen coordinates, use the following code:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-syscommand#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TIMER">
            <summary>Posted to the installing thread's message queue when a timer expires. The message is posted by the GetMessage or PeekMessage function.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>You can process the message by providing a **WM\_TIMER** case in the window procedure. Otherwise, [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage) will call the [*TimerProc*](/windows/win32/api/winuser/nc-winuser-timerproc) callback function specified in the call to the [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) function used to install the timer. The **WM\_TIMER** message is a low-priority message. The [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) and [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) functions post this message only when no other higher-priority messages are in the thread's message queue.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-timer#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_HSCROLL">
            <summary>The WM\_HSCROLL message is sent to a window when a scroll event occurs in the window's standard horizontal scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The SB\_THUMBTRACK request code is typically used by applications that provide feedback as the user drags the scroll box. If an application scrolls the content of the window, it must also reset the position of the scroll box by using the [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos) function. Note that the **WM\_HSCROLL** message carries only 16 bits of scroll box position data. Thus, applications that rely solely on **WM\_HSCROLL** (and [**WM\_VSCROLL**](wm-vscroll.md)) for scroll position data have a practical maximum position value of 65,535. However, because the [**SetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-setscrollinfo), [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos), [**SetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-setscrollrange), [**GetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-getscrollinfo), [**GetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-getscrollpos), and [**GetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-getscrollrange) functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the **WM\_HSCROLL** and [**WM\_VSCROLL**](wm-vscroll.md) messages. See **GetScrollInfo** for a description of the technique.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-hscroll#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_VSCROLL">
            <summary>The WM\_VSCROLL message is sent to a window when a scroll event occurs in the window's standard vertical scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The SB\_THUMBTRACK request code is typically used by applications that provide feedback as the user drags the scroll box. If an application scrolls the content of the window, it must also reset the position of the scroll box by using the [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos) function. Note that the **WM\_VSCROLL** message carries only 16 bits of scroll box position data. Thus, applications that rely solely on **WM\_VSCROLL** (and [**WM\_HSCROLL**](wm-hscroll.md)) for scroll position data have a practical maximum position value of 65,535. However, because the [**SetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-setscrollinfo), [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos), [**SetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-setscrollrange), [**GetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-getscrollinfo), [**GetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-getscrollpos), and [**GetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-getscrollrange) functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the [**WM\_HSCROLL**](wm-hscroll.md) and **WM\_VSCROLL** messages. See **GetScrollInfo** for a description of the technique.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-vscroll#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INITMENU">
            <summary>Sent when a menu is about to become active.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>A **WM\_INITMENU** message is sent only when a menu is first accessed; only one **WM\_INITMENU** message is generated for each access. For example, moving the mouse across several menu items while holding down the button does not generate new messages. **WM\_INITMENU** does not provide information about menu items.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INITMENUPOPUP">
            <summary>WM_INITMENUPOPUP message - Sent when a drop-down menu or submenu is about to become active. This allows an application to modify the menu before it is displayed, without changing the entire menu.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-initmenupopup">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GESTURE">
            <summary>Passes information about a gesture.</summary>
            <returns>
            <para>If an application processes this message, it should return 0. If the application does not process the message, it must call [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). Not doing so will cause the application to leak memory because the touch input handle will not be closed and associated process memory will not be freed.</para>
            </returns>
            <remarks>
            <para>The following table lists the supported gesture commands.</para>
            <para>| Gesture ID            | Value (*dwID*) | Description                                                                                                                                                                                                                                                                          | |-----------------------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | **GID\_BEGIN**        | 1              | Indicates a generic gesture is beginning.                                                                                                                                                                                                                                            | | **GID\_END**          | 2              | Indicates a generic gesture end.                                                                                                                                                                                                                                                     | | **GID\_ZOOM**         | 3              | Indicates zoom start, zoom move, or zoom stop. The first **GID\_ZOOM** command message begins a zoom but does not cause any zooming. The second **GID\_ZOOM** command triggers a zoom relative to the state contained in the first **GID\_ZOOM**.                                    | | **GID\_PAN**          | 4              | Indicates pan move or pan start. The first **GID\_PAN** command indicates a pan start but does not perform any panning. With the second **GID\_PAN** command message, the application will begin panning.                                                                            | | **GID\_ROTATE**       | 5              | Indicates rotate move or rotate start. The first **GID\_ROTATE** command message indicates a rotate move or rotate start but will not rotate. The second **GID\_ROTATE** command message will trigger a rotation operation relative to state contained in the first **GID\_ROTATE**. | | **GID\_TWOFINGERTAP** | 6              | Indicates two-finger tap gesture.                                                                                                                                                                                                                                                    | | **GID\_PRESSANDTAP**  | 7              | Indicates the press and tap gesture.                                                                                                                                                                                                                                                 |</para>
            <para>> [!Note] > In order to enable legacy support, messages with the **GID\_BEGIN** and **GID\_END** gesture commands need to be forwarded using [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            <para>The following table indicates the gesture arguments passed in the *lParam* and *wParam* parameters.</para>
            <para>| Gesture ID            | Gesture        | *ullArgument*                                                                                                                                                                                                                                                                                                                                                                                            | *ptsLocation* in [**GestureInfo**](/windows/desktop/api/winuser/nf-winuser-getgestureinfo) structure                                                  | |-----------------------|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------| | **GID\_ZOOM**         | Zoom In/Out    | Indicates the distance between the two points.                                                                                                                                                                                                                                                                                                                                                           | Indicates the center of the zoom.                                                                                 | | **GID\_PAN**          | Pan            | Indicates the distance between the two points.                                                                                                                                                                                                                                                                                                                                                           | Indicates the current position of the pan.                                                                        | | **GID\_ROTATE**       | Rotate (pivot) | Indicates the angle of rotation if the **GF\_BEGIN** flag is set. Otherwise, this is the angle change since the rotation has started. This is signed to indicate the direction of the rotation. Use the [**GID\_ROTATE\_ANGLE\_FROM\_ARGUMENT**](/windows/desktop/api/winuser/nf-winuser-gid_rotate_angle_from_argument) and [**GID\_ROTATE\_ANGLE\_TO\_ARGUMENT**](/windows/desktop/api/winuser/nf-winuser-gid_rotate_angle_to_argument) macros to get and set the angle value. | This indicates the center of the rotation which is the stationary point that the target object is rotated around. | | **GID\_TWOFINGERTAP** | Two-finger Tap | Indicates the distance between the two fingers.                                                                                                                                                                                                                                                                                                                                                          | Indicates the center of the two fingers.                                                                          | | **GID\_PRESSANDTAP**  | Press and Tap  | Indicates the delta between the first finger and the second finger. This value is stored in the lower 32 bits of the *ullArgument* in a **POINT** structure.                                                                                                                                                                                                                                             | Indicates the position that the first finger comes down on.                                                       |</para>
            <para>> [!Note] > All distances and positions are provided in physical screen coordinates.</para>
            <para>> [!Note] > The *dwID* and *ullArgument* parameters should only be considered to be accompanying the GID\_\* commands and should not be altered by applications.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/wintouch/wm-gesture#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GESTURENOTIFY">
            <summary>Gives you a chance to set the gesture configuration.</summary>
            <returns>A value should be returned from [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca).</returns>
            <remarks>
            <para>When the **WM\_GESTURENOTIFY** message is received, the application can use [**SetGestureConfig**](/windows/desktop/api/winuser/nf-winuser-setgestureconfig) to specify the gestures to receive. This message should always be bubbled up using the [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca) function. > [!Note] > Handling the **WM\_GESTURENOTIFY** message will change the gesture configuration for the lifetime of the Window, not just for the next gesture.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/wintouch/wm-gesturenotify#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUSELECT">
            <summary>Sent to a menu's owner window when the user selects a menu item.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>If the high-order word of *wParam* contains 0xFFFF and the *lParam* parameter contains **NULL**, the system has closed the menu. Do not use the value  1 for the high-order word of *wParam*, because this value is specified as (**UINT**) [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85))(*wParam*). If the value is 0xFFFF, it would be interpreted as 0x0000FFFF, not  1, because of the cast to a **UINT**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menuselect#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUCHAR">
            <summary>Sent when a menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key. This message is sent to the window that owns the menu.</summary>
            <returns>
            <para>An application that processes this message should return one of the following values in the high-order word of the return value.</para>
            <para>| Return code/value                                                                                                                                  | Description                                                                                                                                                                              | |----------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**MNC\_CLOSE**</dt> <dt>1</dt> </dl>   | Informs the system that it should close the active menu.<br/>                                                                                                                      | | <dl> <dt>**MNC\_EXECUTE**</dt> <dt>2</dt> </dl> | Informs the system that it should choose the item specified in the low-order word of the return value. The owner window receives a [**WM\_COMMAND**](wm-command.md) message.<br/> | | <dl> <dt>**MNC\_IGNORE**</dt> <dt>0</dt> </dl>  | Informs the system that it should discard the character the user pressed and create a short beep on the system speaker.<br/>                                                       | | <dl> <dt>**MNC\_SELECT**</dt> <dt>3</dt> </dl>  | Informs the system that it should select the item specified in the low-order word of the return value. <br/>                                                                       |</para>
            </returns>
            <remarks>
            <para>The low-order word is ignored if the high-order word contains 0 or 1. An application should process this message when an accelerator is used to select a menu item that displays a bitmap.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menuchar#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENTERIDLE">
            <summary>Sent to the owner window of a modal dialog box or menu that is entering an idle state. A modal dialog box or menu enters an idle state when no messages are waiting in its queue after it has processed one or more previous messages.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>You can suppress the **WM\_ENTERIDLE** message for a dialog box by creating the dialog box with the **DS\_NOIDLEMSG** style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENURBUTTONUP">
            <summary>Sent when the user releases the right mouse button while the cursor is on a menu item.</summary>
            <remarks>The **WM\_MENURBUTTONUP** message allows applications to provide a context-sensitive menu also known as a shortcut menu for the menu item specified in this message. To display a context-sensitive menu for a menu item, call the [**TrackPopupMenuEx**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenuex) function with **TPM\_RECURSE**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUDRAG">
            <summary>Sent to the owner of a drag-and-drop menu when the user drags a menu item.</summary>
            <returns>
            <para>The application should return one of the following values.</para>
            <para>| Return code/value                                                                                                                                   | Description                                                                           | |-----------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------| | <dl> <dt>**MND\_CONTINUE**</dt> <dt>0</dt> </dl> | Menu should remain active. If the mouse is released, it should be ignored.<br/> | | <dl> <dt>**MND\_ENDMENU**</dt> <dt>1</dt> </dl>  | Menu should be ended.<br/>                                                      |</para>
            </returns>
            <remarks>
            <para>The application can call the [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) function in response to this message. To create a drag-and-drop menu, call [**SetMenuInfo**](/windows/desktop/api/Winuser/nf-winuser-setmenuinfo) with **MNS\_DRAGDROP**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menudrag#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUGETOBJECT">
            <summary>Sent to the owner of a drag-and-drop menu when the mouse cursor enters a menu item or moves from the center of the item to the top or bottom of the item.</summary>
            <returns>
            <para>The application should return one of the following values.</para>
            <para>| Return code/value                                                                                                                                                | Description                                                                                                            | |------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**MNGO\_NOERROR**</dt> <dt>0x00000001</dt> </dl>     | An interface pointer was returned in the **pvObj** member of [**MENUGETOBJECTINFO**](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo)<br/> | | <dl> <dt>**MNGO\_NOINTERFACE**</dt> <dt>0x00000000</dt> </dl> | The interface is not supported.<br/>                                                                             |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menugetobject">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_UNINITMENUPOPUP">
            <summary>Sent when a drop-down menu or submenu has been destroyed.</summary>
            <remarks>If an application receives a [**WM\_INITMENUPOPUP**](wm-initmenupopup.md) message, it will receive a **WM\_UNINITMENUPOPUP** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUCOMMAND">
            <summary>Sent when the user makes a selection from a menu.</summary>
            <remarks>
            <para>The **WM\_MENUCOMMAND** message gives you a handle to the menu so you can access the menu data in the [**MENUINFO**](/windows/win32/api/winuser/ns-winuser-menuinfo) structure and also gives you the index of the selected item, which is typically what applications need. In contrast, the [**WM\_COMMAND**](wm-command.md) message gives you the menu item identifier. The **WM\_MENUCOMMAND** message is sent only for menus that are defined with the **MNS\_NOTIFYBYPOS** flag set in the **dwStyle** member of the [**MENUINFO**](/windows/win32/api/winuser/ns-winuser-menuinfo) structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menucommand#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHANGEUISTATE">
            <summary>An application sends the WM\_CHANGEUISTATE message to indicate that the UI state should be changed.</summary>
            <remarks>
            <para>A window should send this message to itself or its parent when it must change the UI state elements of all windows in the same hierarchy. The window procedure must let [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) process this message so that the entire window tree has a consistent UI state. When the top-level window receives the **WM\_CHANGEUISTATE** message, it sends a [**WM\_UPDATEUISTATE**](wm-updateuistate.md) message with the same parameters to all child windows. When the system processes the **WM\_UPDATEUISTATE** message, it makes the change in the UI state. If the low-order word of *wParam* is UIS\_INITIALIZE, the system will send the [**WM\_UPDATEUISTATE**](wm-updateuistate.md) message with a UI state based on the last input event. For example, if the last input came from the mouse, the system will hide the keyboard cues. And, if the last input came from the keyboard, the system will show the keyboard cues. If the state that results from processing **WM\_CHANGEUISTATE** is the same as the old state, [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) does not send this message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-changeuistate#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_UPDATEUISTATE">
            <summary>An application sends the WM\_UPDATEUISTATE message to change the UI state for the specified window and all its child windows.</summary>
            <remarks>
            <para>A window should send this message to change the UI state of all its child windows. In contrast to the [**WM\_CHANGEUISTATE**](wm-changeuistate.md) message, which is a notification, when [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) processes the **WM\_UPDATEUISTATE** message it changes the UI state and propagates the changes to all child windows. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function updates the UI state according to the *wParam* value. If the UI state is modified, the function sends the message to all the immediate child windows. **DefWindowProc** also sends this message when it receives a [**WM\_CHANGEUISTATE**](wm-changeuistate.md) message notifying the system that a child window intends to modify the UI state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-updateuistate#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYUISTATE">
            <summary>An application sends the WM\_QUERYUISTATE message to retrieve the UI state for a window.</summary>
            <returns>
            <para>The return value is **NULL** if the focus indicators and the keyboard accelerators are visible. Otherwise, the return value can be one or more of the following values.</para>
            <para>| Return code/value                                                                                                                                       | Description                                                                 | |---------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------| | <dl> <dt>**UISF\_ACTIVE**</dt> <dt>0x4</dt> </dl>    | A control should be drawn in the style used for active controls.<br/> | | <dl> <dt>**UISF\_HIDEACCEL**</dt> <dt>0x2</dt> </dl> | Keyboard accelerators are hidden.<br/>                                | | <dl> <dt>**UISF\_HIDEFOCUS**</dt> <dt>0x1</dt> </dl> | Focus indicators are hidden.<br/>                                     |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-queryuistate">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLOREDIT">
            <summary>An edit control that is not read-only or disabled sends the WM\_CTLCOLOREDIT message to its parent window when the control is about to be drawn.</summary>
            <returns>If an application processes this message, it must return the handle of a brush. The system uses the brush to paint the background of the edit control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the edit control. Read-only or disabled edit controls do not send the **WM\_CTLCOLOREDIT** message; instead, they send the [**WM\_CTLCOLORSTATIC**](wm-ctlcolorstatic.md) message. The **WM\_CTLCOLOREDIT** message is never sent between threads, it is only sent within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored. **Rich Edit:** This message is not supported. To set the background color for a rich edit control, use the [**EM\_SETBKGNDCOLOR**](em-setbkgndcolor.md) message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcoloredit#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORLISTBOX">
            <summary>Sent to the parent window of a list box before the system draws the list box. By responding to this message, the parent window can set the text and background colors of the list box by using the specified display device context handle.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the list box.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the list box. The **WM\_CTLCOLORLISTBOX** message is never sent between threads. It is sent only within one thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorlistbox#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORBTN">
            <summary>The WM\_CTLCOLORBTN message is sent to the parent window of a button before drawing the button. The parent window can change the button's text and background colors. However, only owner-drawn buttons respond to the parent window processing this message.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the button.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the button. Buttons with the [**BS\_PUSHBUTTON**](button-styles.md), [**BS\_DEFPUSHBUTTON**](button-styles.md), or [**BS\_PUSHLIKE**](button-styles.md) styles do not use the returned brush. Buttons with these styles are always drawn with the default system colors. Drawing push buttons requires several different brushes-face, highlight, and shadow-but the **WM\_CTLCOLORBTN** message allows only one brush to be returned. To provide a custom appearance for push buttons, use an owner-drawn button. For more information, see [Creating Owner-Drawn Controls](user-controls-intro.md). The **WM\_CTLCOLORBTN** message is never sent between threads. It is sent only within one thread. The text color of a check box or radio button applies to the box or button, its check mark, and the text. The focus rectangle for these buttons remains the system default color (typically black). The text color of a group box applies to the text but not to the line that defines the box. The text color of a push button applies only to its focus rectangle; it does not affect the color of the text. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorbtn#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORDLG">
            <summary>Sent to a dialog box before the system draws the dialog box. By responding to this message, the dialog box can set its text and background colors using the specified display device context handle.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the dialog box.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the dialog box. The system does not automatically destroy the returned brush. It is the application's responsibility to destroy the brush when it is no longer needed. The **WM\_CTLCOLORDLG** message is never sent between threads. It is sent only within one thread. Note that the **WM\_CTLCOLORDLG** message is sent to the dialog box itself; all of the other **WM\_CTLCOLOR\*** messages are sent to the owner of the control. If a dialog box procedure handles this message, it should cast the desired return value to an **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-ctlcolordlg#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORSCROLLBAR">
            <summary>The WM\_CTLCOLORSCROLLBAR message is sent to the parent window of a scroll bar control when the control is about to be drawn.</summary>
            <returns>If an application processes this message, it must return the handle to a brush. The system uses the brush to paint the background of the scroll bar control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the scroll bar control. The **WM\_CTLCOLORSCROLLBAR** message is never sent between threads; it is only sent within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored. The **WM\_CTLCOLORSCROLLBAR** message is used only by child scroll bar controls. Scrollbars attached to a window (WS\_SCROLL and WS\_VSCROLL) do not generate this message. To customize the appearance of scrollbars attached to a window, use the flat scroll bar functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorscrollbar#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORSTATIC">
            <summary>A static control, or an edit control that is read-only or disabled, sends the WM\_CTLCOLORSTATIC message to its parent window when the control is about to be drawn.</summary>
            <returns>If an application processes this message, the return value is a handle to a brush that the system uses to paint the background of the static control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the static control. You can set the text background color of a disabled edit control, but you cannot set the text foreground color. The system always uses COLOR\_GRAYTEXT. Edit controls that are not read-only or disabled do not send the **WM\_CTLCOLORSTATIC** message; instead, they send the [**WM\_CTLCOLOREDIT**](wm-ctlcoloredit.md) message. The **WM\_CTLCOLORSTATIC** message is never sent between threads; it is sent only within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorstatic#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEMOVE">
            <summary>Posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor. Otherwise, the message is posted to the window that has captured the mouse.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousemove#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Windows.Win32.PInvoke.WM_LBUTTONDOWN" -->
        <member name="F:Windows.Win32.PInvoke.WM_LBUTTONUP">
            <summary>Posted when the user releases the left mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-lbuttonup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_LBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the left mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-lbuttondblclk#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RBUTTONDOWN">
            <summary>Posted when the user presses the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttondown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RBUTTONUP">
            <summary>Posted when the user releases the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttonup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Only windows that have the **CS\_DBLCLKS** style can receive **WM\_RBUTTONDBLCLK** messages, which the system generates whenever the user presses, releases, and again presses the right mouse button within the system's double-click time limit. Double-clicking the right mouse button actually generates four messages: [**WM\_RBUTTONDOWN**](wm-rbuttondown.md), [**WM\_RBUTTONUP**](wm-rbuttonup.md), **WM\_RBUTTONDBLCLK**, and **WM\_RBUTTONUP** again. Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttondblclk#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MBUTTONDOWN">
            <summary>Posted when the user presses the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttondown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MBUTTONUP">
            <summary>Posted when the user releases the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttonup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttondblclk#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEWHEEL">
            <summary>Sent to the focus window when the mouse wheel is rotated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousewheel#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_XBUTTONDOWN">
            <summary>Posted when the user presses the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttondown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_XBUTTONUP">
            <summary>Posted when the user releases the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttonup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_XBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttondblclk#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEHWHEEL">
            <summary>Sent to the active window when the mouse's horizontal scroll wheel is tilted or rotated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousehwheel#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PARENTNOTIFY">
            <summary>Sent to a window when a significant action occurs on a descendant window.</summary>
            <returns>
            <para>If the application processes this message, it returns zero. If the application does not process this message, it calls [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>This message is also sent to all ancestor windows of the child window, including the top-level window. All child windows, except those that have the **WS_EX_NOPARENTNOTIFY** extended window style, send this message to their parent windows. By default, child windows in a dialog box have the **WS_EX_NOPARENTNOTIFY** style, unless the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function is called to create the child window without this style. This notification provides the child window's ancestor windows an opportunity to examine the pointer information and, if required, capture the pointer using the pointer capture functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-parentnotify#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENTERMENULOOP">
            <summary>Notifies an application's main window procedure that a menu modal loop has been entered.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns zero.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_EXITMENULOOP">
            <summary>Notifies an application's main window procedure that a menu modal loop has been exited.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns zero.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NEXTMENU">
            <summary>Sent to an application when the right or left arrow key is used to switch between the menu bar and the system menu.</summary>
            <remarks>In responding to this message, the application can specify the menu to switch to in the **hmenuNext** member of [**MDINEXTMENU**](/windows/win32/api/winuser/ns-winuser-mdinextmenu) and the window to receive the menu notification messages in the **hwndNext** member of the **MDINEXTMENU** structure. You must set both members for the changes to take effect (they are initially **NULL**).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SIZING">
            <summary>Sent to a window that the user is resizing. By processing this message, an application can monitor the size and position of the drag rectangle and, if needed, change its size or position.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return **TRUE** if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-sizing">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAPTURECHANGED">
            <summary>Sent to the window that is losing the mouse capture.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>A window receives this message even if it calls [**ReleaseCapture**](/windows/win32/api/winuser/nf-winuser-releasecapture) itself. An application should not attempt to set the mouse capture in response to this message. When it receives this message, a window should redraw itself, if necessary, to reflect the new mouse-capture state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-capturechanged#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOVING">
            <summary>Sent to a window that the user is moving. By processing this message, an application can monitor the position of the drag rectangle and, if needed, change its position.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return **TRUE** if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-moving">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POWERBROADCAST">
            <summary>Notifies applications that a power-management event has occurred.</summary>
            <returns>An application should return **TRUE** if it processes this message.</returns>
            <remarks>
            <para>The system always sends a [PBT\_APMRESUMEAUTOMATIC](pbt-apmresumeautomatic.md) message whenever the system resumes. If the system resumes in response to user input such as pressing a key, the system also sends a **PBT\_APMRESUMESUSPEND** message after sending PBT\_APMRESUMEAUTOMATIC. **WM\_POWERBROADCAST** messages do not distinguish between different low-power states. An application can determine only that the system is entering or has resumed from a low-power state; it cannot determine the specific power state. The system records details about power state transitions in the Windows System event log. To prevent the system from transitioning to a low-power state in Windows Vista, an application must call [**SetThreadExecutionState**](/windows/desktop/api/Winbase/nf-winbase-setthreadexecutionstate) to inform the system that it is in use. The following messages are not supported on any of the operating systems specified in the Requirements section: - PBT_APMQUERYSTANDBY - PBT_APMQUERYSTANDBYFAILED - PBT_APMSTANDBY - PBT_APMRESUMESTANDBY</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Power/wm-powerbroadcast#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDICREATE">
            <summary>An application sends the WM\_MDICREATE message to a multiple-document interface (MDI) client window to create an MDI child window.</summary>
            <returns>
            <para>Type: **HWND** If the message succeeds, the return value is the handle to the new child window. If the message fails, the return value is **NULL**.</para>
            </returns>
            <remarks>
            <para>The MDI child window is created with the [**window style**](window-styles.md) bits **WS\_CHILD**, **WS\_CLIPSIBLINGS**, **WS\_CLIPCHILDREN**, **WS\_SYSMENU**, **WS\_CAPTION**, **WS\_THICKFRAME**, **WS\_MINIMIZEBOX**, and **WS\_MAXIMIZEBOX**, plus additional style bits specified in the [**MDICREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-mdicreatestructa) structure. The system adds the title of the new child window to the window menu of the frame window. An application should use this message to create all child windows of the client window. If an MDI client window receives any message that changes the activation of its child windows while the active child window is maximized, the system restores the active child window and maximizes the newly activated child window. When an MDI child window is created, the system sends the [**WM\_CREATE**](wm-create.md) message to the window. The *lParam* parameter of the **WM\_CREATE** message contains a pointer to a [**CREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-createstructa) structure. The *lpCreateParams* member of this structure contains a pointer to the [**MDICREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-mdicreatestructa) structure passed with the **WM\_MDICREATE** message that created the MDI child window. An application should not send a second **WM\_MDICREATE** message while a **WM\_MDICREATE** message is still being processed. For example, it should not send a **WM\_MDICREATE** message while an MDI child window is processing its **WM\_MDICREATE** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdicreate#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIDESTROY">
            <summary>An application sends the WM\_MDIDESTROY message to a multiple-document interface (MDI) client window to close an MDI child window.</summary>
            <returns>
            <para>Type: **zero** This message always returns zero.</para>
            </returns>
            <remarks>
            <para>This message removes the title of the MDI child window from the MDI frame window and deactivates the child window. An application should use this message to close all MDI child windows. If an MDI client window receives a message that changes the activation of its child windows and the active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdidestroy#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIACTIVATE">
            <summary>An application sends the WM\_MDIACTIVATE message to a multiple-document interface (MDI) client window to instruct the client window to activate a different MDI child window.</summary>
            <returns>
            <para>Type: **LRESULT** If an application sends this message to an MDI client window, the return value is zero. An MDI child window should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>As the client window processes this message, it sends **WM\_MDIACTIVATE** to the child window being deactivated and to the child window being activated. The message parameters received by an MDI child window are as follows: <dl> <dt> <span id="wParam"></span><span id="wparam"></span><span id="WPARAM"></span>*wParam* </dt> <dd> A handle to the MDI child window being deactivated. </dd> <dt> <span id="lParam"></span><span id="lparam"></span><span id="LPARAM"></span>*lParam* </dt> <dd> A handle to the MDI child window being activated. </dd> </dl> An MDI child window is activated independently of the MDI frame window. When the frame window becomes active, the child window last activated by using the **WM\_MDIACTIVATE** message receives the [**WM\_NCACTIVATE**](wm-ncactivate.md) message to draw an active window frame and title bar; the child window does not receive another **WM\_MDIACTIVATE** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdiactivate#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIRESTORE">
            <summary>An application sends the WM\_MDIRESTORE message to a multiple-document interface (MDI) client window to restore an MDI child window from maximized or minimized size.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdirestore">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDINEXT">
            <summary>An application sends the WM\_MDINEXT message to a multiple-document interface (MDI) client window to activate the next or previous child window.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>If an MDI client window receives any message that changes the activation of its child windows while the active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIMAXIMIZE">
            <summary>An application sends the WM\_MDIMAXIMIZE message to a multiple-document interface (MDI) client window to maximize an MDI child window.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>If an MDI client window receives any message that changes the activation of its child windows while the currently active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDITILE">
            <summary>An application sends the WM\_MDITILE message to a multiple-document interface (MDI) client window to arrange all of its MDI child windows in a tile format.</summary>
            <returns>
            <para>Type: **BOOL** If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mditile">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDICASCADE">
            <summary>An application sends the WM\_MDICASCADE message to a multiple-document interface (MDI) client window to arrange all its child windows in a cascade format.</summary>
            <returns>
            <para>Type: **BOOL** If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdicascade">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIICONARRANGE">
            <summary>An application sends the WM\_MDIICONARRANGE message to a multiple-document interface (MDI) client window to arrange all minimized MDI child windows. It does not affect child windows that are not minimized.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdiiconarrange">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIGETACTIVE">
            <summary>An application sends the WM\_MDIGETACTIVE message to a multiple-document interface (MDI) client window to retrieve the handle to the active MDI child window.</summary>
            <returns>
            <para>Type: **HWND** The return value is the handle to the active MDI child window.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdigetactive">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDISETMENU">
            <summary>An application sends the WM\_MDISETMENU message to a multiple-document interface (MDI) client window to replace the entire menu of an MDI frame window, to replace the window menu of the frame window, or both.</summary>
            <returns>
            <para>Type: **HMENU** If the message succeeds, the return value is the handle to the old frame window menu. If the message fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>After sending this message, an application must call the [**DrawMenuBar**](/windows/win32/api/winuser/nf-winuser-drawmenubar) function to update the menu bar. If this message replaces the window menu, the MDI child window menu items are removed from the previous window menu and added to the new window menu. If an MDI child window is maximized and this message replaces the MDI frame window menu, the window menu icon and restore icon are removed from the previous frame window menu and added to the new frame window menu.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdisetmenu#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENTERSIZEMOVE">
            <summary>Sent one time to a window after it enters the moving or sizing modal loop.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-entersizemove">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_EXITSIZEMOVE">
            <summary>Sent one time to a window, after it has exited the moving or sizing modal loop.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-exitsizemove">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DROPFILES">
            <summary>Sent when the user drops a file on the window of an application that has registered itself as a recipient of dropped files.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The HDROP handle is declared in Shellapi.h. You must include this header in your build to use **WM\_DROPFILES**. For further discussion of how to use drag-and-drop to transfer Shell data, see [Transferring Shell Data Using Drag-and-Drop or the Clipboard](dragdrop.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIREFRESHMENU">
            <summary>An application sends the WM\_MDIREFRESHMENU message to a multiple-document interface (MDI) client window to refresh the window menu of the MDI frame window.</summary>
            <returns>
            <para>Type: **HMENU** If the message succeeds, the return value is the handle to the frame window menu. If the message fails, the return value is **NULL**.</para>
            </returns>
            <remarks>After sending this message, an application must call the [**DrawMenuBar**](/windows/win32/api/winuser/nf-winuser-drawmenubar) function to update the menu bar.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERDEVICECHANGE">
            <summary>Sent to a window when there is a change in the settings of a monitor that has a digitizer attached to it. This message contains information regarding the scaling of the display mode.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdevicechange">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERDEVICEINRANGE">
            <summary>Sent to a window when a pointer device is detected within range of an input digitizer. This message contains information regarding the device and its proximity.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdeviceinrange">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERDEVICEOUTOFRANGE">
            <summary>Sent to a window when a pointer device has departed the range of an input digitizer. This message contains information regarding the device and its proximity.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdeviceoutofrange">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TOUCH">
            <summary>Notifies the window when one or more touch points, such as a finger or pen, touches a touch-sensitive digitizer surface.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process the message, it must call [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). Not doing so causes the application to leak memory because the touch input handle is not closed and associated process memory is not freed.</para>
            </returns>
            <remarks>**WM\_TOUCH** messages do not respect **HTTRANSPARENT** regions of windows. If a window returns **HTTRANSPARENT** in response to a **WM\_NCHITTEST** message, mouse messages go to the parent, and **WM\_TOUCH** messages go directly to the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCPOINTERUPDATE">
            <summary>Posted to provide an update on a pointer that made contact over the non-client area of a window or when a hovering uncaptured contact moves over the non-client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCPOINTERDOWN">
            <summary>Posted when a pointer makes contact over the non-client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCPOINTERUP">
            <summary>Posted when a pointer that made contact over the non-client area of a window breaks contact.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERUPDATE">
            <summary>Posted to provide an update on a pointer that made contact over the client area of a window or on a hovering uncaptured pointer over the client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A [**WM_POINTERDOWN**](wm-pointerdown.md) message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of **WM_POINTERUPDATE** messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerupdate#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERDOWN">
            <summary>Posted when a pointer makes contact over the client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired **WM_POINTERDOWN**/[**WM_POINTERUP**](wm-pointerup.md) or [**WM_POINTERENTER**](wm-pointerenter.md)/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A **WM_POINTERDOWN** message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of [**WM_POINTERUPDATE**](wm-pointerupdate.md) messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdown#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERUP">
            <summary>Posted when a pointer that made contact over the client area of a window breaks contact.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/**WM_POINTERUP** or [**WM_POINTERENTER**](wm-pointerenter.md)/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A [**WM_POINTERDOWN**](wm-pointerdown.md) message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of [**WM_POINTERUPDATE**](wm-pointerupdate.md) messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following: Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerup#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERENTER">
            <summary>Sent to a window when a new pointer enters detection range over the window (hover) or when an existing pointer moves within the boundaries of the window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>The **WM_POINTERENTER** notification can be used by a window to provide feedback to the user while the pointer is over its surface or to otherwise react to the presence of a pointer over its surface. This notification is only sent to the window that is receiving input for the pointer. The following table lists some of the situations in which this notification is sent.</para>
            <para>| Action                                                   | Flags Set                                                                                                                                         | Notifications Sent To                                 | |----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------| | A new pointer enters detection range (hover).            | [**IS_POINTER_NEW_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_new_wparam)<br/> [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_new_wparam)<br/> | Window over which the pointer enters detection range. | | A hovering pointer crosses within the window boundaries. | [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_inrange_wparam)<br/>                                                                      | Window within which the pointer has crossed.          |</para>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/[**WM_POINTERUP**](wm-pointerup.md) or **WM_POINTERENTER**/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>When inputs come from the mouse, as a result of mouse and pointer message integration, **WM_POINTERENTER** is not sent.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerenter#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERLEAVE">
            <summary>Sent to a window when a pointer leaves detection range over the window (hover) or when a pointer moves outside the boundaries of the window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>The **WM_POINTERLEAVE** notification can be used by a window to change mode or stop any feedback to the user while the pointer is over the window surface. This notification is only sent to the window that is receiving input for the pointer. The following table lists some of the situations in which this notification is sent.</para>
            <para>| Action                                        | Flags Set                                                         | Notifications Sent To                                | |-----------------------------------------------|-------------------------------------------------------------------|------------------------------------------------------| | A hovering pointer crosses window boundaries. | [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_inrange_wparam) | Window outside of whose boundary the pointer moved.  | | A pointer goes out of detection range.        | N/A                                                               | Window for which the pointer leaves detection range. |</para>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/[**WM_POINTERUP**](wm-pointerup.md) or [**WM_POINTERENTER**](wm-pointerenter.md)/**WM_POINTERLEAVE** notifications.</para>
            <para>If contact is maintained with the input digitizer and the pointer moves outside the window, **WM_POINTERLEAVE** is not generated. **WM_POINTERLEAVE** is generated only when a hovering pointer crosses window boundaries or contact is terminated. **WM_POINTERLEAVE** is posted to the posted message queue if the input is originated from a mouse device.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerleave#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERACTIVATE">
            <summary>Sent to an inactive window when a primary pointer generates a WM_POINTERDOWN over the window.</summary>
            <returns>
            <para>If an application processes this message, it should return one of the values described in the Remarks section. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>An application can handle this message and return one of the following values to determine how the system processes the activation and the activating input: -   PA_ACTIVATE -   PA_NOACTIVATE It is important to note that, when the user is interacting with the system with multiple simultaneous pointers, the activation opportunity that the **WM_POINTERACTIVATE** message represents is available to applications only for the first of those pointers. Applications should, therefore, be aware that they may still receive input from pointers while they are inactive. If the application does not handle this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) passes the message to the parent window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointeractivate#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERCAPTURECHANGED">
            <summary>Sent to a window that is losing capture of an input pointer.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>A window should use this notification to stop processing subsequent messages and initiate any cleanup required for the pointer being lost. Processing of gestures associated with the pointer should also be terminated (for example, by calling [**StopInteractionContext**](/windows/win32/api/interactioncontext/nf-interactioncontext-stopinteractioncontext)) and remaining contacts re-associated with the window. Typically, if a window receives the **WM_POINTERCAPTURECHANGED** notification, no subsequent notifications related to the input pointer are received. Because of this, do not depend on paired notifications such as [**WM_POINTERENTER**](wm-pointerenter.md) and [**WM_POINTERLEAVE**](wm-pointerleave.md). **WM_POINTERCAPTURECHANGED** does not include [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) data. Other than the [**POINTER_FLAG_CAPTURECHANGED**](pointer-flags-contants.md) flag being set, the data returned by [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) (or any variant) is identical to that returned prior to the notification. If the application does not process this notification, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may generate one or more [**WM_GESTURE**](../wintouch/wm-gesture.md) messages or, if a gesture is not recognized, **DefWindowProc** may generate mouse input. If an application selectively consumes some pointer input and passes the rest to [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca), the resulting behavior is undefined.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointercapturechanged#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TOUCHHITTESTING">
            <summary>Sent to a window on a touch down in order to determine the most probable touch target.</summary>
            <returns>
            <para>If one or more elements are within the touch contact area, an application should return the result of [**PackTouchHitTestingProximityEvaluation**](/windows/win32/api/winuser/nf-winuser-packtouchhittestingproximityevaluation). If no elements are within the touch contact area, an application should set the value of **score** in [**TOUCH_HIT_TESTING_PROXIMITY_EVALUATION**](/windows/win32/api/winuser/ns-winuser-touch_hit_testing_proximity_evaluation) to [**TOUCH_HIT_TESTING_PROXIMITY_FARTHEST**](/previous-versions/windows/desktop/input_touchhittest/hit-testing-scores) and call [**PackTouchHitTestingProximityEvaluation**](/windows/win32/api/winuser/nf-winuser-packtouchhittestingproximityevaluation) to get the LRESULT return value. If the application does not process this message, it must call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>This message is sent to windows that register through the [**RegisterTouchHitTestingWindow**](/windows/win32/api/winuser/nf-winuser-registertouchhittestingwindow) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERWHEEL">
            <summary>Posted to the window with foreground keyboard focus when a scroll wheel is rotated.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>To retrieve the wheel scroll units, use the **inputData** filed of the [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) structure returned by calling [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) function. This field contains a signed value and is expressed in a multiple of **WHEEL_DELTA**. A positive value indicates a rotation forward and a negative value indicates a rotation backward. Note that the wheel inputs may be delivered even if the mouse cursor is located outside of application s window. The wheel messages are delivered in a way very similar to the keyboard inputs. The focus window of the foregournd message queue receives the wheel messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerwheel#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERHWHEEL">
            <summary>Posted to the window with foreground keyboard focus when a horizontal scroll wheel is rotated.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>To retrieve the wheel scroll units, use the **inputData** filed of the [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) structure returned by calling [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) function. This field contains a signed value and is expressed in a multiple of **WHEEL_DELTA**. A positive value indicates a rotation forward and a negative value indicates a rotation backward. Note that the wheel inputs may be delivered even if the mouse cursor is located outside of application s window. The wheel messages are delivered in a way very similar to the keyboard inputs. The focus window of the foregournd message queue receives the wheel messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerhwheel#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERROUTEDTO">
            <summary>Sent when ongoing pointer input, for an existing pointer ID, transitions from one process to another across content configured for cross-process chaining (AddContentWithCrossProcessChaining).</summary>
            <returns>NULL</returns>
            <remarks>
            <para>This message is not sent when a [**WM_POINTERDOWN**](wm-pointerdown.md) message is posted for a new pointer ID on a different process. A [**WM_POINTERDOWN**](wm-pointerdown.md) message is not sent if a **WM_POINTERROUTEDTO** message is posted first.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerroutedto#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERROUTEDAWAY">
            <summary>Occurs on the process receiving input when the pointer input is routed to another process.AddContentWithCrossProcessChaining).</summary>
            <returns>NULL</returns>
            <remarks>This message is not sent with either a [**WM_POINTERUP**](wm-pointerup.md) message or a [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERROUTEDRELEASED">
            <summary>Sent to all processes (configured for cross-process chaining through AddContentWithCrossProcessChaining and not currently handling pointer input) ever associated with a specific pointer ID, when a WM_POINTERUP message is received on the current process.</summary>
            <returns>NULL</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerroutedreleased">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_SETCONTEXT">
            <summary>Sent to an application when a window is activated. A window receives this message through its WindowProc function.</summary>
            <returns>Returns the value returned by [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) or [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea).</returns>
            <remarks>
            <para>If the application has created an IME window, it should call [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea). Otherwise, it should pass this message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). If the application draws the composition window, the default IME window does not have to show its composition window. In this case, the application must clear the **ISC\_SHOWUICOMPOSITIONWINDOW** value from the *lParam* parameter before passing the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) or [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea). To display a certain user interface window, an application should remove the corresponding value so that the IME will not display it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-setcontext#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_NOTIFY">
            <summary>Sent to an application to notify it of changes to the IME window. A window receives this message through its WindowProc function.</summary>
            <returns>The return value depends on the command sent.</returns>
            <remarks>An application processes this message if it is responsible for managing the IME window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_CONTROL">
            <summary>Sent by an application to direct the IME window to carry out the requested command.</summary>
            <returns>The message returns a command-specific value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-control">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_COMPOSITIONFULL">
            <summary>Sent to an application when the IME window finds no space to extend the area for the composition window. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>The application should use the [IMC\_SETCOMPOSITIONWINDOW](imc-setcompositionwindow.md) command to specify how the window should be displayed. The IME window, instead of the IME, sends this notification message by the [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-compositionfull#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_SELECT">
            <summary>Sent to an application when the operating system is about to change the current IME. A window receives this message through its WindowProc function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>An application that has created an IME window should pass this message to that window so that it can retrieve the keyboard layout handle to the newly selected IME. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing the information to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-select#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_CHAR">
            <summary>Sent to an application when the IME gets a character of the conversion result. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>Unlike the [**WM\_CHAR**](../inputdev/wm-char.md) message for a non-Unicode window, this message can include double-byte and single-byte character values. For a Unicode window, this message is the same as WM\_CHAR. For a non-Unicode window, if the WM\_IME\_CHAR message includes a double-byte character and the application passes this message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), the IME converts this message into two WM\_CHAR messages, each containing one byte of the double-byte character.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-char#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_REQUEST">
            <summary>Sent to an application to provide commands and request information. A window receives this message through its WindowProc function.</summary>
            <returns>Returns a command-specific value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-request">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_KEYDOWN">
            <summary>Sent to an application by the IME to notify the application of a key press and to keep message order. A window receives this message through its WindowProc function.</summary>
            <returns>An application should return 0 if it processes this message.</returns>
            <remarks>An application can process this message or pass it to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function to generate a matching [**WM\_KEYDOWN**](../inputdev/wm-keydown.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_KEYUP">
            <summary>Sent to an application by the IME to notify the application of a key release and to keep message order. A window receives this message through its WindowProc function.</summary>
            <returns>An application should return 0 if it processes this message.</returns>
            <remarks>An application can process this message or pass it to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function to generate a matching [**WM\_KEYUP**](../inputdev/wm-keyup.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMOUSEHOVER">
            <summary>Posted to a window when the cursor hovers over the nonclient area of the window for the period of time specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Hover tracking stops when this message is generated. The application must call [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) again if it requires further tracking of mouse hover behavior. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmousehover#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMOUSELEAVE">
            <summary>Posted to a window when the cursor leaves the nonclient area of the window specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>All tracking requested by [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) is canceled when this message is generated. The application must call **TrackMouseEvent** when the mouse reenters its window if it requires further tracking of mouse hover behavior.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DPICHANGED">
            <summary>Sent when the effective dots per inch (dpi) for a window has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>This message is only relevant for **PROCESS\_PER\_MONITOR\_DPI\_AWARE** applications or **DPI\_AWARENESS\_PER\_MONITOR\_AWARE** threads. It may be received on certain DPI changes if your top-level window or process is running as **DPI unaware** or **system DPI aware**, but in those situations it can be safely ignored. For more information about the different types of awareness, see [**PROCESS\_DPI\_AWARENESS**](/windows/desktop/api/ShellScalingApi/ne-shellscalingapi-process_dpi_awareness) and [**DPI\_AWARENESS**](/windows/desktop/api/windef/ne-windef-dpi_awareness). Older versions of Windows required DPI awareness to be tied at the level of an application. Those apps use **PROCESS\_DPI\_AWARENESS**. Currently, DPI awareness is tied to threads and individual windows rather than the entire application. These apps use **DPI\_AWARENESS**. You only need to use either the X-axis or the Y-axis value when scaling your application since they are the same. In order to handle this message correctly, you will need to resize and reposition your window based on the suggestions provided by *lParam* and using [**SetWindowPos**](/windows/desktop/api/winuser/nf-winuser-setwindowpos). If you do not do this, your window will grow or shrink with respect to everything else on the new monitor. For example, if a user is using multiple monitors and drags your window from a 96 DPI monitor to a 192 DPI monitor, your window will appear to be half as large with respect to other items on the 192 DPI monitor. The base value of DPI is defined as **USER\_DEFAULT\_SCREEN\_DPI** which is set to 96. To determine the scaling factor for a monitor, take the DPI value and divide by **USER\_DEFAULT\_SCREEN\_DPI**. The following table provides some sample DPI values and associated scaling factors.</para>
            <para>| DPI value | Scaling percentage | |-----------|--------------------| | 96        | 100%               | | 120       | 125%               | | 144       | 150%               | | 192       | 200%               |</para>
            <para>The following example provides a sample DPI change handler.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DPICHANGED_BEFOREPARENT">
            <summary>For Per Monitor v2 top-level windows, this message is sent to all HWNDs in the child HWDN tree of the window that is undergoing a DPI change. | WM_DPICHANGED_BEFOREPARENT message (Winuser.h)</summary>
            <returns>This value is unused and ignored by the system.</returns>
            <remarks>
            <para>There is no default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). This message is only sent when the top-level window has a DPI awareness context of PMv2.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged-beforeparent#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DPICHANGED_AFTERPARENT">
            <summary>For Per Monitor v2 top-level windows, this message is sent to all HWNDs in the child HWDN tree of the window that is undergoing a DPI change. | WM_DPICHANGED_AFTERPARENT message (Winuser.h)</summary>
            <returns>This value is unused and ignored by the system.</returns>
            <remarks>
            <para>There is no default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). This message is only sent when the top-level window has a DPI awareness context of PMv2.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged-afterparent#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETDPISCALEDSIZE">
            <summary>This message tells the operating system that the window will be sized to dimensions other than the default.</summary>
            <returns>The function returns a BOOL. Returning TRUE indicates that a new size has been computed. Returning FALSE indicates that the message will not be handled, and the default linear DPI scaling will apply to the window.</returns>
            <remarks>
            <para>This message is only sent to top-level windows which have a DPI awareness context of Per Monitor v2. This event is necessary to facilitate graceful non-linear scaling, and ensures that the windows's position remains constant in relationship to the cursor and when moving back and forth across monitors. There is no specific default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). As for all messages it does not explicitly handle, [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca) will return zero for this message. As noted above, this return tells the system to use the default linear behavior.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-getdpiscaledsize#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CUT">
            <summary>An application sends a WM\_CUT message to an edit control or combo box to delete (cut) the current selection, if any, in the edit control and copy the deleted text to the clipboard in CF\_TEXT format.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The deletion performed by the **WM\_CUT** message can be undone by sending the edit control an [**EM\_UNDO**](../controls/em-undo.md) message. To delete the current selection without placing the deleted text on the clipboard, use the [**WM\_CLEAR**](wm-clear.md) message. When sent to a combo box, the **WM\_CUT** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-cut#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COPY">
            <summary>An application sends the WM\_COPY message to an edit control or combo box to copy the current selection to the clipboard in CF\_TEXT format.</summary>
            <returns>Returns nonzero value on success, else zero.</returns>
            <remarks>When sent to a combo box, the **WM\_COPY** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PASTE">
            <summary>An application sends a WM\_PASTE message to an edit control or combo box to copy the current content of the clipboard to the edit control at the current caret position. Data is inserted only if the clipboard contains data in CF\_TEXT format.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>When sent to a combo box, the **WM\_PASTE** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CLEAR">
            <summary>An application sends a WM\_CLEAR message to an edit control or combo box to delete (clear) the current selection, if any, from the edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The deletion performed by the **WM\_CLEAR** message can be undone by sending the edit control an [**EM\_UNDO**](../controls/em-undo.md) message. To delete the current selection and place the deleted content on the clipboard, use the [**WM\_CUT**](wm-cut.md) message. When sent to a combo box, the **WM\_CLEAR** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-clear#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_UNDO">
            <summary>An application sends a WM\_UNDO message to an edit control to undo the last operation. When this message is sent to an edit control, the previously deleted text is restored or the previously added text is deleted.</summary>
            <returns>
            <para>If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>**Rich Edit:** It is recommended that [**EM\_UNDO**](em-undo.md) be used instead of **WM\_UNDO**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RENDERFORMAT">
            <summary>Sent to the clipboard owner if it has delayed rendering a specific clipboard format and if an application has requested data in that format.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>When responding to a **WM\_RENDERFORMAT** message, the clipboard owner must not open the clipboard before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata). Opening the clipboard is not necessary before placing data in response to **WM\_RENDERFORMAT**, and any attempt to open the clipboard will fail because the clipboard is currently being held open by the application that requested the format to be rendered.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RENDERALLFORMATS">
            <summary>Sent to the clipboard owner before it is destroyed, if the clipboard owner has delayed rendering one or more clipboard formats.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>When responding to a **WM\_RENDERALLFORMATS** message, the application must call the [**OpenClipboard**](/windows/win32/api/winuser/nf-winuser-openclipboard) function and then check that it is still the clipboard owner by calling the [**GetClipboardOwner**](/windows/win32/api/winuser/nf-winuser-getclipboardowner) function before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata). The application needs to check that it is still the clipboard owner after opening the clipboard because after it receives the **WM\_RENDERALLFORMATS** message, but before it opens the clipboard, another application may have opened and taken ownership of the clipboard, and that application's data should not be overwritten. In most cases, the application should not call the [**EmptyClipboard**](/windows/win32/api/winuser/nf-winuser-emptyclipboard) function before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata), since doing so will erase the clipboard formats that the application has already rendered. When the application returns, the system removes any unrendered formats from the list of available clipboard formats. For information about delayed rendering, see [Delayed Rendering](clipboard-operations.md#delayed-rendering).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-renderallformats#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DESTROYCLIPBOARD">
            <summary>Sent to the clipboard owner when a call to the EmptyClipboard function empties the clipboard. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-destroyclipboard">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DRAWCLIPBOARD">
            <summary>Sent to the first window in the clipboard viewer chain when the content of the clipboard changes. This enables a clipboard viewer window to display the new content of the clipboard. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>Only clipboard viewer windows receive this message. These are windows that have been added to the clipboard viewer chain by using the [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer) function. Each window that receives the **WM\_DRAWCLIPBOARD** message must call the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to pass the message on to the next window in the clipboard viewer chain. The handle to the next window in the chain is returned by [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer), and may change in response to a [**WM\_CHANGECBCHAIN**](wm-changecbchain.md) message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-drawclipboard#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PAINTCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and the clipboard viewer's client area needs repainting.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>To determine whether the entire client area or just a portion of it needs repainting, the clipboard owner must compare the dimensions of the drawing area given in the **rcPaint** member of [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) to the dimensions given in the most recent [**WM\_SIZECLIPBOARD**](wm-sizeclipboard.md) message. The clipboard owner must use the [**GlobalLock**](/windows/desktop/api/winbase/nf-winbase-globallock) function to lock the memory that contains the [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) structure. Before returning, the clipboard owner must unlock that memory by using the [**GlobalUnlock**](/windows/desktop/api/winbase/nf-winbase-globalunlock) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-paintclipboard#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_VSCROLLCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and an event occurs in the clipboard viewer's vertical scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>The clipboard owner can use the [**ScrollWindow**](https://msdn.microsoft.com/library/Cc410994(v=MSDN.10).aspx) function to scroll the image in the clipboard viewer window and invalidate the appropriate region.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SIZECLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and the clipboard viewer's client area has changed size.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>When the clipboard viewer window is about to be destroyed or resized, a **WM\_SIZECLIPBOARD** message is sent with a null rectangle (0, 0, 0, 0) as the new size. This permits the clipboard owner to free its display resources. The clipboard owner must use the [**GlobalLock**](/windows/desktop/api/winbase/nf-winbase-globallock) function to lock the memory object that contains [**RECT**](/windows/win32/api/windef/ns-windef-rect). Before returning, the clipboard owner must unlock the object by using the [**GlobalUnlock**](/windows/desktop/api/winbase/nf-winbase-globalunlock) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-sizeclipboard#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ASKCBFORMATNAME">
            <summary>Sent to the clipboard owner by a clipboard viewer window to request the name of a CF\_OWNERDISPLAY clipboard format.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>In response to this message, the clipboard owner should copy the name of the owner-display format to the specified buffer, not exceeding the buffer size specified by the *wParam* parameter. A clipboard viewer window sends this message to the clipboard owner to determine the name of the [**CF\_OWNERDISPLAY**](standard-clipboard-formats.md) format   for example, to initialize a menu listing available formats.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-askcbformatname#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHANGECBCHAIN">
            <summary>Sent to the first window in the clipboard viewer chain when a window is being removed from the chain. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Each clipboard viewer window saves the handle to the next window in the clipboard viewer chain. Initially, this handle is the return value of the [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer) function. When a clipboard viewer window receives the **WM\_CHANGECBCHAIN** message, it should call the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to pass the message to the next window in the chain, unless the next window is the window being removed. In this case, the clipboard viewer should save the handle specified by the *lParam* parameter as the next window in the chain.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-changecbchain#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_HSCROLLCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>The clipboard owner can use the [**ScrollWindow**](https://msdn.microsoft.com/library/Cc410994(v=MSDN.10).aspx) function to scroll the image in the clipboard viewer window and invalidate the appropriate region.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYNEWPALETTE">
            <summary>The WM\_QUERYNEWPALETTE message informs a window that it is about to receive the keyboard focus, giving the window the opportunity to realize its logical palette when it receives the focus.</summary>
            <returns>If the window realizes its logical palette, it must return **TRUE**; otherwise, it must return **FALSE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-querynewpalette">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PALETTEISCHANGING">
            <summary>The WM\_PALETTEISCHANGING message informs applications that an application is going to realize its logical palette.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The application changing its palette does not wait for acknowledgment of this message before changing the palette and sending the [**WM\_PALETTECHANGED**](wm-palettechanged.md) message. As a result, the palette may already be changed by the time an application receives this message. If the application either ignores or fails to process this message and a second application realizes its palette while the first is using palette indexes, there is a strong possibility that the user will see unexpected colors during subsequent drawing operations.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-paletteischanging#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PALETTECHANGED">
            <summary>The WM\_PALETTECHANGED message is sent to all top-level and overlapped windows after the window with the keyboard focus has realized its logical palette, thereby changing the system palette.</summary>
            <remarks>
            <para>This message must be sent to all top-level and overlapped windows, including the one that changed the system palette. If any child windows use a color palette, this message must be passed on to them as well. To avoid creating an infinite loop, a window that receives this message must not realize its palette, unless it determines that *wParam* does not contain its own window handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-palettechanged#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_HOTKEY">
            <summary>Posted when the user presses a hot key registered by the RegisterHotKey function. The message is placed at the top of the message queue associated with the thread that registered the hot key.</summary>
            <remarks>**WM\_HOTKEY** is unrelated to the [**WM\_GETHOTKEY**](wm-gethotkey.md) and [**WM\_SETHOTKEY**](wm-sethotkey.md) hot keys. The **WM\_HOTKEY** message is sent for generic hot keys while the **WM\_SETHOTKEY** and **WM\_GETHOTKEY** messages relate to window activation hot keys.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PRINT">
            <summary>The WM\_PRINT message is sent to a window to request that it draw itself in the specified device context, most commonly in a printer device context.</summary>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function processes this message based on which drawing option is specified: if PRF\_CHECKVISIBLE is specified and the window is not visible, do nothing, if PRF\_NONCLIENT is specified, draw the nonclient area in the specified device context, if PRF\_ERASEBKGND is specified, send the window a [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message, if PRF\_CLIENT is specified, send the window a [**WM\_PRINTCLIENT**](wm-printclient.md) message, if PRF\_CHILDREN is set, send each visible child window a **WM\_PRINT** message, if PRF\_OWNED is set, send each visible owned window a **WM\_PRINT** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_APPCOMMAND">
            <summary>Notifies a window that the user generated an application command event, for example, by clicking an application command button using the mouse or typing an application command key on the keyboard.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>[**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) generates the **WM\_APPCOMMAND** message when it processes the [**WM\_XBUTTONUP**](wm-xbuttonup.md) or [**WM\_NCXBUTTONUP**](wm-ncxbuttonup.md) message, or when the user types an application command key. If a child window does not process this message and instead calls [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), **DefWindowProc** will send the message to its parent window. If a top level window does not process this message and instead calls **DefWindowProc**, **DefWindowProc** will call a shell hook with the hook code equal to **HSHELL\_APPCOMMAND**. To get the coordinates of the cursor if the message was generated by a mouse click, the application can call [**GetMessagePos**](/windows/desktop/api/winuser/nf-winuser-getmessagepos). An application can test whether the message was generated by the mouse by checking whether *lParam* contains **FAPPCOMMAND\_MOUSE**. Unlike other windows messages, an application should return **TRUE** from this message if it processes it. Doing so will allow software that simulates this message on Windows systems earlier than Windows 2000 to determine whether the window procedure processed the message or called [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) to process it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-appcommand#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_THEMECHANGED">
            <summary>Broadcast to every window following a theme change event. Examples of theme change events are the activation of a theme, the deactivation of a theme, or a transition from one theme to another.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. > [!Note] > This message is posted by the operating system. Applications typically do not send this message.</para>
            <para>Themes are specifications for the appearance of controls, so that the visual element of a control is treated separately from its functionality. To release an existing theme handle, call [**CloseThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-closethemedata). To acquire a new theme handle, use [**OpenThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-openthemedata). Following the **WM\_THEMECHANGED** broadcast, any existing theme handles are invalid. A theme-aware window should release and reopen any of its pre-existing theme handles when it receives the **WM\_THEMECHANGED** message. If the [**OpenThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-openthemedata) function returns **NULL**, the window should paint unthemed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-themechanged#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CLIPBOARDUPDATE">
            <summary>Sent when the contents of the clipboard have changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>To register a window to receive this message, use the [**AddClipboardFormatListener**](/windows/desktop/api/Winuser/nf-winuser-addclipboardformatlistener) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMCOMPOSITIONCHANGED">
            <summary>Informs all top-level windows that Desktop Window Manager (DWM) composition has been enabled or disabled.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. The [**DwmIsCompositionEnabled**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmiscompositionenabled) function can be used to determine the current composition state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmcompositionchanged#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMNCRENDERINGCHANGED">
            <summary>Sent when the non-client area rendering policy has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. The [**DwmGetWindowAttribute**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmgetwindowattribute) and [**DwmSetWindowAttribute**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmsetwindowattribute) functions are used to get or set the non-client rendering policy.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmncrenderingchanged#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMCOLORIZATIONCOLORCHANGED">
            <summary>Informs all top-level windows that the colorization color has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. [**DwmGetColorizationColor**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmgetcolorizationcolor) is used to determine the current color value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmcolorizationcolorchanged#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMWINDOWMAXIMIZEDCHANGE">
            <summary>Sent when a Desktop Window Manager (DWM) composed window is maximized.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMSENDICONICTHUMBNAIL">
            <summary>Instructs a window to provide a static bitmap to use as a thumbnail representation of that window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>DWM sends this message to a window if all of the following situations are true: -   DWM is displaying an iconic representation of the window. -   The [**DWMWA\_HAS\_ICONIC\_BITMAP**](/windows/desktop/api/Dwmapi/ne-dwmapi-dwmwindowattribute) attribute is set on the window. -   The window did not set a cached bitmap. -   There is room in the cache for another bitmap. The window that receives this message should respond by generating a bitmap that is not larger than the size that is requested in the message parameters. The window then calls the [**DwmSetIconicThumbnail**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmseticonicthumbnail) function to override the default thumbnail. If the window does not supply a bitmap in a given amount of time, DWM uses its own default iconic representation for the window. The window must belong to the calling process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmsendiconicthumbnail#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMSENDICONICLIVEPREVIEWBITMAP">
            <summary>Instructs a window to provide a static bitmap to use as a live preview (also known as a Peek preview) of that window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A *live preview* (also known as a *Peek preview*) of a window appears when a user moves the mouse pointer over the window's thumbnail in the taskbar or gives the thumbnail focus in the ALT+TAB window. This view is a full-sized preview of the window and can be a live snapshot or an iconic representation. Desktop Window Manager (DWM) sends this message to a window if all of the following situations are true: -   Live preview has been invoked on the window. -   The [**DWMWA\_HAS\_ICONIC\_BITMAP**](/windows/desktop/api/Dwmapi/ne-dwmapi-dwmwindowattribute) attribute is set on the window. -   An iconic representation is the only one that exists for this window. The window that receives this message should respond by generating a full-scale bitmap. The window then calls the [**DwmSetIconicLivePreviewBitmap**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmseticoniclivepreviewbitmap) function to set the live preview. If the window does not set a bitmap in a given amount of time, DWM uses its own default iconic representation for the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmsendiconiclivepreviewbitmap#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETTITLEBARINFOEX">
            <summary>Sent to request extended title bar information. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>The following example shows how the message receiver casts an **LPARAM** value to retrieve the [**TITLEBARINFOEX**](/windows/win32/api/winuser/ns-winuser-titlebarinfoex) structure. `TITLEBARINFOEX *ptinfo = (TITLEBARINFOEX *)lParam;`</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-gettitlebarinfoex#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_APP">
            <summary>Used to define private messages, usually of the form WM\_APP+x, where x is an integer value.</summary>
            <remarks>
            <para>The **WM\_APP** constant is used to distinguish between message values that are reserved for use by the system and values that can be used by an application to send messages within a private window class. The following are the ranges of message numbers available.</para>
            <para>| Range                                                 | Meaning                                                        | |-------------------------------------------------------|----------------------------------------------------------------| | 0 through [**WM\_USER**](wm-user.md) 1<br/>   | Messages reserved for use by the system.<br/>            | | [**WM\_USER**](wm-user.md) through 0x7FFF<br/> | Integer messages for use by private window classes.<br/> | | **WM\_APP** through 0xBFFF<br/>                 | Messages available for use by applications.<br/>         | | 0xC000 through 0xFFFF<br/>                      | String messages for use by applications.<br/>            | | Greater than 0xFFFF<br/>                        | Reserved by the system.<br/>                             |</para>
            <para>Message numbers in the first range (0 through [**WM\_USER**](wm-user.md) 1) are defined by the system. Values in this range that are not explicitly defined are reserved by the system. Message numbers in the second range ([**WM\_USER**](wm-user.md) through 0x7FFF) can be defined and used by an application to send messages within a private window class. These values cannot be used to define messages that are meaningful throughout an application because some predefined window classes already define values in this range. For example, predefined control classes such as **BUTTON**, **EDIT**, **LISTBOX**, and **COMBOBOX** may use these values. Messages in this range should not be sent to other applications unless the applications have been designed to exchange messages and to attach the same meaning to the message numbers. Message numbers in the third range (0x8000 through 0xBFFF) are available for applications to use as private messages. Messages in this range do not conflict with system messages. Message numbers in the fourth range (0xC000 through 0xFFFF) are defined at run time when an application calls the [**RegisterWindowMessage**](/windows/win32/api/winuser/nf-winuser-registerwindowmessagea) function to retrieve a message number for a string. All applications that register the same string can use the associated message number for exchanging messages. The actual message number, however, is not a constant and cannot be assumed to be the same between different sessions. Message numbers in the fifth range (greater than 0xFFFF) are reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-app#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_USER">
            <summary>Used to define private messages for use by private window classes, usually of the form WM\_USER+x, where x is an integer value.</summary>
            <remarks>
            <para>The following are the ranges of message numbers.</para>
            <para>| Range                                                        | Meaning                                                        | |--------------------------------------------------------------|----------------------------------------------------------------| | 0 through **WM\_USER** 1<br/>                         | Messages reserved for use by the system.<br/>            | | **WM\_USER** through 0x7FFF<br/>                       | Integer messages for use by private window classes.<br/> | | [**WM\_APP**](wm-app.md) (0x8000) through 0xBFFF<br/> | Messages available for use by applications.<br/>         | | 0xC000 through 0xFFFF<br/>                             | String messages for use by applications.<br/>            | | Greater than 0xFFFF<br/>                               | Reserved by the system.<br/>                             |</para>
            <para>Message numbers in the first range (0 through **WM\_USER** 1) are defined by the system. Values in this range that are not explicitly defined are reserved by the system. Message numbers in the second range (**WM\_USER** through 0x7FFF) can be defined and used by an application to send messages within a private window class. These values cannot be used to define messages that are meaningful throughout an application because some predefined window classes already define values in this range. For example, predefined control classes such as **BUTTON**, **EDIT**, **LISTBOX**, and **COMBOBOX** may use these values. Messages in this range should not be sent to other applications unless the applications have been designed to exchange messages and to attach the same meaning to the message numbers. Message numbers in the third range (0x8000 through 0xBFFF) are available for applications to use as private messages. Messages in this range do not conflict with system messages. Message numbers in the fourth range (0xC000 through 0xFFFF) are defined at run time when an application calls the [**RegisterWindowMessage**](/windows/win32/api/winuser/nf-winuser-registerwindowmessagea) function to retrieve a message number for a string. All applications that register the same string can use the associated message number for exchanging messages. The actual message number, however, is not a constant and cannot be assumed to be the same between different sessions. Message numbers in the fifth range (greater than 0xFFFF) are reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-user#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_ERROR">
            <summary>The WM\_CAP\_SET\_CALLBACK\_ERROR message sets an error callback function in the client application. AVICap calls this procedure when errors occur. You can send this message explicitly or by using the capSetCallbackOnError macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the error callback function, of type [**capErrorCallback**](/windows/desktop/api/Vfw/nc-vfw-caperrorcallbacka). Specify **NULL** for this parameter to disable a previously installed error callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set an error callback function. If set, AVICap calls the error procedure in the following situations: -   The disk is full. -   A capture window cannot be connected with a capture driver. -   A waveform-audio device cannot be opened. -   The number of frames dropped during capture exceeds the specified percentage. -   The frames cannot be captured due to vertical synchronization interrupt problems.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-error#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_STATUS">
            <summary>The WM\_CAP\_SET\_CALLBACK\_STATUS message sets a status callback function in the application. AVICap calls this procedure whenever the capture window status changes. You can send this message explicitly or by using the capSetCallbackOnStatus macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the status callback function, of type [**capStatusCallback**](/windows/desktop/api/Vfw/nc-vfw-capstatuscallbacka). Specify **NULL** for this parameter to disable a previously installed status callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set a status callback function. If set, AVICap calls this procedure in the following situations: -   A capture session is completed. -   A capture driver successfully connected to a capture window. -   An optimal palette is created. -   The number of captured frames is reported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-status#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_YIELD">
            <summary>The WM\_CAP\_SET\_CALLBACK\_YIELD message sets a callback function in the application. AVICap calls this procedure when the capture window yields during streaming capture. You can send this message explicitly or by using the capSetCallbackOnYield macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the yield callback function, of type [**capYieldCallback**](/windows/desktop/api/Vfw/nc-vfw-capyieldcallback). Specify **NULL** for this parameter to disable a previously installed yield callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set a yield callback function. The yield callback function is called at least once for each video frame captured during streaming capture. If a yield callback function is installed, it will be called regardless of the state of the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure. If the yield callback function is used, it must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends. Applications typically perform some type of message processing in the callback function consisting of a [PeekMessage](/windows/win32/api/winuser/nf-winuser-peekmessagea), [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage), [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) loop, as in the message loop of a [WinMain](/windows/win32/api/winbase/nf-winbase-winmain) function. The yield callback function must also filter and remove messages that can cause reentrancy problems. An application typically returns **TRUE** in the yield procedure to continue streaming capture. If a yield callback function returns **FALSE**, the capture window stops the capture process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-yield#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_FRAME">
            <summary>The WM\_CAP\_SET\_CALLBACK\_FRAME message sets a preview callback function in the application. AVICap calls this procedure when the capture window captures preview frames. You can send this message explicitly or by using the capSetCallbackOnFrame macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the preview callback function, of type [**capVideoStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capvideocallback). Specify **NULL** for this parameter to disable a previously installed callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>The capture window calls the callback function before displaying preview frames. This allows an application to modify the frame if desired. This callback function is not used during streaming video capture.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_VIDEOSTREAM">
            <summary>The WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM message sets a callback function in the application.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the video-stream callback function, of type [**capVideoStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capvideocallback). Specify **NULL** for this parameter to disable a previously installed video-stream callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>The capture window calls the callback function before writing the captured frame to disk. This allows applications to modify the frame if desired. If a video stream callback function is used for streaming capture, the procedure must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-videostream#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_WAVESTREAM">
            <summary>The WM\_CAP\_SET\_CALLBACK\_WAVESTREAM message sets a callback function in the application.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the wave stream callback function, of type [**capWaveStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capwavecallback). Specify **NULL** for this parameter to disable a previously installed wave stream callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>The capture window calls the procedure before writing the audio buffer to disk. This allows applications to modify the audio buffer if desired. If a wave stream callback function is used, it must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-wavestream#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_USER_DATA">
            <summary>The WM\_CAP\_GET\_USER\_DATA message retrieves a LONG\_PTR data value associated with a capture window. You can send this message explicitly or by using the capGetUserData macro.</summary>
            <returns>Returns a value previously saved by using the [**WM\_CAP\_SET\_USER\_DATA**](wm-cap-set-user-data.md) message.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-get-user-data">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_USER_DATA">
            <summary>The WM\_CAP\_SET\_USER\_DATA message associates a LONG\_PTR data value with a capture window. You can send this message explicitly or by using the capSetUserData macro.</summary>
            <returns>
            <para><span id="lUser"></span><span id="luser"></span><span id="LUSER"></span>*lUser* Data value to associate with a capture window.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture is in progress.</para>
            </returns>
            <remarks>Typically this message is used to point to a block of data associated with a capture window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_CONNECT">
            <summary>The WM\_CAP\_DRIVER\_CONNECT message connects a capture window to a capture driver. You can send this message explicitly or by using the capDriverConnect macro.</summary>
            <returns>
            <para><span id="iIndex"></span><span id="iindex"></span><span id="IINDEX"></span>*iIndex* Index of the capture driver. The index can range from 0 through 9.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the specified capture driver cannot be connected to the capture window.</para>
            </returns>
            <remarks>Connecting a capture driver to a capture window automatically disconnects any previously connected capture driver.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_DISCONNECT">
            <summary>The WM\_CAP\_DRIVER\_DISCONNECT message disconnects a capture driver from a capture window. You can send this message explicitly or by using the capDriverDisconnect macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-driver-disconnect">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_GET_NAME">
            <summary>The WM\_CAP\_DRIVER\_GET\_NAME message returns the name of the capture driver connected to the capture window. You can send this message explicitly or by using the capDriverGetName macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to an application-defined buffer used to return the device name as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The name is a text string retrieved from the driver's resource area. Applications should allocate approximately 80 bytes for this string. If the driver does not contain a name resource, the full path name of the driver listed in the registry or in the SYSTEM.INI file is returned.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_GET_VERSION">
            <summary>The WM\_CAP\_DRIVER\_GET\_VERSION message returns the version information of the capture driver connected to a capture window. You can send this message explicitly or by using the capDriverGetVersion macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the application-defined buffer referenced by**szVer**.</para>
            <para><span id="szVer"></span><span id="szver"></span><span id="SZVER"></span>*szVer* Pointer to an application-defined buffer used to return the version information as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The version information is a text string retrieved from the driver's resource area. Applications should allocate approximately 40 bytes for this string. If version information is not available, a **NULL** string is returned.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_GET_CAPS">
            <summary>The WM\_CAP\_DRIVER\_GET\_CAPS message returns the hardware capabilities of the capture driver currently connected to a capture window. You can send this message explicitly or by using the capDriverGetCaps macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psCaps"></span><span id="pscaps"></span><span id="PSCAPS"></span>*psCaps* Pointer to the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure to contain the hardware capabilities.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The capabilities returned in [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) are constant for a given capture driver. Applications need to retrieve this information once when the capture driver is first connected to a capture window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_SET_CAPTURE_FILE">
            <summary>The WM\_CAP\_FILE\_SET\_CAPTURE\_FILE message names the file used for video capture. You can send this message explicitly or by using the capFileSetCaptureFile macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the capture file to use.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the filename is invalid, or if streaming or single-frame capture is in progress.</para>
            </returns>
            <remarks>This message stores the filename in an internal structure. It does not create, allocate, or open the specified file. The default capture filename is C:\\CAPTURE.AVI.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_GET_CAPTURE_FILE">
            <summary>The WM\_CAP\_FILE\_GET\_CAPTURE\_FILE message returns the name of the current capture file. You can send this message explicitly or by using the capFileGetCaptureFile macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the application-defined buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to an application-defined buffer used to return the name of the capture file as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>The default capture filename is C:\\CAPTURE.AVI.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_SAVEAS">
            <summary>The WM\_CAP\_FILE\_SAVEAS message copies the contents of the capture file to another file. You can send this message explicitly or by using the capFileSaveAs macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the destination file used to copy the file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para>This message does not change the name or contents of the current capture file. If the copy operation is unsuccessful due to a disk full error, the destination file is automatically deleted. Typically, a capture file is preallocated for the largest capture segment anticipated and only a portion of it might be used to capture data. This message copies only the portion of the file containing the capture data.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-file-saveas#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_SAVEDIB">
            <summary>The WM\_CAP\_FILE\_SAVEDIB message copies the current frame to a DIB file. You can send this message explicitly or by using the capFileSaveDIB macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the destination DIB file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>If the capture driver supplies frames in a compressed format, this call attempts to decompress the frame before writing the file.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_ALLOCATE">
            <summary>The WM\_CAP\_FILE\_ALLOCATE message creates (preallocates) a capture file of a specified size. You can send this message explicitly or by using the capFileAlloc macro.</summary>
            <returns>
            <para><span id="dwSize"></span><span id="dwsize"></span><span id="DWSIZE"></span>*dwSize* Size, in bytes, to create the capture file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>You can improve streaming capture performance significantly by preallocating a capture file large enough to store an entire video clip and by defragmenting the capture file before capturing the clip.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_SET_INFOCHUNK">
            <summary>The WM\_CAP\_FILE\_SET\_INFOCHUNK message sets and clears information chunks.</summary>
            <returns>
            <para><span id="lpInfoChunk"></span><span id="lpinfochunk"></span><span id="LPINFOCHUNK"></span>*lpInfoChunk* Pointer to a [**CAPINFOCHUNK**](/windows/win32/api/vfw/ns-vfw-capinfochunk) structure defining the information chunk to be created or deleted.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>Multiple registered information chunks can be added to an AVI file. After an information chunk is set, it continues to be added to subsequent capture files until either the entry is cleared or all information chunk entries are cleared. To clear a single entry, specify the information chunk in the **fccInfoID** member and **NULL** in the **lpData** member of the [**CAPINFOCHUNK**](/windows/win32/api/vfw/ns-vfw-capinfochunk) structure. To clear all entries, specify **NULL** in **fccInfoID**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_EDIT_COPY">
            <summary>The WM\_CAP\_EDIT\_COPY message copies the contents of the video frame buffer and associated palette to the clipboard. You can send this message explicitly or by using the capEditCopy macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-edit-copy">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_AUDIOFORMAT">
            <summary>The WM\_CAP\_SET\_AUDIOFORMAT message sets the audio format to use when performing streaming or step capture. You can send this message explicitly or by using the capSetAudioFormat macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by **s**.</para>
            <para><span id="psAudioFormat"></span><span id="psaudioformat"></span><span id="PSAUDIOFORMAT"></span>*psAudioFormat* Pointer to a [**WAVEFORMATEX**](/windows/win32/api/mmeapi/ns-mmeapi-waveformatex) or [**PCMWAVEFORMAT**](/windows/win32/api/mmreg/ns-mmreg-pcmwaveformat) structure that defines the audio format.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-audioformat">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_AUDIOFORMAT">
            <summary>The WM\_CAP\_GET\_AUDIOFORMAT message obtains the audio format or the size of the audio format. You can send this message explicitly or by using the capGetAudioFormat and capGetAudioFormatSize macros.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psAudioFormat"></span><span id="psaudioformat"></span><span id="PSAUDIOFORMAT"></span>*psAudioFormat* Pointer to a [**WAVEFORMATEX**](/windows/win32/api/mmeapi/ns-mmeapi-waveformatex) structure, or **NULL**. If the value is **NULL**, the size, in bytes, required to hold the structure is returned.</para>
            <para>Returns the size, in bytes, of the audio format.</para>
            </returns>
            <remarks>Because compressed audio formats vary in size requirements applications must first retrieve the size, then allocate memory, and finally request the audio format data.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DLG_VIDEOFORMAT">
            <summary>The WM\_CAP\_DLG\_VIDEOFORMAT message displays a dialog box in which the user can select the video format.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>After this message returns, applications might need to update the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure because the user might have changed the image dimensions. The Video Format dialog box is unique for each capture driver. Some capture drivers might not support a Video Format dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoFormat** member of [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videoformat#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DLG_VIDEOSOURCE">
            <summary>The WM\_CAP\_DLG\_VIDEOSOURCE message displays a dialog box in which the user can control the video source.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>The Video Source dialog box is unique for each capture driver. Some capture drivers might not support a Video Source dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoSource** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DLG_VIDEODISPLAY">
            <summary>The WM\_CAP\_DLG\_VIDEODISPLAY message displays a dialog box in which the user can set or adjust the video output.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>The controls in this dialog box do not affect digitized video data; they affect only the output or redisplay of the video signal. The Video Display dialog box is unique for each capture driver. Some capture drivers might not support a Video Display dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoDisplay** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videodisplay#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_VIDEOFORMAT">
            <summary>The WM\_CAP\_GET\_VIDEOFORMAT message retrieves a copy of the video format in use or the size required for the video format. You can send this message explicitly or by using the capGetVideoFormat and capGetVideoFormatSize macros.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psVideoFormat"></span><span id="psvideoformat"></span><span id="PSVIDEOFORMAT"></span>*psVideoFormat* Pointer to a [**BITMAPINFO**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfo) structure. You can also specify **NULL** to retrieve the number of bytes needed.</para>
            <para>Returns the size, in bytes, of the video format or zero if the capture window is not connected to a capture driver. For video formats that require a palette, the current palette is also returned.</para>
            </returns>
            <remarks>Because compressed video formats vary in size requirements applications must first retrieve the size, then allocate memory, and finally request the video format data.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_VIDEOFORMAT">
            <summary>The WM\_CAP\_SET\_VIDEOFORMAT message sets the format of captured video data. You can send this message explicitly or by using the capSetVideoFormat macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by **s**.</para>
            <para><span id="psVideoFormat"></span><span id="psvideoformat"></span><span id="PSVIDEOFORMAT"></span>*psVideoFormat* Pointer to a [**BITMAPINFO**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfo) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>Because video formats are device-specific, applications should check the return value from this function to determine if the format is accepted by the driver.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DLG_VIDEOCOMPRESSION">
            <summary>The WM\_CAP\_DLG\_VIDEOCOMPRESSION message displays a dialog box in which the user can select a compressor to use during the capture process.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>Use this message with capture drivers that provide frames only in the BI\_RGB format. This message is most useful in the step capture operation to combine capture and compression in a single operation. Compressing frames with a software compressor as part of a real-time capture operation is most likely too time-consuming to perform. Compression does not affect the frames copied to the clipboard.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videocompression#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_PREVIEW">
            <summary>The WM\_CAP\_SET\_PREVIEW message enables or disables preview mode.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Preview flag. Specify **TRUE** for this parameter to enable preview mode or **FALSE** to disable it.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>The preview mode uses substantial CPU resources. Applications can disable preview or lower the preview rate when another application has the focus. The **fLiveWindow** member of the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure indicates if preview mode is currently enabled. Enabling preview mode automatically disables overlay mode.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-preview#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_OVERLAY">
            <summary>The WM\_CAP\_SET\_OVERLAY message enables or disables overlay mode. In overlay mode, video is displayed using hardware overlay. You can send this message explicitly or by using the capOverlay macro.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Overlay flag. Specify **TRUE** for this parameter to enable overlay mode or **FALSE** to disable it.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>Using an overlay does not require CPU resources. The **fHasOverlay** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure indicates whether the device is capable of overlay. The **fOverlayWindow** member of the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure indicates whether overlay mode is currently enabled. Enabling overlay mode automatically disables preview mode.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-overlay#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_PREVIEWRATE">
            <summary>The WM\_CAP\_SET\_PREVIEWRATE message sets the frame display rate in preview mode. You can send this message explicitly or by using the capPreviewRate macro.</summary>
            <returns>
            <para><span id="wMS"></span><span id="wms"></span><span id="WMS"></span>*wMS* Rate, in milliseconds, at which new frames are captured and displayed.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The preview mode uses substantial CPU resources. Applications can disable preview or lower the preview rate when another application has the focus. During streaming video capture, the previewing task is lower priority than writing frames to disk, and preview frames are displayed only if no other buffers are available for writing.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_SCALE">
            <summary>The WM\_CAP\_SET\_SCALE message enables or disables scaling of the preview video images.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Preview scaling flag. Specify **TRUE** for this parameter to stretch preview frames to the size of the capture window or **FALSE** to display them at their natural size.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>Scaling preview images controls the immediate presentation of captured frames within the capture window. It has no effect on the size of the frames saved to file. Scaling has no effect when using overlay to display video in the frame buffer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-scale#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_STATUS">
            <summary>The WM\_CAP\_GET\_STATUS message retrieves the status of the capture window. You can send this message explicitly or by using the capGetStatus macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="s"></span><span id="S"></span>*s* Pointer to a [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure contains the current state of the capture window. Since this state is dynamic and changes in response to various messages, the application should initialize this structure after sending the [**WM\_CAP\_DLG\_VIDEOFORMAT**](wm-cap-dlg-videoformat.md) message (or using the [**capDlgVideoFormat**](/windows/desktop/api/Vfw/nf-vfw-capdlgvideoformat) macro) and whenever it needs to enable menu items or determine the actual state of the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_SCROLL">
            <summary>The WM\_CAP\_SET\_SCROLL message defines the portion of the video frame to display in the capture window.</summary>
            <returns>
            <para><span id="lpP"></span><span id="lpp"></span><span id="LPP"></span>*lpP* Address to contain the desired scroll position.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>The scroll position affects the image in both preview and overlay modes.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GRAB_FRAME">
            <summary>The WM\_CAP\_GRAB\_FRAME message retrieves and displays a single frame from the capture driver. After capture, overlay and preview are disabled. You can send this message explicitly or by using the capGrabFrame macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GRAB_FRAME_NOSTOP">
            <summary>The WM\_CAP\_GRAB\_FRAME\_NOSTOP message fills the frame buffer with a single uncompressed frame from the capture device and displays it.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SEQUENCE">
            <summary>The WM\_CAP\_SEQUENCE message initiates streaming video and audio capture to a file. You can send this message explicitly or by using the capCaptureSequence macro.</summary>
            <returns>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para>If you want to alter the parameters controlling streaming capture, use the [**WM\_CAP\_SET\_SEQUENCE\_SETUP**](wm-cap-set-sequence-setup.md) message prior to starting the capture. By default, the capture window does not allow other applications to continue running during capture. To override this, either set the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure to **TRUE**, or install a yield callback function. During streaming capture, the capture window can optionally issue notifications to your application of specific types of conditions. To install callback procedures for these notifications, use the following messages: -   [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) -   [**WM\_CAP\_SET\_CALLBACK\_STATUS**](wm-cap-set-callback-status.md) -   [**WM\_CAP\_SET\_CALLBACK\_YIELD**](wm-cap-set-callback-yield.md) -   [**WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM**](wm-cap-set-callback-videostream.md) -   [**WM\_CAP\_SET\_CALLBACK\_WAVESTREAM**](wm-cap-set-callback-wavestream.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-sequence#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SEQUENCE_NOFILE">
            <summary>The WM\_CAP\_SEQUENCE\_NOFILE message initiates streaming video capture without writing data to a file. You can send this message explicitly or by using the capCaptureSequenceNoFile macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>This message is useful in conjunction with video stream or waveform-audio stream callback functions that let your application use the video and audio data directly. If you want to alter the parameters controlling streaming capture, use the [**WM\_CAP\_SET\_SEQUENCE\_SETUP**](wm-cap-set-sequence-setup.md) message prior to starting the capture. By default, the capture window does not allow other applications to continue running during capture. To override this, either set the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure to **TRUE**, or install a yield callback function. During streaming capture, the capture window can optionally issue notifications to your application of specific types of conditions. To install callback procedures for these notifications, use the following messages: -   [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) -   [**WM\_CAP\_SET\_CALLBACK\_STATUS**](wm-cap-set-callback-status.md) -   [**WM\_CAP\_SET\_CALLBACK\_YIELD**](wm-cap-set-callback-yield.md) -   [**WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM**](wm-cap-set-callback-videostream.md) -   [**WM\_CAP\_SET\_CALLBACK\_WAVESTREAM**](wm-cap-set-callback-wavestream.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-sequence-nofile#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_SEQUENCE_SETUP">
            <summary>The WM\_CAP\_SET\_SEQUENCE\_SETUP message sets the configuration parameters used with streaming capture. You can send this message explicitly or by using the capCaptureSetSetup macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psCapParms"></span><span id="pscapparms"></span><span id="PSCAPPARMS"></span>*psCapParms* Pointer to a [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>For information about the parameters used to control streaming capture, see the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_SEQUENCE_SETUP">
            <summary>The WM\_CAP\_GET\_SEQUENCE\_SETUP message retrieves the current settings of the streaming capture parameters. You can send this message explicitly or by using the capCaptureGetSetup macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="s"></span><span id="S"></span>*s* Pointer to a [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>For information about the parameters used to control streaming capture, see the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_MCI_DEVICE">
            <summary>The WM\_CAP\_SET\_MCI\_DEVICE message specifies the name of the MCI video device to be used to capture data. You can send this message explicitly or by using the capSetMCIDeviceName macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the name of the device.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>This message stores the MCI device name in an internal structure. It does not open or access the device. The default device name is **NULL**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_MCI_DEVICE">
            <summary>The WM\_CAP\_GET\_MCI\_DEVICE message retrieves the name of an MCI device previously set with the WM\_CAP\_SET\_MCI\_DEVICE message. You can send this message explicitly or by using the capGetMCIDeviceName macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Length, in bytes, of the buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string that contains the MCI device name.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-get-mci-device">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_STOP">
            <summary>The WM\_CAP\_STOP message stops the capture operation. You can send this message explicitly or by using the capCaptureStop macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>The capture operation must yield to use this message. Use the [**WM\_CAP\_ABORT**](wm-cap-abort.md) message to abandon the current capture operation.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_ABORT">
            <summary>The WM\_CAP\_ABORT message stops the capture operation.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>The capture operation must yield to use this message. Use the [**WM\_CAP\_STOP**](wm-cap-stop.md) message to halt step capture at the current position, and then capture audio.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-abort#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SINGLE_FRAME_OPEN">
            <summary>The WM\_CAP\_SINGLE\_FRAME\_OPEN message opens the capture file for single-frame capturing. Any previous information in the capture file is overwritten. You can send this message explicitly or by using the capCaptureSingleFrameOpen macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SINGLE_FRAME_CLOSE">
            <summary>The WM\_CAP\_SINGLE\_FRAME\_CLOSE message closes the capture file opened by the WM\_CAP\_SINGLE\_FRAME\_OPEN message. You can send this message explicitly or by using the capCaptureSingleFrameClose macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SINGLE_FRAME">
            <summary>The WM\_CAP\_SINGLE\_FRAME message appends a single frame to a capture file that was opened using the WM\_CAP\_SINGLE\_FRAME\_OPEN message. You can send this message explicitly or by using the capCaptureSingleFrame macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-single-frame">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_OPEN">
            <summary>The WM\_CAP\_PAL\_OPEN message loads a new palette from a palette file and passes it to a capture driver.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the palette filename.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-open">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_SAVE">
            <summary>The WM\_CAP\_PAL\_SAVE message saves the current palette to a palette file. Palette files typically use the filename extension .PAL. You can send this message explicitly or by using the capPaletteSave macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the palette filename.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-save">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_PASTE">
            <summary>The WM\_CAP\_PAL\_PASTE message copies the palette from the clipboard and passes it to a capture driver. You can send this message explicitly or by using the capPalettePaste macro.</summary>
            <returns>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>A capture driver uses a palette when required by the specified digitized video format.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_AUTOCREATE">
            <summary>The WM\_CAP\_PAL\_AUTOCREATE message requests that the capture driver sample video frames and automatically create a new palette. You can send this message explicitly or by using the capPaletteAuto macro.</summary>
            <returns>
            <para><span id="iFrames"></span><span id="iframes"></span><span id="IFRAMES"></span>*iFrames* Number of frames to sample.</para>
            <para><span id="iColors"></span><span id="icolors"></span><span id="ICOLORS"></span>*iColors* Number of colors in the palette. The maximum value for this parameter is 256.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>The sampled video sequence should include all the colors you want in the palette. To obtain the best palette, you might have to sample the whole sequence rather than a portion of it.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_MANUALCREATE">
            <summary>The WM\_CAP\_PAL\_MANUALCREATE message requests that the capture driver manually sample video frames and create a new palette. You can send this message explicitly or by using the capPaletteManual macro.</summary>
            <returns>
            <para><span id="fGrab"></span><span id="fgrab"></span><span id="FGRAB"></span>*fGrab* Palette histogram flag. Set this parameter to **TRUE** for each frame included in creating the optimal palette. After the last frame has been collected, set this parameter to **FALSE** to calculate the optimal palette and send it to the capture driver.</para>
            <para><span id="iColors"></span><span id="icolors"></span><span id="ICOLORS"></span>*iColors* Number of colors in the palette. The maximum value for this parameter is 256. This value is used only during collection of the first frame in a sequence.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-manualcreate">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_CAPCONTROL">
            <summary>The WM\_CAP\_SET\_CALLBACK\_CAPCONTROL message sets a callback function in the application giving it precise recording control. You can send this message explicitly or by using the capSetCallbackOnCapControl macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the callback function, of type [**capControlCallback**](/windows/desktop/api/Vfw/nc-vfw-capcontrolcallback). Specify **NULL** for this parameter to disable a previously installed callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if a streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>A single callback function is used to give the application precise control over the moments that streaming capture begins and completes. The capture window first calls the procedure with *nState* set to CONTROLCALLBACK\_PREROLL after all buffers have been allocated and all other capture preparations have finished. This gives the application the ability to preroll video sources, returning from the callback function at the exact moment recording is to begin. A return value of **TRUE** from the callback function continues capture, and a return value of **FALSE** aborts capture. After capture begins, this callback function will be called frequently with *nState* set to CONTROLCALLBACK\_CAPTURING to allow the application to end capture by returning **FALSE**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_PAGEINIT">
            <summary>An Active Directory property sheet extension calls the ADsPropGetInitInfo to obtain data about regarding the directory object that the property sheet extension applies to.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-pageinit">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_PAGEHWND">
            <summary>An Active Directory directory service property sheet extension calls the ADsPropSetHwnd to inform the notification object of the property page window handle.</summary>
            <returns>This message has no return value.</returns>
            <remarks>An Active Directory property sheet extension normally calls the [**ADsPropSetHwnd**](/windows/desktop/api/Adsprop/nf-adsprop-adspropsethwnd) function while processing the [**WM\_INITDIALOG**](../dlgbox/wm-initdialog.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_CHANGE">
            <summary>The WM\_ADSPROP\_NOTIFY\_CHANGE message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-change">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_APPLY">
            <summary>An Active Directory directory service property sheet extension sends the WM\_ADSPROP\_NOTIFY\_APPLY message to the notification object if the property page PSN\_APPLY handler succeeds.</summary>
            <returns>This message has no return value.</returns>
            <remarks>When adding pages to the Active Directory Manager MMC snap-in, Active Directory MMC property sheets create the notification objects by a call to the [**ADsPropCreateNotifyObj**](/windows/desktop/api/Adsprop/nf-adsprop-adspropcreatenotifyobj) function, and then passes the notification object handle to each property page.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_SETFOCUS">
            <summary>The WM\_ADSPROP\_NOTIFY\_SETFOCUS message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-setfocus">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_FOREGROUND">
            <summary>The WM\_ADSPROP\_NOTIFY\_FOREGROUND message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-foreground">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_EXIT">
            <summary>An Active Directory property sheet extension sends the WM\_ADSPROP\_NOTIFY\_EXIT message to the notification object when the notification object is no longer required.</summary>
            <returns>This message has no return value.</returns>
            <remarks>The notification object will delete itself in response to this message. When this message has been sent, the notification object handle should be considered invalid.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_ERROR">
            <summary>The WM\_ADSPROP\_NOTIFY\_ERROR message adds an error message to a list of error messages that are displayed by calling the ADsPropShowErrorDialog function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>The [**ADsPropSendErrorMessage**](/windows/desktop/api/Adsprop/nf-adsprop-adspropsenderrormessage) function is the preferred method of sending this message. The error messages added by the **WM\_ADSPROP\_NOTIFY\_ERROR** message are accumulated until [**ADsPropShowErrorDialog**](/windows/desktop/api/Adsprop/nf-adsprop-adspropshowerrordialog) is called. **ADsPropShowErrorDialog** combines and displays the accumulated error messages. When the error dialog is dismissed, the accumulated error messages are deleted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-error#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RASDIALEVENT">
            <summary>The operating system sends a WM\_RASDIALEVENT message to a window procedure when a change of state event occurs during a RAS connection process.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/RRAS/wm-rasdialevent">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DeleteObject(Windows.Win32.Graphics.Gdi.HGDIOBJ)">
            <summary>The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.</summary>
            <param name="ho">A handle to a logical pen, brush, font, bitmap, region, or palette.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the specified handle is not valid or is currently selected into a DC, the return value is zero.</para>
            </returns>
            <remarks>
            <para>Do not delete a drawing object (pen or brush) while it is still selected into a DC. When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-deleteobject#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CloseHandle(Windows.Win32.Foundation.HANDLE)">
            <summary>Closes an open object handle.</summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
            </returns>
            <remarks>
            <para>The <b>CloseHandle</b> function closes handles to the following objects: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetDpiForWindow(Windows.Win32.Foundation.HWND)">
            <summary>Returns the dots per inch (dpi) value for the specified window.</summary>
            <param name="hwnd">The window that you want to get information about.</param>
            <returns>The DPI for the window, which depends on the [DPI_AWARENESS](/windows/win32/api/windef/ne-windef-dpi_awareness) of the window. See the **Remarks** section for more information. An invalid *hwnd* value will result in a return value of 0.</returns>
            <remarks>
            <para>The following table indicates the return value of <b>GetDpiForWindow</b> based on the [DPI_AWARENESS](/windows/win32/api/windef/ne-windef-dpi_awareness) of the provided *hwnd*. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdpiforwindow#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.IsWindowVisible(Windows.Win32.Foundation.HWND)">
            <summary>Determines the visibility state of the specified window.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window to be tested.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-iswindowvisible#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the specified window, its parent window, its parent's parent window, and so forth, have the <b>WS_VISIBLE</b> style, the return value is nonzero. Otherwise, the return value is zero. Because the return value specifies whether the window has the <b>WS_VISIBLE</b> style, it may be nonzero even if the window is totally obscured by other windows.</para>
            </returns>
            <remarks>
            <para>The visibility state of a window is indicated by the <b>WS_VISIBLE</b> style bit. When <b>WS_VISIBLE</b> is set, the window is displayed and subsequent drawing into it is displayed as long as the window has the <b>WS_VISIBLE</b> style. Any drawing to a window with the <b>WS_VISIBLE</b> style will not be displayed if the window is obscured by other windows or is clipped by its parent window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-iswindowvisible#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetWindowLong(Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.WINDOW_LONG_PTR_INDEX,System.Int32)">
            <summary>Changes an attribute of the specified window. The function also sets the 32-bit (long) value at the specified offset into the extra window memory. (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window and, indirectly, the class to which the window belongs.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongw#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="nIndex">Type: <b>int</b></param>
            <param name="dwNewLong">
            <para>Type: <b>LONG</b> The replacement value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongw#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LONG</b> If the function succeeds, the return value is the previous value of the specified 32-bit integer. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not clear the last error information. This makes it difficult to determine success or failure. To deal with this, you should clear the last error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0 before calling <b>SetWindowLong</b>. Then, function failure will be indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.</para>
            </returns>
            <remarks>
            <para>Certain window data is cached, so changes you make using <b>SetWindowLong</b> will not take effect until you call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowpos">SetWindowPos</a> function. Specifically, if you change any of the frame styles, you must call <b>SetWindowPos</b> with the <b>SWP_FRAMECHANGED</b> flag for the cache to be updated properly. If you use <b>SetWindowLong</b> with the <b>GWL_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. If you use <b>SetWindowLong</b> with the <b>DWL_MSGRESULT</b> index to set the return value for a message processed by a dialog procedure, you should return <b>TRUE</b> directly afterward. Otherwise, if you call any function that results in your dialog procedure receiving a window message, the nested window message could overwrite the return value you set using <b>DWL_MSGRESULT</b>. Calling <b>SetWindowLong</b> with the <b>GWL_WNDPROC</b> index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The <b>SetWindowLong</b> function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>. This allows the application to create a chain of window procedures. Reserve extra window memory by specifying a nonzero value in the <b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. You must not call <b>SetWindowLong</b> with the <b>GWL_HWNDPARENT</b> index to change the parent of a child window. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setparent">SetParent</a> function. If the window has a class style of <b>CS_CLASSDC</b> or <b>CS_OWNDC</b>, do not set the extended window styles <b>WS_EX_COMPOSITED</b> or <b>WS_EX_LAYERED</b>. Calling <b>SetWindowLong</b> to set the style on a progressbar will reset its position.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongw#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetWindowLong(Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.WINDOW_LONG_PTR_INDEX)">
            <summary>Retrieves information about the specified window. (GetWindowLongW)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window and, indirectly, the class to which the window belongs.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlongw#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="nIndex">Type: <b>int</b></param>
            <returns>
            <para>Type: <b>LONG</b> If the function succeeds, the return value is the requested value. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> has not been called previously, <b>GetWindowLong</b> returns zero for values in the extra window or class memory.</para>
            </returns>
            <remarks>
            <para>Reserve extra window memory by specifying a nonzero value in the <b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlongw#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetWindowRgn(Windows.Win32.Foundation.HWND,System.Runtime.InteropServices.SafeHandle,Windows.Win32.Foundation.BOOL)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.SetWindowRgn(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Foundation.BOOL)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetWindowRgn(Windows.Win32.Foundation.HWND,Windows.Win32.Graphics.Gdi.HRGN,Windows.Win32.Foundation.BOOL)">
            <summary>The SetWindowRgn function sets the window region of a window.</summary>
            <param name="hWnd">A handle to the window whose window region is to be set.</param>
            <param name="hRgn">
            <para>A handle to a region. The function sets the window region of the window to this region. If <i>hRgn</i> is <b>NULL</b>, the function sets the window region to <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowrgn#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="bRedraw">
            <para>Specifies whether the system redraws the window after setting the window region. If <i>bRedraw</i> is <b>TRUE</b>, the system does so; otherwise, it does not. Typically, you set <i>bRedraw</i> to <b>TRUE</b> if the window is visible.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowrgn#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>When this function is called, the system sends the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-windowposchanging">WM_WINDOWPOSCHANGING</a> and <b>WM_WINDOWPOSCHANGING</b> messages to the window. The coordinates of a window's window region are relative to the upper-left corner of the window, not the client area of the window. <div class="alert"><b>Note</b>If the window layout is right-to-left (RTL), the coordinates are relative to the upper-right corner of the window. See <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">Window Layout and Mirroring</a>.</div> <div></div> After a successful call to <b>SetWindowRgn</b>, the system owns the region specified by the region handle <i>hRgn</i>. The system does not make a copy of the region. Thus, you should not make any further function calls with this region handle. In particular, do not delete this region handle. The system deletes the region handle when it no longer needed. To obtain the window region of a window, call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowrgn">GetWindowRgn</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowrgn#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetWindowRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetWindowRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetWindowRect(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)">
            <summary>Retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that are relative to the upper-left corner of the screen.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowrect#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="lpRect">
            <para>Type: <b>LPRECT</b> A pointer to a  <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the screen coordinates of the upper-left and lower-right corners of the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowrect#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>In conformance with conventions for the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure, the bottom-right coordinates of the returned rectangle are exclusive. In other words, the pixel at (<b>right</b>, <b>bottom</b>) lies immediately outside the rectangle. GetWindowRect is virtualized for DPI. In Windows Vista and later, the Window Rect now includes the area occupied by the drop shadow. Calling GetWindowRect will have different behavior depending on whether the window has ever been shown or not.  If the window has not been shown before, GetWindowRect will not include the area of the drop shadow. To get the window bounds excluding the drop shadow, use <a href="https://docs.microsoft.com/windows/win32/api/dwmapi/nf-dwmapi-dwmgetwindowattribute">DwmGetWindowAttribute</a>, specifying <b>DWMWA_EXTENDED_FRAME_BOUNDS</b>.  Note that unlike the Window Rect, the DWM Extended Frame Bounds are not adjusted for DPI.  Getting the extended frame bounds can only be done after the window has been shown at least once.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowrect#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetSystemMetrics(Windows.Win32.UI.WindowsAndMessaging.SYSTEM_METRICS_INDEX)">
            <summary>Retrieves the specified system metric or system configuration setting.</summary>
            <param name="nIndex">Type: <b>int</b></param>
            <returns>
            <para>Type: <b>int</b> If the function succeeds, the return value is the requested system metric or configuration setting. If the function fails, the return value is 0. <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not provide extended error information.</para>
            </returns>
            <remarks>
            <para>System metrics can vary from display to display. <b>GetSystemMetrics</b>(SM_CMONITORS) counts only visible display monitors. This is different from <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaymonitors">EnumDisplayMonitors</a>, which enumerates both visible display monitors and invisible  pseudo-monitors that are associated with mirroring drivers. An invisible pseudo-monitor is associated with a pseudo-device used to mirror application drawing for remoting or other purposes. The SM_ARRANGE setting specifies how the system arranges minimized windows, and consists of a starting position and a direction. The starting position can be one of the following values.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getsystemmetrics#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.IsWindow(Windows.Win32.Foundation.HWND)">
            <summary>Determines whether the specified window handle identifies an existing window.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window to be tested.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-iswindow#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the window handle identifies an existing window, the return value is nonzero. If the window handle does not identify an existing window, the return value is zero.</para>
            </returns>
            <remarks>A thread should not use <b>IsWindow</b> for a window that it did not create because the window could be destroyed after this function was called. Further, because window handles are recycled the handle could even point to a different window.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyIcon(Windows.Win32.UI.WindowsAndMessaging.HICON)">
            <summary>Destroys an icon and frees any memory the icon occupied.</summary>
            <param name="hIcon">
            <para>Type: <b>HICON</b> A handle to the icon to be destroyed. The icon must not be in use.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>It is only necessary to call <b>DestroyIcon</b> for icons and cursors created with the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if called without the <b>LR_SHARED</b> flag), <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyicon">CopyIcon</a>. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetWindowThemeAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.WINDOWTHEMEATTRIBUTETYPE,System.ReadOnlySpan{System.Byte})">
            <inheritdoc cref="M:Windows.Win32.PInvoke.SetWindowThemeAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.WINDOWTHEMEATTRIBUTETYPE,System.Void*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetWindowThemeAttribute(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.WINDOWTHEMEATTRIBUTETYPE,System.Void*,System.UInt32)">
            <summary>Sets attributes to control how visual styles are applied to a specified window.</summary>
            <param name="hwnd">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b> Handle to a window to apply changes to.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/nf-uxtheme-setwindowthemeattribute#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="pvAttribute">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">PVOID</a></b> A pointer that specifies attributes to set. Type is determined by the value of the <i>eAttribute</i> value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/nf-uxtheme-setwindowthemeattribute#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="cbAttribute">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">DWORD</a></b> Specifies the size, in bytes, of the data pointed to by <i>pvAttribute</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/nf-uxtheme-setwindowthemeattribute#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HRESULT</a></b> If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/nf-uxtheme-setwindowthemeattribute">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.HRESULT">
            <remarks>
            <para>The **HRESULT** data type is the same as the [SCODE](scode.md) data type. An **HRESULT** value consists of the following fields: - A 1-bit code indicating severity, where zero represents success and 1 represents failure. - A 4-bit reserved value. - An 11-bit code indicating responsibility for the error or warning, also known as a facility code. - A 16-bit code describing the error or warning. Most MAPI interface methods and functions return **HRESULT** values to provide detailed cause formation. **HRESULT** values are also used widely in OLE interface methods. OLE provides several macros for converting between **HRESULT** values and **SCODE** values, another common data type for error handling. > [!NOTE] > In 64-bit MAPI, **HRESULT** is still a 32-bit value. For information about the OLE use of **HRESULT** values, see the  *OLE Programmer's Reference*. For more information about the use of these values in MAPI, see [Error Handling](error-handling-in-mapi.md) and any of the following interface methods: [IABLogon::GetLastError](iablogon-getlasterror.md) [IMAPISupport::GetLastError](imapisupport-getlasterror.md) [IMAPIControl::GetLastError](imapicontrol-getlasterror.md) [IMAPITable::GetLastError](imapitable-getlasterror.md) [IMAPIProp::GetLastError](imapiprop-getlasterror.md) [IMAPIViewAdviseSink::OnPrint](imapiviewadvisesink-onprint.md)</para>
            <para><see href="https://learn.microsoft.com/office/client-developer/outlook/mapi/hresult#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Foundation.HRESULT.ThrowOnFailure(System.IntPtr)">
            <inheritdoc cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
            <param name="errorInfo">
            A pointer to the IErrorInfo interface that provides more information about the
            error. You can specify <see cref="F:System.IntPtr.Zero"/> to use the current IErrorInfo interface, or
            <c>new IntPtr(-1)</c> to ignore the current IErrorInfo interface and construct the exception
            just from the error code.
            </param>
            <returns><see langword="this"/> <see cref="T:Windows.Win32.Foundation.HRESULT"/>, if it does not reflect an error.</returns>
            <seealso cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)"/>
        </member>
        <member name="F:Windows.Win32.Foundation.HRESULT.S_OK">
            <summary>Documentation varies per use. Refer to each: <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnconnectioncontextevents-onsetprovisionedcontextcomplete">IMbnConnectionContextEvents.OnSetProvisionedContextComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnconnectionevents-onconnectcomplete">IMbnConnectionEvents.OnConnectComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-onchangecomplete">IMbnPinEvents.OnChangeComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-ondisablecomplete">IMbnPinEvents.OnDisableComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-onenablecomplete">IMbnPinEvents.OnEnableComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-onentercomplete">IMbnPinEvents.OnEnterComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinevents-onunblockcomplete">IMbnPinEvents.OnUnblockComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnpinmanagerevents-ongetpinstatecomplete">IMbnPinManagerEvents.OnGetPinStateComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnradioevents-onsetsoftwareradiostatecomplete">IMbnRadioEvents.OnSetSoftwareRadioStateComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnserviceactivationevents-onactivationcomplete">IMbnServiceActivationEvents.OnActivationComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsetsmsconfigurationcomplete">IMbnSmsEvents.OnSetSmsConfigurationComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsmsdeletecomplete">IMbnSmsEvents.OnSmsDeleteComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsmsreadcomplete">IMbnSmsEvents.OnSmsReadComplete</see>, <see href="https://learn.microsoft.com/windows/win32/api/mbnapi/nf-mbnapi-imbnsmsevents-onsmssendcomplete">IMbnSmsEvents.OnSmsSendComplete</see>.</summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PCWSTR">
            <summary>
            A pointer to a null-terminated, constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCWSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, up to the first null character (exclusive).
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCWSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.RECT">
            <summary>The RECT structure defines a rectangle by the coordinates of its upper-left and lower-right corners.</summary>
            <remarks>The RECT structure is identical to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rectl">RECTL</a> structure.</remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.left">
            <summary>Specifies the <i>x</i>-coordinate of the upper-left corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.top">
            <summary>Specifies the <i>y</i>-coordinate of the upper-left corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.right">
            <summary>Specifies the <i>x</i>-coordinate of the lower-right corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.bottom">
            <summary>Specifies the <i>y</i>-coordinate of the lower-right corner of the rectangle.</summary>
        </member>
        <member name="P:Windows.Win32.__char_260.Length">
            <summary>The length of the inline array.</summary>
        </member>
        <member name="P:Windows.Win32.__char_260.Item(System.Int32)">
            <summary>
            Gets a ref to an individual element of the inline array.
             Important : When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
            </summary>
        </member>
        <member name="M:Windows.Win32.__char_260.AsSpan">
            <summary>
            Gets this inline array as a span.
            </summary>
            <remarks>
             Important : When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
            </remarks>
        </member>
        <member name="M:Windows.Win32.__char_260.AsReadOnlySpan">
            <summary>
            Gets this inline array as a span.
            </summary>
            <remarks>
             Important : When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
            </remarks>
        </member>
        <member name="M:Windows.Win32.__char_260.ToString(System.Int32)">
            <summary>
            Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="P:Windows.Win32.__char_260.Length"/>.
            </exception>
        </member>
        <member name="M:Windows.Win32.__char_260.ToString">
            <summary>
            Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE">
            <summary>Flags used by the [DwmGetWindowAttribute](/windows/desktop/api/dwmapi/nf-dwmapi-dwmgetwindowattribute) and [DwmSetWindowAttribute](/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute) functions.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_NCRENDERING_ENABLED">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmgetwindowattribute">DwmGetWindowAttribute</a>. Discovers whether non-client rendering is enabled. The retrieved value is of type <b>BOOL</b>. <b>TRUE</b> if non-client rendering is enabled; otherwise, <b>FALSE</b>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_NCRENDERING_POLICY">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Sets the non-client rendering policy. The <i>pvAttribute</i> parameter points to a value from the <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/ne-dwmapi-dwmncrenderingpolicy">DWMNCRENDERINGPOLICY</a> enumeration.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_TRANSITIONS_FORCEDISABLED">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Enables or forcibly disables DWM transitions. The <i>pvAttribute</i> parameter points to a value of type <b>BOOL</b>. <b>TRUE</b> to disable transitions, or <b>FALSE</b> to enable transitions.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_ALLOW_NCPAINT">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Enables content rendered in the non-client area to be visible on the frame drawn by DWM. The <i>pvAttribute</i> parameter points to a value of type <b>BOOL</b>. <b>TRUE</b> to enable content rendered in the non-client area to be visible on the frame; otherwise, <b>FALSE</b>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_CAPTION_BUTTON_BOUNDS">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmgetwindowattribute">DwmGetWindowAttribute</a>. Retrieves the bounds of the caption button area in the window-relative space. The retrieved value is of type <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>. If the window is minimized or otherwise not visible to the user, then the value of the **RECT** retrieved is undefined. You should check whether the retrieved **RECT** contains a boundary that you can work with, and if it doesn't then you can conclude that the window is minimized or otherwise not visible.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_NONCLIENT_RTL_LAYOUT">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Specifies whether non-client content is right-to-left (RTL) mirrored. The <i>pvAttribute</i> parameter points to a value of type <b>BOOL</b>. <b>TRUE</b> if the non-client content is right-to-left (RTL) mirrored; otherwise, <b>FALSE</b>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_FORCE_ICONIC_REPRESENTATION">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Forces the window to display an iconic thumbnail or peek representation (a static bitmap), even if a live or snapshot representation of the window is available. This value is normally set during a window's creation, and not changed throughout the window's lifetime. Some scenarios, however, might require the value to change over time. The <i>pvAttribute</i> parameter points to a value of type <b>BOOL</b>. <b>TRUE</b> to require a iconic thumbnail or peek representation; otherwise, <b>FALSE</b>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_FLIP3D_POLICY">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Sets how Flip3D treats the window. The <i>pvAttribute</i> parameter points to a value from the <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/ne-dwmapi-dwmflip3dwindowpolicy">DWMFLIP3DWINDOWPOLICY</a> enumeration.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_EXTENDED_FRAME_BOUNDS">
            <summary>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmgetwindowattribute">DwmGetWindowAttribute</a>. Retrieves the extended frame bounds rectangle in screen space. The retrieved value is of type <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_HAS_ICONIC_BITMAP">
            <summary>
            <para>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. The window will provide a bitmap for use by DWM as an iconic thumbnail or peek representation (a static bitmap) for the window. <b>DWMWA_HAS_ICONIC_BITMAP</b> can be specified with <b>DWMWA_FORCE_ICONIC_REPRESENTATION</b>. <b>DWMWA_HAS_ICONIC_BITMAP</b> normally is set during a window's creation and not changed throughout the window's lifetime. Some scenarios, however, might require the value to change over time. The <i>pvAttribute</i> parameter points to a value of type <b>BOOL</b>.  <b>TRUE</b> to inform DWM that the window will provide an iconic thumbnail or peek representation; otherwise, <b>FALSE</b>. <b>WindowsVista and earlier:</b>This value is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_DISALLOW_PEEK">
            <summary>
            <para>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Do not show peek preview for the window. The peek view shows a full-sized preview of the window when the mouse hovers over the window's thumbnail in the taskbar. If this attribute is set, hovering the mouse pointer over the window's thumbnail dismisses peek (in case another window in the group has a peek preview showing). The <i>pvAttribute</i> parameter points to a value of type <b>BOOL</b>. <b>TRUE</b> to prevent peek functionality, or <b>FALSE</b> to allow it. <b>WindowsVista and earlier:</b>This value is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_EXCLUDED_FROM_PEEK">
            <summary>
            <para>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Prevents a window from fading to a glass sheet when peek is invoked. The <i>pvAttribute</i> parameter points to a value of type <b>BOOL</b>. <b>TRUE</b> to prevent the window from fading during another window's peek, or <b>FALSE</b> for normal behavior. <b>WindowsVista and earlier:</b>This value is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_CLOAK">
            <summary>
            <para>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Cloaks the window such that it is not visible to the user. The window is still composed by DWM. <b>Using with DirectComposition:</b>Use the DWMWA_CLOAK flag to cloak the layered child window when animating a representation of the window's content via a DirectComposition visual that has been associated with the layered child window. For more details on this usage case, see <a href="https://docs.microsoft.com/windows/desktop/directcomp/how-to--animate-the-bitmap-of-a-layered-child-window">How to animate the bitmap of a layered child window</a>. <b>Windows7 and earlier:</b>This value is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_CLOAKED">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_FREEZE_REPRESENTATION">
            <summary>
            <para>Use with <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmsetwindowattribute">DwmSetWindowAttribute</a>. Freeze the window's thumbnail image with its current visuals. Do no further live updates on the thumbnail image to match the window's contents. <b>Windows7 and earlier:</b>This value is not supported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_USE_HOSTBACKDROPBRUSH">
            <summary>
            <para>Use with [DwmSetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmsetwindowattribute). Enables a non-UWP window to use host backdrop brushes. If this flag is set, then a Win32 app that calls [Windows::UI::Composition](/uwp/api/windows.ui.composition) APIs can build transparency effects using the host backdrop brush (see [Compositor.CreateHostBackdropBrush](/uwp/api/windows.ui.composition.compositor.createhostbackdropbrush)). The <i>pvAttribute</i> parameter points to a value of type <b>BOOL</b>. <b>TRUE</b> to enable host backdrop brushes for the window, or <b>FALSE</b> to disable it. This value is supported starting with Windows 11 Build 22000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE">
            <summary>
            <para>Use with [DwmSetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmsetwindowattribute). Allows the window frame for this window to be drawn in dark mode colors when the dark mode system setting is enabled. For compatibility reasons, all windows default to light mode regardless of the system setting. The <i>pvAttribute</i> parameter points to a value of type **BOOL**. <b>TRUE</b> to honor dark mode for the window, <b>FALSE</b> to always use light mode. This value is supported starting with Windows 11 Build 22000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_WINDOW_CORNER_PREFERENCE">
            <summary>
            <para>Use with [DwmSetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmsetwindowattribute). Specifies the rounded corner preference for a window. The <i>pvAttribute</i> parameter points to a value of type [DWM_WINDOW_CORNER_PREFERENCE](ne-dwmapi-dwm_window_corner_preference.md). This value is supported starting with Windows 11 Build 22000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_BORDER_COLOR">
            <summary>
            <para>Use with [DwmSetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmsetwindowattribute). Specifies the color of the window border. The <i>pvAttribute</i> parameter points to a value of type [COLORREF](/windows/win32/gdi/colorref). The app is responsible for changing the border color according to state changes, such as a change in window activation. This value is supported starting with Windows 11 Build 22000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_CAPTION_COLOR">
            <summary>
            <para>Use with [DwmSetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmsetwindowattribute). Specifies the color of the caption. The <i>pvAttribute</i> parameter points to a value of type [COLORREF](/windows/win32/gdi/colorref). This value is supported starting with Windows 11 Build 22000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_TEXT_COLOR">
            <summary>
            <para>Use with [DwmSetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmsetwindowattribute). Specifies the color of the caption text. The <i>pvAttribute</i> parameter points to a value of type [COLORREF](/windows/win32/gdi/colorref). This value is supported starting with Windows 11 Build 22000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_VISIBLE_FRAME_BORDER_THICKNESS">
            <summary>
            <para>Use with [DwmGetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmgetwindowattribute). Retrieves the width of the outer border that the DWM would draw around this window. The value can vary depending on the DPI of the window. The <i>pvAttribute</i> parameter points to a value of type **UINT**. This value is supported starting with Windows 11 Build 22000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE">
            <summary>
            <para>Use with [DwmGetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmgetwindowattribute) or [DwmSetWindowAttribute](/windows/win32/api/dwmapi/nf-dwmapi-dwmsetwindowattribute). Retrieves or specifies the system-drawn backdrop material of a window, including behind the non-client area. The *pvAttribute* parameter points to a value of type [DWM_SYSTEMBACKDROP_TYPE](ne-dwmapi-dwm_systembackdrop_type.md). This value is supported starting with Windows 11 Build 22621.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWMWINDOWATTRIBUTE.DWMWA_LAST">
            <summary>The maximum recognized <b>DWMWINDOWATTRIBUTE</b> value, used for validation purposes.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Dwm.DWM_SYSTEMBACKDROP_TYPE">
            <summary>Flags for specifying the system-drawn backdrop material of a window, including behind the non-client area.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_SYSTEMBACKDROP_TYPE.DWMSBT_AUTO">
            <summary>The default. Let the Desktop Window Manager (DWM) automatically decide the system-drawn backdrop material for this window.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_SYSTEMBACKDROP_TYPE.DWMSBT_NONE">
            <summary>Don't draw any system backdrop.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_SYSTEMBACKDROP_TYPE.DWMSBT_MAINWINDOW">
            <summary>Draw the backdrop material effect corresponding to a long-lived window.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_SYSTEMBACKDROP_TYPE.DWMSBT_TRANSIENTWINDOW">
            <summary>Draw the backdrop material effect corresponding to a transient window.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_SYSTEMBACKDROP_TYPE.DWMSBT_TABBEDWINDOW">
            <summary>Draw the backdrop material effect corresponding to a window with a tabbed title bar.</summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Dwm.DWM_WINDOW_CORNER_PREFERENCE">
            <summary>The DWM_WINDOW_CORNER_PREFERENCE enumeration (dwmapi.h) specifies the rounded corner preference for a window.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_WINDOW_CORNER_PREFERENCE.DWMWCP_DEFAULT">
            <summary>Let the system decide when to round window corners.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_WINDOW_CORNER_PREFERENCE.DWMWCP_DONOTROUND">
            <summary>Never round window corners.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_WINDOW_CORNER_PREFERENCE.DWMWCP_ROUND">
            <summary>Round the corners, if appropriate.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Dwm.DWM_WINDOW_CORNER_PREFERENCE.DWMWCP_ROUNDSMALL">
            <summary>Round the corners if appropriate, with a small radius.</summary>
        </member>
        <member name="T:Windows.Win32.UI.Controls.MARGINS">
            <summary>Returned by the GetThemeMargins function to define the margins of windows that have visual styles applied.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ns-uxtheme-margins">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Controls.MARGINS.cxLeftWidth">
            <summary>
            <para>Type: <b>int</b> Width of the left border that retains its size.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ns-uxtheme-margins#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.MARGINS.cxRightWidth">
            <summary>
            <para>Type: <b>int</b> Width of the right border that retains its size.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ns-uxtheme-margins#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.MARGINS.cyTopHeight">
            <summary>
            <para>Type: <b>int</b> Height of the top border that retains its size.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ns-uxtheme-margins#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.MARGINS.cyBottomHeight">
            <summary>
            <para>Type: <b>int</b> Height of the bottom border that retains its size.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ns-uxtheme-margins#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Controls.WINDOWTHEMEATTRIBUTETYPE">
            <summary>Specifies the type of visual style attribute to set on a window.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ne-uxtheme-windowthemeattributetype">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Controls.WINDOWTHEMEATTRIBUTETYPE.WTA_NONCLIENT">
            <summary>Non-client area window attributes will be set.</summary>
        </member>
        <member name="T:Windows.Win32.UI.Controls.WTA_OPTIONS">
            <summary>Defines options that are used to set window visual style attributes.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ns-uxtheme-wta_options">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Controls.WTA_OPTIONS.dwFlags">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">DWORD</a></b> A combination of flags that modify window visual style attributes. Can be a combination of the <a href="https://docs.microsoft.com/windows/desktop/Controls/wtnca">WTNCA</a> constants.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ns-uxtheme-wta_options#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Controls.WTA_OPTIONS.dwMask">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">DWORD</a></b> A bitmask that describes how the values specified in <b>dwFlags</b> should be applied. If the bit corresponding to a value in <b>dwFlags</b> is 0, that flag will be removed. If the bit is 1, the flag will be added.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/uxtheme/ns-uxtheme-wta_options#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList.HrInit">
            <summary>Initializes the taskbar list object. This method must be called before any other ITaskbarList methods can be called.</summary>
            <returns>
            <para>Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the method fails, no other methods can be called. The calling application should release the interface pointer.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-hrinit">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList.AddTab(Windows.Win32.Foundation.HWND)">
            <summary>Adds an item to the taskbar.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> A handle to the window to be added to the taskbar.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-addtab#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para>Any type of window can be added to the taskbar, but it is recommended that the window at least have the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">WS_CAPTION</a> style. Any window added with this method must be removed with the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-deletetab">DeleteTab</a> method when the added window is destroyed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-addtab#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList.DeleteTab(Windows.Win32.Foundation.HWND)">
            <summary>Deletes an item from the taskbar.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> A handle to the window to be deleted from the taskbar.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-deletetab#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-deletetab">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList.ActivateTab(Windows.Win32.Foundation.HWND)">
            <summary>Activates an item on the taskbar. The window is not actually activated; the window's item on the taskbar is merely displayed as active.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> A handle to the window on the taskbar to be displayed as active.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-activatetab#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-activatetab">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList.SetActiveAlt(Windows.Win32.Foundation.HWND)">
            <summary>Marks a taskbar item as active but does not visually activate it.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> A handle to the window to be marked as active.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-setactivealt#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks><b>SetActiveAlt</b> marks the item associated with <i>hwnd</i> as the currently active item for the window's process without changing the pressed state of any item. Any user action that would activate a different tab in that process will activate the tab associated with <i>hwnd</i> instead. The active state of the window's item is not guaranteed to be preserved when the process associated with <i>hwnd</i> is not active. To ensure that a given tab is always active, call <b>SetActiveAlt</b> whenever any of your windows are activated. Calling <b>SetActiveAlt</b> with a <b>NULL</b> <i>hwnd</i> clears this state.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.UI.Shell.ITaskbarList2.MarkFullscreenWindow(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.BOOL)" -->
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.SetProgressValue(Windows.Win32.Foundation.HWND,System.UInt64,System.UInt64)">
            <summary>Displays or updates a progress bar hosted in a taskbar button to show the specific percentage completed of the full operation.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> The handle of the window whose associated taskbar button is being used as a progress indicator.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressvalue#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="ullCompleted">
            <para>Type: <b>ULONGLONG</b> An application-defined value that indicates the proportion of the operation that has been completed at the time the method is called.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressvalue#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="ullTotal">
            <para>Type: <b>ULONGLONG</b> An application-defined value that specifies the value <i>ullCompleted</i> will have when the operation is complete.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressvalue#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><h3><a id="Determinate_Progress_Bar_Lifecycle"></a><a id="determinate_progress_bar_lifecycle"></a><a id="DETERMINATE_PROGRESS_BAR_LIFECYCLE"></a>Determinate Progress Bar Lifecycle</h3> An application first calls <b>SetProgressValue</b> to begin the display of a determinate progress bar, and then calls it again as needed to update the bar as the progress changes. When progress is complete, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressstate">SetProgressState</a> with the TBPF_NOPROGRESS flag to dismiss the progress bar. <h3><a id="How_the_Taskbar_Button_Chooses_the_Progress_Indicator_for_a_Group"></a><a id="how_the_taskbar_button_chooses_the_progress_indicator_for_a_group"></a><a id="HOW_THE_TASKBAR_BUTTON_CHOOSES_THE_PROGRESS_INDICATOR_FOR_A_GROUP"></a>How the Taskbar Button Chooses the Progress Indicator for a Group</h3> The taskbar button can show a progress indicator for only one window at a time. When the taskbar button represents a group and more than one of the windows in that group are broadcasting progress information, the taskbar button chooses its progress display based on the following state priority.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressvalue#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.SetProgressState(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Shell.TBPFLAG)">
            <summary>Sets the type and state of the progress indicator displayed on a taskbar button.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> The handle of the window in which the progress of an operation is being shown. This window's associated taskbar button will display the progress bar.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressstate#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="tbpFlags">
            <para>Type: <b>TBPFLAG</b> Flags that control the current state of the progress button. Specify only one of the following flags; all states are mutually exclusive of all others.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressstate#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para>Progress bar information is not shown in high contrast color schemes to guarantee that no accessibility needs are compromised. Developers accustomed to the existing <a href="https://docs.microsoft.com/windows/desktop/Controls/progress-bar-control-reference">progress bar</a> control should find the taskbar button progress indicator to be a similar experience both in concept and visuals. Here, the taskbar button itself becomes a progress bar. A taskbar button's progress indicator should be a reflection of a more detailed progress bar in the associated window. This allows the user to see specifics, such as the percentage number and the amount of time remaining, that cannot be shown in a taskbar button. Also, because a taskbar button can show the progress of only a single window in a group, it allows the user to check the progress of individual windows. It also provides progress information to the user when the taskbar button cannot, such as in a high-contrast color scheme. Note that a taskbar button progress bar is not intended for use with normally peripheral actions such as the loading of a webpage or the printing of a document. That type of progress should continue to be shown in a window's <a href="https://docs.microsoft.com/windows/desktop/Controls/status-bar-reference">status bar</a>. The progress indicator is displayed between the taskbar button's icon or text and the background. If progress is shown for both the active taskbar button and an inactive button, shading in the respective progress bars is such that the active button is still obvious to the user. Also, button functionality such as the display of thumbnails continues to work normally when the button is being used to display progress. When exiting an error or paused state, call this method again with the <b>TBPF_NORMAL</b> or <b>TBPF_INDETERMINATE</b> flag to continue in the original state or <b>TBPF_NOPROGRESS</b> if the operation is canceled. <h3><a id="How_the_Taskbar_Button_Chooses_the_Progress_Indicator_for_a_Group"></a><a id="how_the_taskbar_button_chooses_the_progress_indicator_for_a_group"></a><a id="HOW_THE_TASKBAR_BUTTON_CHOOSES_THE_PROGRESS_INDICATOR_FOR_A_GROUP"></a>How the Taskbar Button Chooses the Progress Indicator for a Group</h3> The taskbar button can show a progress indicator for only one window at a time. This includes the situation where the taskbar button represents a group and more than one window in that group is broadcasting progress information. In that case, the taskbar button chooses its progress display based on state priority. State priority is shown in the following table with priority 1 being the highest.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setprogressstate#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.RegisterTab(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.HWND)">
            <summary>Informs the taskbar that a new tab or document thumbnail has been provided for display in an application's taskbar group flyout.</summary>
            <param name="hwndTab">
            <para>Type: <b>HWND</b> Handle of the tab or document window. This value is required and cannot be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-registertab#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="hwndMDI">
            <para>Type: <b>HWND</b> Handle of the application's main window. This value tells the taskbar which application's preview group to attach the new thumbnail to. This value is required and cannot be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-registertab#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If either parameter is <b>NULL</b>, this method returns an error.</para>
            </returns>
            <remarks>By itself, registering a tab thumbnail alone will not result in its being displayed. You must also call <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-settaborder">ITaskbarList3::SetTabOrder</a> to instruct the group where to display it.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.UnregisterTab(Windows.Win32.Foundation.HWND)">
            <summary>Removes a thumbnail from an application's preview group when that tab or document is closed in the application.</summary>
            <param name="hwndTab">
            <para>Type: <b>HWND</b> The handle of the tab window whose thumbnail is being removed. This is the same value with which the thumbnail was registered as part the group through <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-registertab">ITaskbarList3::RegisterTab</a>. This value is required and cannot be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-unregistertab#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise. If <i>hwndTab</i> is <b>NULL</b>, this method returns an error.</para>
            </returns>
            <remarks>It is the responsibility of the calling application to free <i>hwndTab</i> through <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a>. <b>UnregisterTab</b> must be called before the handle is freed.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.SetTabOrder(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.HWND)">
            <summary>Inserts a new thumbnail into a tabbed-document interface (TDI) or multiple-document interface (MDI) application's group flyout or moves an existing thumbnail to a new position in the application's group.</summary>
            <param name="hwndTab">
            <para>Type: <b>HWND</b> The handle of the tab window whose thumbnail is being placed. This value is required, must already be registered through <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-registertab">ITaskbarList3::RegisterTab</a>, and cannot be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-settaborder#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="hwndInsertBefore">
            <para>Type: <b>HWND</b> The handle of the tab window whose thumbnail that <i>hwndTab</i> is inserted to the left of. This handle must already be registered through <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-registertab">ITaskbarList3::RegisterTab</a>. If this value is <b>NULL</b>, the new thumbnail is added to the end of the list.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-settaborder#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>This method must be called for the thumbnail to be shown in the group. Call it after you have called <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-registertab">ITaskbarList3::RegisterTab</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.SetTabActive(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.HWND,System.UInt32)">
            <summary>Informs the taskbar that a tab or document window has been made the active window.</summary>
            <param name="hwndTab">
            <para>Type: <b>HWND</b> Handle of the active tab window. This handle must already be registered through <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-registertab">ITaskbarList3::RegisterTab</a>. This value can be <b>NULL</b> if no tab is active.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-settabactive#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="hwndMDI">
            <para>Type: <b>HWND</b> Handle of the application's main window. This value tells the taskbar which group the thumbnail is a member of. This value is required and cannot be <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-settabactive#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="dwReserved">
            <para>Type: <b>DWORD</b> Reserved; set to 0.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-settabactive#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-settabactive">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.ThumbBarAddButtons(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.UI.Shell.THUMBBUTTON*)">
            <summary>Adds a thumbnail toolbar with a specified set of buttons to the thumbnail image of a window in a taskbar button flyout.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> The handle of the window whose thumbnail representation will receive the toolbar. This handle must belong to the calling process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbaraddbuttons#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="cButtons">
            <para>Type: <b>UINT</b> The number of buttons defined in the array pointed to by <i>pButton</i>. The maximum number of buttons allowed is 7.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbaraddbuttons#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="pButton">
            <para>Type: <b>LPTHUMBBUTTON</b> A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ns-shobjidl_core-thumbbutton">THUMBBUTTON</a> structures. Each <b>THUMBBUTTON</b> defines an individual button to be added to the toolbar. Buttons cannot be added or deleted later, so this must be the full defined set. Buttons also cannot be reordered, so their order in the array, which is the order in which they are displayed left to right, will be their permanent order.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbaraddbuttons#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise, including the following: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>This method allows an application to define buttons for an active toolbar control that is embedded in a window's taskbar thumbnail preview. This provides access to the window's essential commands without making the user restore or activate the window. For example, Windows Media Player might offer standard media transport controls such as play, pause, mute, and stop. The toolbar used in the thumbnail is essentially a standard <a href="https://docs.microsoft.com/windows/desktop/Controls/toolbar-control-reference">toolbar</a> control. It has a maximum of seven buttons, and it is center-aligned, transparent, and displayed in an area beneath the thumbnail rather than covering any portion of it. Each button's ID, image, tooltip, and state are defined in a <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ns-shobjidl_core-thumbbutton">THUMBBUTTON</a> structure, which is then passed to the taskbar. The application can then subsequently show, alter, or hide buttons from the thumbnail toolbar as required by its current state by calling <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarupdatebuttons">ITaskbarList3::ThumbBarUpdateButtons</a>. When a button in a thumbnail toolbar is clicked, the window associated with that thumbnail is sent a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> message with the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of its <i>wParam</i> parameter set to <b>THBN_CLICKED</b> and the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> to the button ID. After a toolbar has been added to a thumbnail, buttons can be altered only through <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarupdatebuttons">ITaskbarList3::ThumbBarUpdateButtons</a>. While individual buttons cannot be added or removed, they can be shown and hidden through <b>ThumbBarUpdateButtons</b> as needed. The toolbar itself cannot be removed without re-creating the window itself. Because there is a limited amount of space in which to display thumbnails, as well as a constantly changing number of thumbnails to display, applications are not guaranteed a specific toolbar size. If display space is low, buttons in the toolbar are truncated from right to left as needed. Therefore, an application should prioritize the commands associated with its buttons to ensure that those of highest priority are to the left and are therefore least likely to be truncated. Thumbnail toolbars are displayed only when thumbnails are being displayed. For instance, if a taskbar button represents a group with more open windows than there is room to display thumbnails for, the UI reverts to a legacy menu rather than thumbnails.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbaraddbuttons#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.ThumbBarUpdateButtons(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.UI.Shell.THUMBBUTTON*)">
            <summary>Shows, enables, disables, or hides buttons in a thumbnail toolbar as required by the window's current state. A thumbnail toolbar is a toolbar embedded in a thumbnail image of a window in a taskbar button flyout.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> The handle of the window whose thumbnail representation contains the toolbar.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarupdatebuttons#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="cButtons">
            <para>Type: <b>UINT</b> The number of buttons defined in the array pointed to by <i>pButton</i>. The maximum number of buttons allowed is 7. This array contains only structures that represent existing buttons that are being updated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarupdatebuttons#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="pButton">
            <para>Type: <b>LPTHUMBBUTTON</b> A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ns-shobjidl_core-thumbbutton">THUMBBUTTON</a> structures. Each <b>THUMBBUTTON</b> defines an individual button. If the button already exists (the <b>iId</b> value is already defined), then that existing button is updated with the information provided in the structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarupdatebuttons#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para>Because there is a limited amount of space in which to display thumbnails, as well as a constantly changing number of thumbnails to display, applications are not guaranteed a specific toolbar size. If display space is low, buttons in the toolbar are truncated from right to left as needed. Therefore, an application should prioritize the commands associated with its buttons to ensure that those of highest priority are to the left and are therefore least likely to be truncated. Thumbnail toolbars are displayed only when thumbnails are being displayed on the taskbar. For instance, if a taskbar button represents a group with more open windows than there is room to display thumbnails for, the UI reverts to a legacy menu rather than thumbnails.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarupdatebuttons#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.ThumbBarSetImageList(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.HIMAGELIST)">
            <summary>Specifies an image list that contains button images for a toolbar embedded in a thumbnail image of a window in a taskbar button flyout.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> The handle of the window whose thumbnail representation contains the toolbar to be updated. This handle must belong to the calling process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarsetimagelist#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="himl">
            <para>Type: <b>HIMAGELIST</b> The handle of the image list that contains all button images to be used in the toolbar.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarsetimagelist#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para>Applications must provide these button images:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarsetimagelist#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.SetOverlayIcon(Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HICON,Windows.Win32.Foundation.PCWSTR)">
            <summary>Applies an overlay to a taskbar button to indicate application status or a notification to the user.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> The handle of the window whose associated taskbar button receives the overlay. This handle must belong to a calling process associated with the button's application and must be a valid <b>HWND</b> or the call is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setoverlayicon#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="hIcon">
            <para>Type: <b>HICON</b> The handle of an icon to use as the overlay. This should be a small icon, measuring 16x16 pixels at 96 dpi. If an overlay icon is already applied to the taskbar button, that existing overlay is replaced.</para>
            <para>This value can be <b>NULL</b>. How a <b>NULL</b> value is handled depends on whether the taskbar button represents a single window or a group of windows. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setoverlayicon#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="pszDescription">
            <para>Type: <b>LPCWSTR</b> A pointer to a string that provides an alt text version of the information conveyed by the overlay, for accessibility purposes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setoverlayicon#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para>In versions of Windows earlier than Windows7, applications often used icons in the notification area of the taskbar to display application status and notifications to the user. The Windows7 taskbar allows an application to provide that same sort of user feedback through its taskbar button, centralizing more of the application information in one place. These overlays are similar to existing overlays used for shortcut icons or security notifications, displayed at the lower-right corner of the button. The following illustration shows an overlay (the small, green square that indicates the user status as "Available") applied to the far-right taskbar button. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setoverlayicon#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.SetThumbnailTooltip(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.PCWSTR)">
            <summary>Specifies or updates the text of the tooltip that is displayed when the mouse pointer rests on an individual preview thumbnail in a taskbar button flyout.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> The handle to the window whose thumbnail displays the tooltip. This handle must belong to the calling process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setthumbnailtooltip#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="pszTip">
            <para>Type: <b>LPCWSTR</b> The pointer to the text to be displayed in the tooltip. This value can be <b>NULL</b>, in which case the title of the window specified by <i>hwnd</i> is used as the tooltip.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setthumbnailtooltip#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setthumbnailtooltip">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList3.SetThumbnailClip(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)">
            <summary>Selects a portion of a window's client area to display as that window's thumbnail in the taskbar.</summary>
            <param name="hwnd">
            <para>Type: <b>HWND</b> The handle to a window represented in the taskbar.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setthumbnailclip#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="prcClip">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b> A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies a selection within the window's client area, relative to the upper-left corner of that client area. To clear a clip that is already in place and return to the default display of the thumbnail, set this parameter to <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setthumbnailclip#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-setthumbnailclip">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.UI.Shell.ITaskbarList4.SetTabProperties(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Shell.STPFLAG)">
            <summary>Allows a tab to specify whether the main application frame window or the tab window should be used as a thumbnail or in the peek feature under certain circumstances.</summary>
            <param name="hwndTab">
            <para>Type: <b>HWND</b> The handle of the tab window that is to have properties set. This handle must already be registered through <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-registertab">RegisterTab</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist4-settabproperties#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <param name="stpFlags">
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-stpflag">STPFLAG</a></b> One or more members of the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-stpflag">STPFLAG</a> enumeration that specify the displayed thumbnail and peek image source of the tab thumbnail.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist4-settabproperties#parameters">Read more on learn.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
            </returns>
            <remarks>An application might want to use the thumbnail or peek representation of its associated parent window if the application cannot generate its own thumbnail for a tab or for its active tab content (such as an animation) to appear live.</remarks>
        </member>
        <member name="T:Windows.Win32.UI.Shell.STPFLAG">
            <summary>Used by the ITaskbarList4::SetTabProperties method to specify tab properties.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ne-shobjidl_core-stpflag">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.STPFLAG.STPF_NONE">
            <summary>No specific property values are specified. The default behavior is used: the tab window provides a thumbnail and peek image, either live or static as appropriate.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.STPFLAG.STPF_USEAPPTHUMBNAILALWAYS">
            <summary>Always use the thumbnail provided by the main application frame window rather than a thumbnail provided by the individual tab window. Do not combine this value with STPF_USEAPPTHUMBNAILWHENACTIVE; doing so will result in an error.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.STPFLAG.STPF_USEAPPTHUMBNAILWHENACTIVE">
            <summary>When the application tab is active and a live representation of its window is available, use the main application's frame window thumbnail. At other times, use the tab window thumbnail. Do not combine this value with STPF_USEAPPTHUMBNAILALWAYS; doing so will result in an error.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.STPFLAG.STPF_USEAPPPEEKALWAYS">
            <summary>Always use the peek image provided by the main application frame window rather than a peek image provided by the individual tab window. Do not combine this value with STPF_USEAPPPEEKWHENACTIVE; doing so will result in an error.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.STPFLAG.STPF_USEAPPPEEKWHENACTIVE">
            <summary>When the application tab is active and a live representation of its window is available, show the main application frame in the peek feature. At other times, use the tab window. Do not combine this value with STPF_USEAPPPEEKALWAYS; doing so will result in an error.</summary>
        </member>
        <member name="T:Windows.Win32.UI.Shell.THUMBBUTTON">
            <summary>Used by methods of the ITaskbarList3 interface to define buttons used in a toolbar embedded in a window's thumbnail representation.</summary>
            <remarks>
            <para>When a button is clicked, a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> message that contains the button ID is sent to the associated application window. The application handles whatever action it has assigned to the button. <h3><a id="Button_Images"></a><a id="button_images"></a><a id="BUTTON_IMAGES"></a>Button Images</h3> When using an icon, specified through the <b>hIcon</b> member, the taskbar makes its own copy of the icon. It is the caller's responsibility to free the handle it passed in <b>hIcon</b> when it is no longer needed.</para>
            <para>If both an icon and an image list are specified for a button's image, the icon is used if possible. If for some reason the attempt to retrieve the icon fails, the image from the image list is used. Applications must provide these button images: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-thumbbutton#">Read more on learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTON.dwMask">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-thumbbuttonmask">THUMBBUTTONMASK</a></b> A combination of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-thumbbuttonmask">THUMBBUTTONMASK</a> values that specify which members of this structure contain valid data; other members are ignored, with the exception of <b>iId</b>, which is always required.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-thumbbutton#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTON.iId">
            <summary>
            <para>Type: <b>UINT</b> The application-defined identifier of the button, unique within the toolbar.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-thumbbutton#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTON.iBitmap">
            <summary>
            <para>Type: <b>UINT</b> The zero-based index of the button image within the image list set through <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-itaskbarlist3-thumbbarsetimagelist">ITaskbarList3::ThumbBarSetImageList</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-thumbbutton#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTON.hIcon">
            <summary>
            <para>Type: <b>HICON</b> The handle of an icon to use as the button image.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-thumbbutton#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTON.szTip">
            <summary>
            <para>Type: <b>WCHAR[260]</b> A wide character array that contains the text of the button's tooltip, displayed when the mouse pointer hovers over the button.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-thumbbutton#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTON.dwFlags">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-thumbbuttonflags">THUMBBUTTONFLAGS</a></b> A combination of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-thumbbuttonflags">THUMBBUTTONFLAGS</a> values that control specific states and behaviors of the button.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ns-shobjidl_core-thumbbutton#members">Read more on learn.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Shell.THUMBBUTTONFLAGS">
            <summary>Used by THUMBBUTTON to control specific states and behaviors of the button.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ne-shobjidl_core-thumbbuttonflags">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONFLAGS.THBF_ENABLED">
            <summary>The button is active and available to the user.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONFLAGS.THBF_DISABLED">
            <summary>The button is disabled. It is present, but has a visual state that indicates that it will not respond to user action.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONFLAGS.THBF_DISMISSONCLICK">
            <summary>When the button is clicked, the taskbar button's flyout closes immediately.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONFLAGS.THBF_NOBACKGROUND">
            <summary>Do not draw a button border, use only the image.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONFLAGS.THBF_HIDDEN">
            <summary>The button is not shown to the user.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONFLAGS.THBF_NONINTERACTIVE">
            <summary>The button is enabled but not interactive; no pressed button state is drawn. This value is intended for instances where the button is used in a notification.</summary>
        </member>
        <member name="T:Windows.Win32.UI.Shell.THUMBBUTTONMASK">
            <summary>Used by the THUMBBUTTON structure to specify which members of that structure contain valid data.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/ne-shobjidl_core-thumbbuttonmask">Learn more about this API from learn.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONMASK.THB_BITMAP">
            <summary>The <b>iBitmap</b> member contains valid information.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONMASK.THB_ICON">
            <summary>The <b>hIcon</b> member contains valid information.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONMASK.THB_TOOLTIP">
            <summary>The <b>szTip</b> member contains valid information.</summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.THUMBBUTTONMASK.THB_FLAGS">
            <summary>The <b>dwFlags</b> member contains valid information.</summary>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList3_Extensions.ThumbBarAddButtons(Windows.Win32.UI.Shell.ITaskbarList3,Windows.Win32.Foundation.HWND,System.ReadOnlySpan{Windows.Win32.UI.Shell.THUMBBUTTON})">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList3.ThumbBarAddButtons(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.UI.Shell.THUMBBUTTON*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList3_Extensions.ThumbBarUpdateButtons(Windows.Win32.UI.Shell.ITaskbarList3,Windows.Win32.Foundation.HWND,System.ReadOnlySpan{Windows.Win32.UI.Shell.THUMBBUTTON})">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList3.ThumbBarUpdateButtons(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.UI.Shell.THUMBBUTTON*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList3_Extensions.ThumbBarSetImageList(Windows.Win32.UI.Shell.ITaskbarList3,Windows.Win32.Foundation.HWND,System.Runtime.InteropServices.SafeHandle)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList3.ThumbBarSetImageList(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.HIMAGELIST)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList3_Extensions.SetOverlayIcon(Windows.Win32.UI.Shell.ITaskbarList3,Windows.Win32.Foundation.HWND,System.Runtime.InteropServices.SafeHandle,System.String)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList3.SetOverlayIcon(Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HICON,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList3_Extensions.SetThumbnailTooltip(Windows.Win32.UI.Shell.ITaskbarList3,Windows.Win32.Foundation.HWND,System.String)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList3.SetThumbnailTooltip(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList3_Extensions.SetThumbnailClip(Windows.Win32.UI.Shell.ITaskbarList3,Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList3.SetThumbnailClip(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList4_Extensions.ThumbBarAddButtons(Windows.Win32.UI.Shell.ITaskbarList4,Windows.Win32.Foundation.HWND,System.ReadOnlySpan{Windows.Win32.UI.Shell.THUMBBUTTON})">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList4.ThumbBarAddButtons(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.UI.Shell.THUMBBUTTON*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList4_Extensions.ThumbBarUpdateButtons(Windows.Win32.UI.Shell.ITaskbarList4,Windows.Win32.Foundation.HWND,System.ReadOnlySpan{Windows.Win32.UI.Shell.THUMBBUTTON})">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList4.ThumbBarUpdateButtons(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.UI.Shell.THUMBBUTTON*)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList4_Extensions.ThumbBarSetImageList(Windows.Win32.UI.Shell.ITaskbarList4,Windows.Win32.Foundation.HWND,System.Runtime.InteropServices.SafeHandle)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList4.ThumbBarSetImageList(Windows.Win32.Foundation.HWND,Windows.Win32.UI.Controls.HIMAGELIST)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList4_Extensions.SetOverlayIcon(Windows.Win32.UI.Shell.ITaskbarList4,Windows.Win32.Foundation.HWND,System.Runtime.InteropServices.SafeHandle,System.String)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList4.SetOverlayIcon(Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HICON,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList4_Extensions.SetThumbnailTooltip(Windows.Win32.UI.Shell.ITaskbarList4,Windows.Win32.Foundation.HWND,System.String)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList4.SetThumbnailTooltip(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.UI_Shell_ITaskbarList4_Extensions.SetThumbnailClip(Windows.Win32.UI.Shell.ITaskbarList4,Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT@)">
            <inheritdoc cref="M:Windows.Win32.UI.Shell.ITaskbarList4.SetThumbnailClip(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.RECT*)"/>
        </member>
        <member name="T:XamlGeneratedNamespace.GeneratedInternalTypeHelper">
            <summary>
            GeneratedInternalTypeHelper
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.CreateInstance(System.Type,System.Globalization.CultureInfo)">
            <summary>
            CreateInstance
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.GetPropertyValue(System.Reflection.PropertyInfo,System.Object,System.Globalization.CultureInfo)">
            <summary>
            GetPropertyValue
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.SetPropertyValue(System.Reflection.PropertyInfo,System.Object,System.Object,System.Globalization.CultureInfo)">
            <summary>
            SetPropertyValue
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.CreateDelegate(System.Type,System.Object,System.String)">
            <summary>
            CreateDelegate
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.AddEventHandler(System.Reflection.EventInfo,System.Object,System.Delegate)">
            <summary>
            AddEventHandler
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute">
            <summary>
            Specifies the priority of a member in overload resolution.
            When unspecified, the default priority is 0.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute"/> class.
            </summary>
            <param name="priority">The priority of the attributed member. Higher numbers are prioritized, lower numbers are deprioritized. 0 is the default if no attribute is present.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.Priority">
            <summary>
            The priority of the member.
            </summary>
        </member>
    </members>
</doc>
